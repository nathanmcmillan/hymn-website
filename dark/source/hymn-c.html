<!DOCTYPE html>
<html>
  <head>
    <title>hymn.c</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" type="text/css" href="/dark/css/index.css" />
  </head>

  <body>
    <header>
      <div class="header">
        <div class="header-left">Hymn Script</div>
        <div>
          <a href="/dark/index.html">Home</a>
          <a href="/dark/learn.html">Learn</a>
          <a href="/dark/play.html">Play</a>
          <a href="https://github.com/nathanmcmillan/hymn-lang/tags">Download</a>
          <a href="/dark/source">Source</a>
          <a href="/source/hymn-c.html">Light</a>
        </div>
      </div>
    </header>
    <main id="index">
      <h1 class="centered-header">hymn.c</h1>
      <section>
        <hr class="padding" />
        <div class="code"><pre><code><comment>/* This Source Code Form is subject to the terms of the Mozilla Public</comment>
<comment> * License, v. 2.0. If a copy of the MPL was not distributed with this</comment>
<comment> * file, You can obtain one at https://mozilla.org/MPL/2.0/. */</comment>

<constant>#include</constant> <string>&quot;hymn.h&quot;</string>

<constant>void</constant> <keyword>*</keyword>hymn_malloc(<constant>size_t</constant> size) {
    <constant>void</constant> <keyword>*</keyword>mem <keyword>=</keyword> malloc(size);
    <keyword>if</keyword> (mem) {
        <keyword>return</keyword> mem;
    }
    <constant>fprintf</constant>(stderr, <string>&quot;malloc failed.\n&quot;</string>);
    exit(<constant>1</constant>);
}

<constant>void</constant> <keyword>*</keyword>hymn_calloc(<constant>size_t</constant> count, <constant>size_t</constant> size) {
    <constant>void</constant> <keyword>*</keyword>mem <keyword>=</keyword> calloc(count, size);
    <keyword>if</keyword> (mem) {
        <keyword>return</keyword> mem;
    }
    <constant>fprintf</constant>(stderr, <string>&quot;calloc failed.\n&quot;</string>);
    exit(<constant>1</constant>);
}

<constant>void</constant> <keyword>*</keyword>hymn_realloc(<constant>void</constant> <keyword>*</keyword>mem, <constant>size_t</constant> size) {
    mem <keyword>=</keyword> realloc(mem, size);
    <keyword>if</keyword> (mem) {
        <keyword>return</keyword> mem;
    }
    <constant>fprintf</constant>(stderr, <string>&quot;realloc failed.\n&quot;</string>);
    exit(<constant>1</constant>);
}

<constant>void</constant> <keyword>*</keyword>hymn_malloc_<constant>int</constant>(<constant>int</constant> count, <constant>size_t</constant> size) {
    <keyword>if</keyword> (count <keyword>&lt;</keyword> <constant>0</constant>) {
        <constant>fprintf</constant>(stderr, <string>&quot;malloc negative count.\n&quot;</string>);
        exit(<constant>1</constant>);
    }
    <constant>void</constant> <keyword>*</keyword>mem <keyword>=</keyword> malloc((<constant>size_t</constant>)count <keyword>*</keyword> size);
    <keyword>if</keyword> (mem) {
        <keyword>return</keyword> mem;
    }
    <constant>fprintf</constant>(stderr, <string>&quot;malloc failed.\n&quot;</string>);
    exit(<constant>1</constant>);
}

<constant>void</constant> <keyword>*</keyword>hymn_calloc_<constant>int</constant>(<constant>int</constant> count, <constant>size_t</constant> size) {
    <keyword>if</keyword> (count <keyword>&lt;</keyword> <constant>0</constant>) {
        <constant>fprintf</constant>(stderr, <string>&quot;calloc negative count.\n&quot;</string>);
        exit(<constant>1</constant>);
    }
    <constant>void</constant> <keyword>*</keyword>mem <keyword>=</keyword> calloc((<constant>size_t</constant>)count, size);
    <keyword>if</keyword> (mem) {
        <keyword>return</keyword> mem;
    }
    <constant>fprintf</constant>(stderr, <string>&quot;calloc failed.\n&quot;</string>);
    exit(<constant>1</constant>);
}

<constant>void</constant> <keyword>*</keyword>hymn_realloc_<constant>int</constant>(<constant>void</constant> <keyword>*</keyword>mem, <constant>int</constant> count, <constant>size_t</constant> size) {
    <keyword>if</keyword> (count <keyword>&lt;</keyword> <constant>0</constant>) {
        <constant>fprintf</constant>(stderr, <string>&quot;realloc negative count.\n&quot;</string>);
        exit(<constant>1</constant>);
    }
    mem <keyword>=</keyword> realloc(mem, (<constant>size_t</constant>)count <keyword>*</keyword> size);
    <keyword>if</keyword> (mem) {
        <keyword>return</keyword> mem;
    }
    <constant>fprintf</constant>(stderr, <string>&quot;realloc failed.\n&quot;</string>);
    exit(<constant>1</constant>);
}

<keyword>static</keyword> <constant>void</constant> hymn_mem_copy(<constant>void</constant> <keyword>*</keyword>dest, <constant>void</constant> <keyword>*</keyword>src, <constant>int</constant> count, <constant>size_t</constant> size) {
    <keyword>if</keyword> (count <keyword>&lt;</keyword> <constant>0</constant>) {
        <constant>fprintf</constant>(stderr, <string>&quot;memcpy negative count.\n&quot;</string>);
        exit(<constant>1</constant>);
    }
    <constant>memcpy</constant>(dest, src, (<constant>size_t</constant>)count <keyword>*</keyword> size);
}

<keyword>static</keyword> HymnStringHead <keyword>*</keyword>string_head_init(<constant>size_t</constant> length, <constant>size_t</constant> capacity) {
    <constant>size_t</constant> memory <keyword>=</keyword> sizeof(HymnStringHead) <keyword>+</keyword> capacity <keyword>+</keyword> <constant>1</constant>;
    HymnStringHead <keyword>*</keyword>head <keyword>=</keyword> (HymnStringHead <keyword>*</keyword>)hymn_malloc(memory);
    memset(head, <constant>0</constant>, memory);
    head-&gt;length = length;
    head-&gt;capacity = capacity;
    <keyword>return</keyword> head;
}

HymnString <keyword>*</keyword>hymn_new_string_with_capacity(<constant>size_t</constant> capacity) {
    HymnStringHead <keyword>*</keyword>head <keyword>=</keyword> string_head_init(<constant>0</constant>, capacity);
    <keyword>return</keyword> (HymnString <keyword>*</keyword>)(head <keyword>+</keyword> <constant>1</constant>);
}

HymnString <keyword>*</keyword>hymn_new_string_with_length(<keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>chars, <constant>size_t</constant> length) {
    HymnStringHead <keyword>*</keyword>head <keyword>=</keyword> string_head_init(length, length);
    <constant>char</constant> <keyword>*</keyword>string <keyword>=</keyword> (<constant>char</constant> <keyword>*</keyword>)(head <keyword>+</keyword> <constant>1</constant>);
    <constant>memcpy</constant>(string, chars, length);
    <keyword>return</keyword> (HymnString <keyword>*</keyword>)string;
}

HymnString <keyword>*</keyword>hymn_new_empty_string(<constant>size_t</constant> length) {
    HymnStringHead <keyword>*</keyword>head <keyword>=</keyword> string_head_init(length, length);
    <constant>char</constant> <keyword>*</keyword>string <keyword>=</keyword> (<constant>char</constant> <keyword>*</keyword>)(head <keyword>+</keyword> <constant>1</constant>);
    <keyword>return</keyword> (HymnString <keyword>*</keyword>)string;
}

HymnString <keyword>*</keyword>hymn_new_string(<keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>chars) {
    <constant>size_t</constant> length <keyword>=</keyword> strlen(chars);
    <keyword>return</keyword> hymn_new_string_with_length(chars, length);
}

HymnString <keyword>*</keyword>hymn_substring(<keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>init, <constant>size_t</constant> start, <constant>size_t</constant> end) {
    <constant>size_t</constant> length <keyword>=</keyword> end <keyword>-</keyword> start;
    HymnStringHead <keyword>*</keyword>head <keyword>=</keyword> string_head_init(length, length);
    <constant>char</constant> <keyword>*</keyword>string <keyword>=</keyword> (<constant>char</constant> <keyword>*</keyword>)(head <keyword>+</keyword> <constant>1</constant>);
    <constant>memcpy</constant>(string, <keyword>&</keyword>init[start], length);
    string[length] <keyword>=</keyword> <string>'\0'</string>;
    <keyword>return</keyword> (HymnString <keyword>*</keyword>)string;
}

<keyword>static</keyword> <constant>bool</constant> space(<constant>char</constant> c) {
    <keyword>return</keyword> c <keyword>==</keyword> <string>' '</string> || c <keyword>==</keyword> <string>'\t'</string> || c <keyword>==</keyword> <string>'\n'</string> || c <keyword>==</keyword> <string>'\r'</string>;
}

<constant>void</constant> hymn_string_trim(HymnString <keyword>*</keyword>string) {
    <constant>size_t</constant> len <keyword>=</keyword> hymn_string_len(string);
    <constant>size_t</constant> start <keyword>=</keyword> <constant>0</constant>;
    <keyword>while</keyword> (start <keyword>&lt;</keyword> len) {
        <constant>char</constant> c <keyword>=</keyword> string[start];
        <keyword>if</keyword> (<keyword>!</keyword>space(c)) {
            <keyword>break</keyword>;
        }
        start++;
    }
    <keyword>if</keyword> (start <keyword>==</keyword> len) {
        hymn_string_zero(string);
    } <keyword>else</keyword> {
        <constant>size_t</constant> end <keyword>=</keyword> len <keyword>-</keyword> <constant>1</constant>;
        <keyword>while</keyword> (end <keyword>&gt;</keyword> start) {
            <constant>char</constant> c <keyword>=</keyword> string[end];
            <keyword>if</keyword> (<keyword>!</keyword>space(c)) {
                <keyword>break</keyword>;
            }
            end--;
        }
        end++;
        <constant>size_t</constant> offset <keyword>=</keyword> start;
        <constant>size_t</constant> size <keyword>=</keyword> end <keyword>-</keyword> start;
        <keyword>for</keyword> (<constant>size_t</constant> i <keyword>=</keyword> <constant>0</constant>; i <keyword>&lt;</keyword> size; i++) {
            string[i] <keyword>=</keyword> string[offset++];
        }
        HymnStringHead <keyword>*</keyword>head <keyword>=</keyword> hymn_string_head(string);
        head-&gt;length = size;
        string[size] <keyword>=</keyword> <string>'\0'</string>;
    }
}

HymnString <keyword>*</keyword>hymn_string_copy(HymnString <keyword>*</keyword>string) {
    HymnStringHead <keyword>*</keyword>head <keyword>=</keyword> hymn_string_head(string);
    <keyword>return</keyword> hymn_new_string_with_length(string, head-&gt;length);
}

<constant>void</constant> hymn_string_delete(HymnString <keyword>*</keyword>string) {
    <keyword>if</keyword> (string <keyword>==</keyword> <constant>NULL</constant>) {
        <keyword>return</keyword>;
    }
    <constant>free</constant>((<constant>char</constant> <keyword>*</keyword>)string <keyword>-</keyword> sizeof(HymnStringHead));
}

<constant>void</constant> hymn_string_zero(HymnString <keyword>*</keyword>string) {
    HymnStringHead <keyword>*</keyword>head <keyword>=</keyword> hymn_string_head(string);
    head-&gt;length = <constant>0</constant>;
    string[<constant>0</constant>] <keyword>=</keyword> <string>'\0'</string>;
}

<keyword>static</keyword> HymnStringHead <keyword>*</keyword>string_resize(HymnStringHead <keyword>*</keyword>head, <constant>size_t</constant> capacity) {
    <constant>size_t</constant> memory <keyword>=</keyword> sizeof(HymnStringHead) <keyword>+</keyword> capacity <keyword>+</keyword> <constant>1</constant>;
    HymnStringHead <keyword>*</keyword>new <keyword>=</keyword> hymn_realloc(head, memory);
    new-&gt;capacity = capacity;
    <keyword>return</keyword> new;
}

HymnString <keyword>*</keyword>hymn_string_append(HymnString <keyword>*</keyword>string, <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>b) {
    HymnStringHead <keyword>*</keyword>head <keyword>=</keyword> hymn_string_head(string);
    <constant>size_t</constant> len_a <keyword>=</keyword> head-&gt;length;
    <constant>size_t</constant> len_b <keyword>=</keyword> strlen(b);
    <constant>size_t</constant> len <keyword>=</keyword> len_a <keyword>+</keyword> len_b;
    <keyword>if</keyword> (len <keyword>&gt;</keyword> head-&gt;capacity) {
        head <keyword>=</keyword> string_resize(head, len <keyword>*</keyword> <constant>2</constant>);
    }
    head-&gt;length = len;
    <constant>char</constant> <keyword>*</keyword>s <keyword>=</keyword> (<constant>char</constant> <keyword>*</keyword>)(head <keyword>+</keyword> <constant>1</constant>);
    <constant>memcpy</constant>(s <keyword>+</keyword> len_a, b, len_b <keyword>+</keyword> <constant>1</constant>);
    s[len] <keyword>=</keyword> <string>'\0'</string>;
    <keyword>return</keyword> (HymnString <keyword>*</keyword>)s;
}

HymnString <keyword>*</keyword>hymn_string_append_<constant>char</constant>(HymnString <keyword>*</keyword>string, <keyword>const</keyword> <constant>char</constant> b) {
    HymnStringHead <keyword>*</keyword>head <keyword>=</keyword> hymn_string_head(string);
    <constant>size_t</constant> len <keyword>=</keyword> head-&gt;length + <constant>1</constant>;
    <keyword>if</keyword> (len <keyword>&gt;</keyword> head-&gt;capacity) {
        head <keyword>=</keyword> string_resize(head, len <keyword>*</keyword> <constant>2</constant>);
    }
    head-&gt;length = len;
    <constant>char</constant> <keyword>*</keyword>s <keyword>=</keyword> (<constant>char</constant> <keyword>*</keyword>)(head <keyword>+</keyword> <constant>1</constant>);
    s[len <keyword>-</keyword> <constant>1</constant>] <keyword>=</keyword> b;
    s[len] <keyword>=</keyword> <string>'\0'</string>;
    <keyword>return</keyword> (HymnString <keyword>*</keyword>)s;
}

HymnString <keyword>*</keyword>hymn_string_append_substring(HymnString <keyword>*</keyword>string, <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>b, <constant>size_t</constant> start, <constant>size_t</constant> end) {
    HymnStringHead <keyword>*</keyword>head <keyword>=</keyword> hymn_string_head(string);
    <constant>size_t</constant> len_a <keyword>=</keyword> head-&gt;length;
    <constant>size_t</constant> len_b <keyword>=</keyword> end <keyword>-</keyword> start;
    <constant>size_t</constant> len <keyword>=</keyword> len_a <keyword>+</keyword> len_b;
    <keyword>if</keyword> (len <keyword>&gt;</keyword> head-&gt;capacity) {
        head <keyword>=</keyword> string_resize(head, len <keyword>*</keyword> <constant>2</constant>);
    }
    head-&gt;length = len;
    <constant>char</constant> <keyword>*</keyword>s <keyword>=</keyword> (<constant>char</constant> <keyword>*</keyword>)(head <keyword>+</keyword> <constant>1</constant>);
    <constant>memcpy</constant>(s <keyword>+</keyword> len_a, <keyword>&</keyword>b[start], len_b);
    s[len] <keyword>=</keyword> <string>'\0'</string>;
    <keyword>return</keyword> (HymnString <keyword>*</keyword>)s;
}

<keyword>static</keyword> <constant>bool</constant> string_starts_with(<keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>t, <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>s) {
    <constant>size_t</constant> tlen <keyword>=</keyword> strlen(t);
    <constant>size_t</constant> slen <keyword>=</keyword> strlen(s);
    <keyword>return</keyword> tlen <keyword>&lt;</keyword> slen ? <constant>false</constant> : memcmp(t, s, slen) <keyword>==</keyword> <constant>0</constant>;
}

<constant>bool</constant> hymn_string_starts_with(HymnString <keyword>*</keyword>s, <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>using) {
    <constant>size_t</constant> slen <keyword>=</keyword> hymn_string_len(s);
    <constant>size_t</constant> ulen <keyword>=</keyword> strlen(using);
    <keyword>return</keyword> slen <keyword>&lt;</keyword> ulen ? <constant>false</constant> : memcmp(s, using, ulen) <keyword>==</keyword> <constant>0</constant>;
}

<keyword>static</keyword> <constant>bool</constant> string_find(HymnString <keyword>*</keyword>string, HymnString <keyword>*</keyword>sub, <constant>size_t</constant> <keyword>*</keyword>out) {
    HymnStringHead <keyword>*</keyword>head <keyword>=</keyword> hymn_string_head(string);
    HymnStringHead <keyword>*</keyword>head_sub <keyword>=</keyword> hymn_string_head(sub);
    <constant>size_t</constant> len <keyword>=</keyword> head-&gt;length;
    <constant>size_t</constant> len_sub <keyword>=</keyword> head_sub-&gt;length;
    <keyword>if</keyword> (len_sub <keyword>&gt;</keyword> len) {
        <keyword>return</keyword> <constant>false</constant>;
    } <keyword>else</keyword> <keyword>if</keyword> (len <keyword>==</keyword> <constant>0</constant>) {
        <keyword>*</keyword>out <keyword>=</keyword> <constant>0</constant>;
        <keyword>return</keyword> <constant>true</constant>;
    }
    <constant>size_t</constant> end <keyword>=</keyword> len <keyword>-</keyword> len_sub <keyword>+</keyword> <constant>1</constant>;
    <keyword>for</keyword> (<constant>size_t</constant> i <keyword>=</keyword> <constant>0</constant>; i <keyword>&lt;</keyword> end; i++) {
        <constant>bool</constant> match <keyword>=</keyword> <constant>true</constant>;
        <keyword>for</keyword> (<constant>size_t</constant> k <keyword>=</keyword> <constant>0</constant>; k <keyword>&lt;</keyword> len_sub; k++) {
            <keyword>if</keyword> (sub[k] <keyword>!=</keyword> string[i <keyword>+</keyword> k]) {
                match <keyword>=</keyword> <constant>false</constant>;
                <keyword>break</keyword>;
            }
        }
        <keyword>if</keyword> (match) {
            <keyword>*</keyword>out <keyword>=</keyword> i;
            <keyword>return</keyword> <constant>true</constant>;
        }
    }
    <keyword>return</keyword> <constant>false</constant>;
}

HymnString <keyword>*</keyword>hymn_string_replace(HymnString <keyword>*</keyword>string, <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>find, <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>replace) {
    HymnStringHead <keyword>*</keyword>head <keyword>=</keyword> hymn_string_head(string);
    <constant>size_t</constant> len <keyword>=</keyword> head-&gt;length;
    <constant>size_t</constant> len_sub <keyword>=</keyword> strlen(find);
    <keyword>if</keyword> (len <keyword>==</keyword> <constant>0</constant> || len_sub <keyword>&gt;</keyword> len) {
        <keyword>return</keyword> hymn_new_string(<string>&quot;&quot;</string>);
    }
    HymnString <keyword>*</keyword>out <keyword>=</keyword> hymn_new_string_with_capacity(len);
    <constant>size_t</constant> end <keyword>=</keyword> len <keyword>-</keyword> len_sub <keyword>+</keyword> <constant>1</constant>;
    <constant>size_t</constant> pos <keyword>=</keyword> <constant>0</constant>;
    <keyword>for</keyword> (<constant>size_t</constant> i <keyword>=</keyword> <constant>0</constant>; i <keyword>&lt;</keyword> end; i++) {
        <constant>bool</constant> match <keyword>=</keyword> <constant>true</constant>;
        <keyword>for</keyword> (<constant>size_t</constant> k <keyword>=</keyword> <constant>0</constant>; k <keyword>&lt;</keyword> len_sub; k++) {
            <keyword>if</keyword> (find[k] <keyword>!=</keyword> string[i <keyword>+</keyword> k]) {
                match <keyword>=</keyword> <constant>false</constant>;
                <keyword>break</keyword>;
            }
        }
        <keyword>if</keyword> (match) {
            out <keyword>=</keyword> hymn_string_append_substring(out, string, pos, i);
            out <keyword>=</keyword> hymn_string_append(out, replace);
            i <keyword>+</keyword><keyword>=</keyword> len_sub;
            pos <keyword>=</keyword> i;
            i--;
        }
    }
    <keyword>if</keyword> (pos <keyword>&lt;</keyword> len) {
        out <keyword>=</keyword> hymn_string_append_substring(out, string, pos, len);
    }
    <keyword>return</keyword> out;
}

<keyword>static</keyword> HymnString <keyword>*</keyword><constant>char</constant>_to_string(<constant>char</constant> ch) {
    HymnString <keyword>*</keyword>s <keyword>=</keyword> hymn_new_empty_string(<constant>1</constant>);
    s[<constant>0</constant>] <keyword>=</keyword> ch;
    <keyword>return</keyword> s;
}

HymnString <keyword>*</keyword>hymn_<constant>int</constant>_to_string(HymnInt number) {
    <constant>size_t</constant> len <keyword>=</keyword> (<constant>size_t</constant>)snprintf(<constant>NULL</constant>, <constant>0</constant>, <string>&quot;%lld&quot;</string>, number);
    <constant>char</constant> <keyword>*</keyword>str <keyword>=</keyword> hymn_malloc(len <keyword>+</keyword> <constant>1</constant>);
    snprintf(str, len <keyword>+</keyword> <constant>1</constant>, <string>&quot;%lld&quot;</string>, number);
    HymnString <keyword>*</keyword>s <keyword>=</keyword> hymn_new_string_with_length(str, len);
    <constant>free</constant>(str);
    <keyword>return</keyword> s;
}

HymnString <keyword>*</keyword>hymn_<constant>float</constant>_to_string(HymnFloat number) {
    <constant>size_t</constant> len <keyword>=</keyword> (<constant>size_t</constant>)snprintf(<constant>NULL</constant>, <constant>0</constant>, <string>&quot;%g&quot;</string>, number);
    <constant>char</constant> <keyword>*</keyword>str <keyword>=</keyword> hymn_malloc(len <keyword>+</keyword> <constant>1</constant>);
    snprintf(str, len <keyword>+</keyword> <constant>1</constant>, <string>&quot;%g&quot;</string>, number);
    HymnString <keyword>*</keyword>s <keyword>=</keyword> hymn_new_string_with_length(str, len);
    <constant>free</constant>(str);
    <keyword>return</keyword> s;
}

<keyword>static</keyword> <constant>char</constant> <keyword>*</keyword>string_to_chars(HymnString <keyword>*</keyword>this) {
    <constant>size_t</constant> len <keyword>=</keyword> hymn_string_len(this);
    <constant>char</constant> <keyword>*</keyword>s <keyword>=</keyword> hymn_malloc((len <keyword>+</keyword> <constant>1</constant>) <keyword>*</keyword> sizeof(<constant>char</constant>));
    <constant>memcpy</constant>(s, this, len);
    s[len] <keyword>=</keyword> <string>'\0'</string>;
    <keyword>return</keyword> s;
}

HymnString <keyword>*</keyword>hymn_string_format(<keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>format, ...) {
    va_list args;

    va_start(args, format);
    <constant>size_t</constant> len <keyword>=</keyword> (<constant>size_t</constant>)vsnprintf(<constant>NULL</constant>, <constant>0</constant>, format, args);
    va_end(args);
    <constant>char</constant> <keyword>*</keyword>chars <keyword>=</keyword> hymn_malloc((len <keyword>+</keyword> <constant>1</constant>) <keyword>*</keyword> sizeof(<constant>char</constant>));
    va_start(args, format);
    len <keyword>=</keyword> (<constant>size_t</constant>)vsnprintf(chars, len <keyword>+</keyword> <constant>1</constant>, format, args);
    va_end(args);
    HymnString <keyword>*</keyword>str <keyword>=</keyword> hymn_new_string_with_length(chars, len);
    <constant>free</constant>(chars);
    <keyword>return</keyword> str;
}

<keyword>static</keyword> HymnString <keyword>*</keyword>string_append_format(HymnString <keyword>*</keyword>this, <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>format, ...) {
    va_list args;

    va_start(args, format);
    <constant>size_t</constant> len <keyword>=</keyword> (<constant>size_t</constant>)vsnprintf(<constant>NULL</constant>, <constant>0</constant>, format, args);
    va_end(args);
    <constant>char</constant> <keyword>*</keyword>chars <keyword>=</keyword> hymn_malloc((len <keyword>+</keyword> <constant>1</constant>) <keyword>*</keyword> sizeof(<constant>char</constant>));
    va_start(args, format);
    len <keyword>=</keyword> (<constant>size_t</constant>)vsnprintf(chars, len <keyword>+</keyword> <constant>1</constant>, format, args);
    va_end(args);
    this <keyword>=</keyword> hymn_string_append(this, chars);
    <constant>free</constant>(chars);
    <keyword>return</keyword> this;
}

HymnString <keyword>*</keyword>hymn_working_directory(<constant>void</constant>) {
    <constant>char</constant> path[PATH_MAX];
    <keyword>if</keyword> (getcwd(path, sizeof(path)) <keyword>!=</keyword> <constant>NULL</constant>) {
        <keyword>return</keyword> hymn_new_string(path);
    }
    <keyword>return</keyword> <constant>NULL</constant>;
}

HymnString <keyword>*</keyword>hymn_path_convert(HymnString <keyword>*</keyword>path) {
    <constant>size_t</constant> size <keyword>=</keyword> hymn_string_len(path);
    HymnString <keyword>*</keyword>convert <keyword>=</keyword> hymn_string_copy(path);
    <keyword>for</keyword> (<constant>size_t</constant> i <keyword>=</keyword> <constant>0</constant>; i <keyword>&lt;</keyword> size; i++) {
        <keyword>if</keyword> (convert[i] <keyword>==</keyword> PATH_SEP_OTHER) {
            convert[i] <keyword>=</keyword> PATH_SEP;
        }
    }
    <keyword>return</keyword> convert;
}

HymnString <keyword>*</keyword>hymn_path_normalize(HymnString <keyword>*</keyword>path) {
    <constant>size_t</constant> i <keyword>=</keyword> <constant>0</constant>;
    <constant>size_t</constant> size <keyword>=</keyword> hymn_string_len(path);
    <keyword>if</keyword> (size <keyword>&gt;</keyword> <constant>1</constant> <keyword>&</keyword><keyword>&</keyword> path[<constant>0</constant>] <keyword>==</keyword> <string>'.'</string>) {
        <keyword>if</keyword> (path[<constant>1</constant>] <keyword>==</keyword> <string>'.'</string>) {
            <keyword>if</keyword> (size <keyword>&gt;</keyword> <constant>2</constant> <keyword>&</keyword><keyword>&</keyword> path[<constant>2</constant>] <keyword>==</keyword> PATH_SEP) {
                i <keyword>=</keyword> <constant>3</constant>;
            }
        } <keyword>else</keyword> <keyword>if</keyword> (path[<constant>1</constant>] <keyword>==</keyword> PATH_SEP) {
            i <keyword>=</keyword> <constant>2</constant>;
        }
    }

    <constant>size_t</constant> n <keyword>=</keyword> <constant>0</constant>;
    <constant>char</constant> normal[PATH_MAX];

    <keyword>while</keyword> (i <keyword>&lt;</keyword> size) {
        <keyword>if</keyword> (path[i] <keyword>==</keyword> PATH_SEP) {
            <keyword>if</keyword> (i <keyword>+</keyword> <constant>2</constant> <keyword>&lt;</keyword> size) {
                <keyword>if</keyword> (path[i <keyword>+</keyword> <constant>1</constant>] <keyword>==</keyword> <string>'.'</string> <keyword>&</keyword><keyword>&</keyword> path[i <keyword>+</keyword> <constant>2</constant>] <keyword>==</keyword> PATH_SEP) {
                    i <keyword>+</keyword><keyword>=</keyword> <constant>2</constant>;
                    <keyword>continue</keyword>;
                } <keyword>else</keyword> <keyword>if</keyword> (path[i <keyword>+</keyword> <constant>2</constant>] <keyword>==</keyword> <string>'.'</string> <keyword>&</keyword><keyword>&</keyword> i <keyword>+</keyword> <constant>3</constant> <keyword>&lt;</keyword> size <keyword>&</keyword><keyword>&</keyword> path[i <keyword>+</keyword> <constant>3</constant>] <keyword>==</keyword> PATH_SEP) {
                    <keyword>if</keyword> (n <keyword>&gt;</keyword> <constant>0</constant>) {
                        n--;
                        <keyword>while</keyword> (n <keyword>&gt;</keyword> <constant>0</constant>) {
                            <keyword>if</keyword> (normal[n] <keyword>==</keyword> PATH_SEP) {
                                <keyword>break</keyword>;
                            }
                            n--;
                        }
                    }
                    i <keyword>+</keyword><keyword>=</keyword> <constant>3</constant>;
                    <keyword>continue</keyword>;
                }
            }
        }

        normal[n] <keyword>=</keyword> path[i];
        n++;
        i++;
    }

    normal[n] <keyword>=</keyword> <string>'\0'</string>;
    <keyword>return</keyword> hymn_new_string(normal);
}

HymnString <keyword>*</keyword>hymn_path_parent(HymnString <keyword>*</keyword>path) {
    <constant>size_t</constant> size <keyword>=</keyword> hymn_string_len(path);
    <keyword>if</keyword> (size <keyword>&lt;</keyword> <constant>2</constant>) {
        <keyword>return</keyword> hymn_string_copy(path);
    }
    <constant>size_t</constant> index <keyword>=</keyword> size <keyword>-</keyword> <constant>2</constant>;
    <keyword>while</keyword> (<constant>true</constant>) {
        <keyword>if</keyword> (index <keyword>==</keyword> <constant>0</constant> || path[index] <keyword>==</keyword> PATH_SEP) {
            <keyword>return</keyword> hymn_substring(path, <constant>0</constant>, index);
        }
        index--;
    }
}

HymnString <keyword>*</keyword>hymn_path_absolute(HymnString <keyword>*</keyword>path) {
    HymnString <keyword>*</keyword>working <keyword>=</keyword> hymn_working_directory();
    <keyword>if</keyword> (hymn_string_starts_with(path, working)) {
        hymn_string_delete(working);
        <keyword>return</keyword> hymn_path_normalize(path);
    }
    working <keyword>=</keyword> hymn_string_append_<constant>char</constant>(working, PATH_SEP);
    working <keyword>=</keyword> hymn_string_append(working, path);
    HymnString <keyword>*</keyword>normal <keyword>=</keyword> hymn_path_normalize(working);
    hymn_string_delete(working);
    <keyword>return</keyword> normal;
}

<constant>size_t</constant> hymn_file_size(<keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>path) {
    FILE <keyword>*</keyword>open <keyword>=</keyword> fopen(path, <string>&quot;r&quot;</string>);
    <keyword>if</keyword> (open <keyword>==</keyword> <constant>NULL</constant>) {
        <keyword>return</keyword> <constant>0</constant>;
    }
    <constant>size_t</constant> size <keyword>=</keyword> <constant>0</constant>;
    <constant>int</constant> ch;
    <keyword>while</keyword> ((ch <keyword>=</keyword> fgetc(open)) <keyword>!=</keyword> EOF) {
        size++;
    }
    fclose(open);
    <keyword>return</keyword> size;
}

HymnString <keyword>*</keyword>hymn_read_file(<keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>path) {
    <constant>size_t</constant> size <keyword>=</keyword> hymn_file_size(path);
    FILE <keyword>*</keyword>open <keyword>=</keyword> fopen(path, <string>&quot;r&quot;</string>);
    <keyword>if</keyword> (open <keyword>==</keyword> <constant>NULL</constant>) {
        <keyword>return</keyword> <constant>NULL</constant>;
    }
    HymnString <keyword>*</keyword>string <keyword>=</keyword> hymn_new_string_with_capacity(size);
    HymnStringHead <keyword>*</keyword>head <keyword>=</keyword> hymn_string_head(string);
    <keyword>for</keyword> (<constant>size_t</constant> i <keyword>=</keyword> <constant>0</constant>; i <keyword>&lt;</keyword> size; i++) {
        string[i] <keyword>=</keyword> (<constant>char</constant>)fgetc(open);
    }
    fclose(open);
    head-&gt;length = size;
    <keyword>return</keyword> string;
}

<constant>bool</constant> hymn_file_exists(<keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>path) {
    <keyword>struct</keyword> stat b;
    <keyword>return</keyword> stat(path, <keyword>&</keyword>b) <keyword>==</keyword> <constant>0</constant>;
}

<constant>#ifdef</constant> _MSC_VER
<constant>#define</constant> ANSI_COLOR_RED <string>&quot;&quot;</string>
<constant>#define</constant> ANSI_COLOR_RESET <string>&quot;&quot;</string>
<constant>#else</constant>
<constant>#define</constant> ANSI_COLOR_RED <string>&quot;\x1b[31m&quot;</string>
<constant>#define</constant> ANSI_COLOR_RESET <string>&quot;\x1b[0m&quot;</string>
<constant>#endif</constant>

<keyword>typedef</keyword> <keyword>struct</keyword> JumpList JumpList;
<keyword>typedef</keyword> <keyword>struct</keyword> LoopList LoopList;

<keyword>typedef</keyword> <keyword>struct</keyword> Token Token;
<keyword>typedef</keyword> <keyword>struct</keyword> Local Local;
<keyword>typedef</keyword> <keyword>struct</keyword> Rule Rule;
<keyword>typedef</keyword> <keyword>struct</keyword> Scope Scope;
<keyword>typedef</keyword> <keyword>struct</keyword> Compiler Compiler;
<keyword>typedef</keyword> <keyword>struct</keyword> CompileResult CompileResult;

<keyword>typedef</keyword> <keyword>struct</keyword> Instruction Instruction;
<keyword>typedef</keyword> <keyword>struct</keyword> Optimizer Optimizer;

<keyword>static</keyword> <keyword>const</keyword> <constant>float</constant> LOAD_FACTOR <keyword>=</keyword> <constant>0.80</constant>f;
<keyword>static</keyword> <keyword>const</keyword> <keyword>unsigned</keyword> <constant>int</constant> INITIAL_BINS <keyword>=</keyword> <constant>1</constant> <keyword>&lt;&lt;</keyword> <constant>3</constant>;
<keyword>static</keyword> <keyword>const</keyword> <keyword>unsigned</keyword> <constant>int</constant> MAXIMUM_BINS <keyword>=</keyword> <constant>1</constant> <keyword>&lt;&lt;</keyword> <constant>30</constant>;

<keyword>enum</keyword> TokenType {
    TOKEN_ADD,
    TOKEN_AND,
    TOKEN_ASSIGN,
    TOKEN_ASSIGN_ADD,
    TOKEN_ASSIGN_BIT_AND,
    TOKEN_ASSIGN_BIT_LEFT_SHIFT,
    TOKEN_ASSIGN_BIT_OR,
    TOKEN_ASSIGN_BIT_RIGHT_SHIFT,
    TOKEN_ASSIGN_BIT_XOR,
    TOKEN_ASSIGN_DIVIDE,
    TOKEN_ASSIGN_MODULO,
    TOKEN_ASSIGN_MULTIPLY,
    TOKEN_ASSIGN_SUBTRACT,
    TOKEN_BIT_AND,
    TOKEN_BIT_LEFT_SHIFT,
    TOKEN_BIT_NOT,
    TOKEN_BIT_OR,
    TOKEN_BIT_RIGHT_SHIFT,
    TOKEN_BIT_XOR,
    TOKEN_BREAK,
    TOKEN_CLEAR,
    TOKEN_COLON,
    TOKEN_COMMA,
    TOKEN_CONTINUE,
    TOKEN_COPY,
    TOKEN_DEBUG,
    TOKEN_DELETE,
    TOKEN_DIVIDE,
    TOKEN_DOT,
    TOKEN_ECHO,
    TOKEN_ELIF,
    TOKEN_ELSE,
    TOKEN_EOF,
    TOKEN_EQUAL,
    TOKEN_ERROR,
    TOKEN_EXCEPT,
    TOKEN_EXISTS,
    TOKEN_FALSE,
    TOKEN_FLOAT,
    TOKEN_FOR,
    TOKEN_FUNCTION,
    TOKEN_GREATER,
    TOKEN_GREATER_EQUAL,
    TOKEN_IDENT,
    TOKEN_IF,
    TOKEN_IN,
    TOKEN_INDEX,
    TOKEN_INSERT,
    TOKEN_INSPECT,
    TOKEN_INTEGER,
    TOKEN_KEYS,
    TOKEN_LEFT_CURLY,
    TOKEN_LEFT_PAREN,
    TOKEN_LEFT_SQUARE,
    TOKEN_LEN,
    TOKEN_LESS,
    TOKEN_LESS_EQUAL,
    TOKEN_LET,
    TOKEN_MODULO,
    TOKEN_MULTIPLY,
    TOKEN_NONE,
    TOKEN_NOT,
    TOKEN_NOT_EQUAL,
    TOKEN_OR,
    TOKEN_POINTER,
    TOKEN_POP,
    TOKEN_PRINT,
    TOKEN_PUSH,
    TOKEN_RETURN,
    TOKEN_RIGHT_CURLY,
    TOKEN_RIGHT_PAREN,
    TOKEN_RIGHT_SQUARE,
    TOKEN_STRING,
    TOKEN_SUBTRACT,
    TOKEN_THROW,
    TOKEN_TO_FLOAT,
    TOKEN_TO_INTEGER,
    TOKEN_TO_STRING,
    TOKEN_TRUE,
    TOKEN_TRY,
    TOKEN_TYPE_FUNC,
    TOKEN_UNDEFINED,
    TOKEN_USE,
    TOKEN_VALUE,
    TOKEN_WHILE,
};

<keyword>enum</keyword> Precedence {
    PRECEDENCE_NONE,
    PRECEDENCE_ASSIGN,
    PRECEDENCE_BITS,
    PRECEDENCE_OR,
    PRECEDENCE_AND,
    PRECEDENCE_EQUALITY,
    PRECEDENCE_COMPARE,
    PRECEDENCE_TERM,
    PRECEDENCE_FACTOR,
    PRECEDENCE_UNARY,
    PRECEDENCE_CALL,
};

<keyword>enum</keyword> StringStatus {
    STRING_STATUS_NONE,
    STRING_STATUS_BEGIN,
    STRING_STATUS_ADD,
    STRING_STATUS_CLOSE,
    STRING_STATUS_CONTINUE,
};

<keyword>enum</keyword> OpCode {
    OP_ADD,
    OP_ADD_LOCALS,
    OP_INCREMENT,
    OP_INSERT,
    OP_ARRAY_POP,
    OP_ARRAY_PUSH,
    OP_ARRAY_PUSH_LOCALS,
    OP_BIT_AND,
    OP_BIT_LEFT_SHIFT,
    OP_BIT_NOT,
    OP_BIT_OR,
    OP_BIT_RIGHT_SHIFT,
    OP_BIT_XOR,
    OP_CALL,
    OP_TAIL_CALL,
    OP_SELF,
    OP_CLEAR,
    OP_CONSTANT,
    OP_COPY,
    OP_DEFINE_GLOBAL,
    OP_DEBUG,
    OP_DELETE,
    OP_DIVIDE,
    OP_DUPLICATE,
    OP_ECHO,
    OP_EQUAL,
    OP_EXISTS,
    OP_FALSE,
    OP_GET_DYNAMIC,
    OP_GET_GLOBAL,
    OP_GET_GLOBAL_PROPERTY,
    OP_GET_LOCAL,
    OP_GET_LOCALS,
    OP_GET_PROPERTY,
    OP_GREATER,
    OP_GREATER_EQUAL,
    OP_INDEX,
    OP_INSPECT,
    OP_JUMP,
    OP_JUMP_IF_EQUAL,
    OP_JUMP_IF_NOT_EQUAL,
    OP_JUMP_IF_LESS,
    OP_JUMP_IF_GREATER,
    OP_JUMP_IF_GREATER_LOCALS,
    OP_JUMP_IF_LESS_EQUAL,
    OP_JUMP_IF_GREATER_EQUAL,
    OP_JUMP_IF_FALSE,
    OP_JUMP_IF_TRUE,
    OP_KEYS,
    OP_LEN,
    OP_LESS,
    OP_LESS_EQUAL,
    OP_LOOP,
    OP_MODULO,
    OP_MODULO_LOCALS,
    OP_MULTIPLY,
    OP_NEGATE,
    OP_NEW_ARRAY,
    OP_NEW_TABLE,
    OP_NONE,
    OP_NOT,
    OP_NOT_EQUAL,
    OP_POP,
    OP_POP_TWO,
    OP_POP_N,
    OP_PRINT,
    OP_RETURN,
    OP_SET_DYNAMIC,
    OP_SET_GLOBAL,
    OP_SET_LOCAL,
    OP_SET_PROPERTY,
    OP_INCREMENT_LOCAL,
    OP_INCREMENT_LOCAL_AND_SET,
    OP_INCREMENT_LOOP,
    OP_SLICE,
    OP_SUBTRACT,
    OP_THROW,
    OP_FLOAT,
    OP_INT,
    OP_STRING,
    OP_TRUE,
    OP_TYPE,
    OP_USE,
    OP_FOR,
    OP_FOR_LOOP,
    OP_VOID,
};

<keyword>enum</keyword> FunctionType {
    TYPE_FUNCTION,
    TYPE_SCRIPT,
    TYPE_DO,
    TYPE_REPL,
};

<keyword>static</keyword> <constant>void</constant> compile_with_precedence(Compiler <keyword>*</keyword>C, <keyword>enum</keyword> Precedence precedence);
<keyword>static</keyword> <constant>void</constant> compile_call(Compiler <keyword>*</keyword>C, <constant>bool</constant> assign);
<keyword>static</keyword> <constant>void</constant> compile_group(Compiler <keyword>*</keyword>C, <constant>bool</constant> assign);
<keyword>static</keyword> <constant>void</constant> compile_none(Compiler <keyword>*</keyword>C, <constant>bool</constant> assign);
<keyword>static</keyword> <constant>void</constant> compile_<constant>true</constant>(Compiler <keyword>*</keyword>C, <constant>bool</constant> assign);
<keyword>static</keyword> <constant>void</constant> compile_<constant>false</constant>(Compiler <keyword>*</keyword>C, <constant>bool</constant> assign);
<keyword>static</keyword> <constant>void</constant> compile_integer(Compiler <keyword>*</keyword>C, <constant>bool</constant> assign);
<keyword>static</keyword> <constant>void</constant> compile_<constant>float</constant>(Compiler <keyword>*</keyword>C, <constant>bool</constant> assign);
<keyword>static</keyword> <constant>void</constant> compile_string(Compiler <keyword>*</keyword>C, <constant>bool</constant> assign);
<keyword>static</keyword> <constant>void</constant> compile_array(Compiler <keyword>*</keyword>C, <constant>bool</constant> assign);
<keyword>static</keyword> <constant>void</constant> compile_table(Compiler <keyword>*</keyword>C, <constant>bool</constant> assign);
<keyword>static</keyword> <constant>void</constant> compile_variable(Compiler <keyword>*</keyword>C, <constant>bool</constant> assign);
<keyword>static</keyword> <constant>void</constant> compile_unary(Compiler <keyword>*</keyword>C, <constant>bool</constant> assign);
<keyword>static</keyword> <constant>void</constant> compile_binary(Compiler <keyword>*</keyword>C, <constant>bool</constant> assign);
<keyword>static</keyword> <constant>void</constant> compile_dot(Compiler <keyword>*</keyword>C, <constant>bool</constant> assign);
<keyword>static</keyword> <constant>void</constant> compile_pointer(Compiler <keyword>*</keyword>C, <constant>bool</constant> assign);
<keyword>static</keyword> <constant>void</constant> compile_square(Compiler <keyword>*</keyword>C, <constant>bool</constant> assign);
<keyword>static</keyword> <constant>void</constant> compile_and(Compiler <keyword>*</keyword>C, <constant>bool</constant> assign);
<keyword>static</keyword> <constant>void</constant> compile_or(Compiler <keyword>*</keyword>C, <constant>bool</constant> assign);
<keyword>static</keyword> <constant>void</constant> array_pop_expression(Compiler <keyword>*</keyword>C, <constant>bool</constant> assign);
<keyword>static</keyword> <constant>void</constant> delete_expression(Compiler <keyword>*</keyword>C, <constant>bool</constant> assign);
<keyword>static</keyword> <constant>void</constant> len_expression(Compiler <keyword>*</keyword>C, <constant>bool</constant> assign);
<keyword>static</keyword> <constant>void</constant> cast_integer_expression(Compiler <keyword>*</keyword>C, <constant>bool</constant> assign);
<keyword>static</keyword> <constant>void</constant> cast_<constant>float</constant>_expression(Compiler <keyword>*</keyword>C, <constant>bool</constant> assign);
<keyword>static</keyword> <constant>void</constant> cast_string_expression(Compiler <keyword>*</keyword>C, <constant>bool</constant> assign);
<keyword>static</keyword> <constant>void</constant> clear_expression(Compiler <keyword>*</keyword>C, <constant>bool</constant> assign);
<keyword>static</keyword> <constant>void</constant> copy_expression(Compiler <keyword>*</keyword>C, <constant>bool</constant> assign);
<keyword>static</keyword> <constant>void</constant> index_expression(Compiler <keyword>*</keyword>C, <constant>bool</constant> assign);
<keyword>static</keyword> <constant>void</constant> keys_expression(Compiler <keyword>*</keyword>C, <constant>bool</constant> assign);
<keyword>static</keyword> <constant>void</constant> type_expression(Compiler <keyword>*</keyword>C, <constant>bool</constant> assign);
<keyword>static</keyword> <constant>void</constant> exists_expression(Compiler <keyword>*</keyword>C, <constant>bool</constant> assign);
<keyword>static</keyword> <constant>void</constant> inspect_expression(Compiler <keyword>*</keyword>C, <constant>bool</constant> assign);
<keyword>static</keyword> <constant>void</constant> debug_expression(Compiler <keyword>*</keyword>C, <constant>bool</constant> assign);
<keyword>static</keyword> <constant>void</constant> function_expression(Compiler <keyword>*</keyword>C, <constant>bool</constant> assign);
<keyword>static</keyword> <constant>void</constant> declaration(Compiler <keyword>*</keyword>C);
<keyword>static</keyword> <constant>void</constant> statement(Compiler <keyword>*</keyword>C);
<keyword>static</keyword> <constant>void</constant> expression_statement(Compiler <keyword>*</keyword>C);
<keyword>static</keyword> <constant>void</constant> expression(Compiler <keyword>*</keyword>C);

<keyword>static</keyword> <constant>char</constant> <keyword>*</keyword>interpret(Hymn <keyword>*</keyword>H);

<keyword>struct</keyword> JumpList {
    <constant>int</constant> jump;
    <constant>int</constant> depth;
    HymnByteCode <keyword>*</keyword>code;
    JumpList <keyword>*</keyword>next;
};

<keyword>struct</keyword> LoopList {
    <constant>int</constant> start;
    <constant>int</constant> depth;
    HymnByteCode <keyword>*</keyword>code;
    LoopList <keyword>*</keyword>next;
    <constant>bool</constant> is_<keyword>for</keyword>;
    <constant>char</constant> padding[<constant>7</constant>];
};

<keyword>struct</keyword> Token {
    HymnInt integer;
    HymnFloat floating;
    <constant>int</constant> row;
    <constant>int</constant> column;
    <constant>size_t</constant> start;
    <keyword>unsigned</keyword> <constant>int</constant> length;
    <keyword>enum</keyword> TokenType type;
};

<keyword>struct</keyword> Local {
    Token name;
    <constant>int</constant> depth;
    <constant>char</constant> padding[<constant>4</constant>];
};

<keyword>struct</keyword> Rule {
    <constant>void</constant> (<keyword>*</keyword>prefix)(Compiler <keyword>*</keyword>, <constant>bool</constant>);
    <constant>void</constant> (<keyword>*</keyword>infix)(Compiler <keyword>*</keyword>, <constant>bool</constant>);
    <keyword>enum</keyword> Precedence precedence;
    <constant>char</constant> padding[<constant>4</constant>];
};

<keyword>struct</keyword> Scope {
    <keyword>struct</keyword> Scope <keyword>*</keyword>enclosing;
    HymnFunction <keyword>*</keyword>func;
    <constant>size_t</constant> begin;
    Local locals[HYMN_UINT8_COUNT];
    <constant>int</constant> local_count;
    <constant>int</constant> depth;
    <keyword>enum</keyword> FunctionType type;
    <constant>char</constant> padding[<constant>4</constant>];
};

<keyword>struct</keyword> Compiler {
    Hymn <keyword>*</keyword>H;
    Scope <keyword>*</keyword>scope;
    LoopList <keyword>*</keyword>loop;
    JumpList <keyword>*</keyword>jump;
    JumpList <keyword>*</keyword>jump_or;
    JumpList <keyword>*</keyword>jump_and;
    JumpList <keyword>*</keyword>jump_<keyword>for</keyword>;
    HymnString <keyword>*</keyword>error;
    <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>script;
    <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>source;
    <constant>size_t</constant> pos;
    <constant>size_t</constant> size;
    <constant>int</constant> pop;
    <constant>int</constant> barrier;
    <constant>int</constant> row;
    <constant>int</constant> column;
    Token previous;
    Token current;
    <constant>int</constant> string_format;
    <keyword>enum</keyword> StringStatus string_status;
    <constant>bool</constant> interactive;
    <constant>char</constant> padding[<constant>7</constant>];
};

<keyword>struct</keyword> CompileResult {
    HymnFunction <keyword>*</keyword>func;
    <constant>char</constant> <keyword>*</keyword>error;
};

HymnValue hymn_new_undefined(<constant>void</constant>) {
    <keyword>return</keyword> (HymnValue){.is <keyword>=</keyword> HYMN_VALUE_UNDEFINED, .as <keyword>=</keyword> {.i <keyword>=</keyword> <constant>0</constant>}};
}

HymnValue hymn_new_none(<constant>void</constant>) {
    <keyword>return</keyword> (HymnValue){.is <keyword>=</keyword> HYMN_VALUE_NONE, .as <keyword>=</keyword> {.i <keyword>=</keyword> <constant>0</constant>}};
}

HymnValue hymn_new_<constant>bool</constant>(<constant>bool</constant> v) {
    <keyword>return</keyword> (HymnValue){.is <keyword>=</keyword> HYMN_VALUE_BOOL, .as <keyword>=</keyword> {.b <keyword>=</keyword> v}};
}

HymnValue hymn_new_<constant>int</constant>(HymnInt v) {
    <keyword>return</keyword> (HymnValue){.is <keyword>=</keyword> HYMN_VALUE_INTEGER, .as <keyword>=</keyword> {.i <keyword>=</keyword> v}};
}

HymnValue hymn_new_<constant>float</constant>(HymnFloat v) {
    <keyword>return</keyword> (HymnValue){.is <keyword>=</keyword> HYMN_VALUE_FLOAT, .as <keyword>=</keyword> {.f <keyword>=</keyword> v}};
}

HymnValue hymn_new_native(HymnNativeFunction <keyword>*</keyword>v) {
    <keyword>return</keyword> (HymnValue){.is <keyword>=</keyword> HYMN_VALUE_FUNC_NATIVE, .as <keyword>=</keyword> {.o <keyword>=</keyword> (<constant>void</constant> <keyword>*</keyword>)v}};
}

HymnValue hymn_new_pointer(<constant>void</constant> <keyword>*</keyword>v) {
    <keyword>return</keyword> (HymnValue){.is <keyword>=</keyword> HYMN_VALUE_POINTER, .as <keyword>=</keyword> {.p <keyword>=</keyword> v}};
}

HymnValue hymn_new_string_value(HymnObjectString <keyword>*</keyword>v) {
    <keyword>return</keyword> (HymnValue){.is <keyword>=</keyword> HYMN_VALUE_STRING, .as <keyword>=</keyword> {.o <keyword>=</keyword> (<constant>void</constant> <keyword>*</keyword>)v}};
}

HymnValue hymn_new_array_value(HymnArray <keyword>*</keyword>v) {
    <keyword>return</keyword> (HymnValue){.is <keyword>=</keyword> HYMN_VALUE_ARRAY, .as <keyword>=</keyword> {.o <keyword>=</keyword> (<constant>void</constant> <keyword>*</keyword>)v}};
}

HymnValue hymn_new_table_value(HymnTable <keyword>*</keyword>v) {
    <keyword>return</keyword> (HymnValue){.is <keyword>=</keyword> HYMN_VALUE_TABLE, .as <keyword>=</keyword> {.o <keyword>=</keyword> (<constant>void</constant> <keyword>*</keyword>)v}};
}

HymnValue hymn_new_func_value(HymnFunction <keyword>*</keyword>v) {
    <keyword>return</keyword> (HymnValue){.is <keyword>=</keyword> HYMN_VALUE_FUNC, .as <keyword>=</keyword> {.o <keyword>=</keyword> (<constant>void</constant> <keyword>*</keyword>)v}};
}

<constant>bool</constant> hymn_as_<constant>bool</constant>(HymnValue v) {
    <keyword>return</keyword> (v).as.b;
}

HymnInt hymn_as_<constant>int</constant>(HymnValue v) {
    <keyword>return</keyword> (v).as.i;
}

HymnFloat hymn_as_<constant>float</constant>(HymnValue v) {
    <keyword>return</keyword> (v).as.f;
}

HymnNativeFunction <keyword>*</keyword>hymn_as_native(HymnValue v) {
    <keyword>return</keyword> (HymnNativeFunction <keyword>*</keyword>)(v).as.o;
}

<constant>void</constant> <keyword>*</keyword>hymn_as_pointer(HymnValue v) {
    <keyword>return</keyword> (v).as.p;
}

<constant>void</constant> <keyword>*</keyword>hymn_as_object(HymnValue v) {
    <keyword>return</keyword> (<constant>void</constant> <keyword>*</keyword>)(v).as.o;
}

HymnObjectString <keyword>*</keyword>hymn_as_hymn_string(HymnValue v) {
    <keyword>return</keyword> (HymnObjectString <keyword>*</keyword>)(v).as.o;
}

HymnString <keyword>*</keyword>hymn_as_string(HymnValue v) {
    <keyword>return</keyword> hymn_as_hymn_string(v)<keyword>-&gt;</keyword>string;
}

HymnArray <keyword>*</keyword>hymn_as_array(HymnValue v) {
    <keyword>return</keyword> (HymnArray <keyword>*</keyword>)(v).as.o;
}

HymnTable <keyword>*</keyword>hymn_as_table(HymnValue v) {
    <keyword>return</keyword> (HymnTable <keyword>*</keyword>)(v).as.o;
}

HymnFunction <keyword>*</keyword>hymn_as_func(HymnValue v) {
    <keyword>return</keyword> (HymnFunction <keyword>*</keyword>)(v).as.o;
}

<constant>bool</constant> hymn_is_undefined(HymnValue v) {
    <keyword>return</keyword> (v).is <keyword>==</keyword> HYMN_VALUE_UNDEFINED;
}

<constant>bool</constant> hymn_is_none(HymnValue v) {
    <keyword>return</keyword> (v).is <keyword>==</keyword> HYMN_VALUE_NONE;
}

<constant>bool</constant> hymn_is_<constant>bool</constant>(HymnValue v) {
    <keyword>return</keyword> (v).is <keyword>==</keyword> HYMN_VALUE_BOOL;
}

<constant>bool</constant> hymn_is_<constant>int</constant>(HymnValue v) {
    <keyword>return</keyword> (v).is <keyword>==</keyword> HYMN_VALUE_INTEGER;
}

<constant>bool</constant> hymn_is_<constant>float</constant>(HymnValue v) {
    <keyword>return</keyword> (v).is <keyword>==</keyword> HYMN_VALUE_FLOAT;
}

<constant>bool</constant> hymn_is_native(HymnValue v) {
    <keyword>return</keyword> (v).is <keyword>==</keyword> HYMN_VALUE_FUNC_NATIVE;
}

<constant>bool</constant> hymn_is_pointer(HymnValue v) {
    <keyword>return</keyword> (v).is <keyword>==</keyword> HYMN_VALUE_POINTER;
}

<constant>bool</constant> hymn_is_string(HymnValue v) {
    <keyword>return</keyword> (v).is <keyword>==</keyword> HYMN_VALUE_STRING;
}

<constant>bool</constant> hymn_is_array(HymnValue v) {
    <keyword>return</keyword> (v).is <keyword>==</keyword> HYMN_VALUE_ARRAY;
}

<constant>bool</constant> hymn_is_table(HymnValue v) {
    <keyword>return</keyword> (v).is <keyword>==</keyword> HYMN_VALUE_TABLE;
}

<constant>bool</constant> hymn_is_func(HymnValue v) {
    <keyword>return</keyword> (v).is <keyword>==</keyword> HYMN_VALUE_FUNC;
}

<keyword>static</keyword> Rule rules[] <keyword>=</keyword> {
    [TOKEN_ADD] <keyword>=</keyword> {<constant>NULL</constant>, compile_binary, PRECEDENCE_TERM, {<constant>0</constant>}},
    [TOKEN_AND] <keyword>=</keyword> {<constant>NULL</constant>, compile_and, PRECEDENCE_AND, {<constant>0</constant>}},
    [TOKEN_ASSIGN] <keyword>=</keyword> {<constant>NULL</constant>, <constant>NULL</constant>, PRECEDENCE_NONE, {<constant>0</constant>}},
    [TOKEN_ASSIGN_ADD] <keyword>=</keyword> {<constant>NULL</constant>, <constant>NULL</constant>, PRECEDENCE_NONE, {<constant>0</constant>}},
    [TOKEN_ASSIGN_BIT_AND] <keyword>=</keyword> {<constant>NULL</constant>, <constant>NULL</constant>, PRECEDENCE_NONE, {<constant>0</constant>}},
    [TOKEN_ASSIGN_BIT_LEFT_SHIFT] <keyword>=</keyword> {<constant>NULL</constant>, <constant>NULL</constant>, PRECEDENCE_NONE, {<constant>0</constant>}},
    [TOKEN_ASSIGN_BIT_OR] <keyword>=</keyword> {<constant>NULL</constant>, <constant>NULL</constant>, PRECEDENCE_NONE, {<constant>0</constant>}},
    [TOKEN_ASSIGN_BIT_RIGHT_SHIFT] <keyword>=</keyword> {<constant>NULL</constant>, <constant>NULL</constant>, PRECEDENCE_NONE, {<constant>0</constant>}},
    [TOKEN_ASSIGN_BIT_XOR] <keyword>=</keyword> {<constant>NULL</constant>, <constant>NULL</constant>, PRECEDENCE_NONE, {<constant>0</constant>}},
    [TOKEN_ASSIGN_DIVIDE] <keyword>=</keyword> {<constant>NULL</constant>, <constant>NULL</constant>, PRECEDENCE_NONE, {<constant>0</constant>}},
    [TOKEN_ASSIGN_MODULO] <keyword>=</keyword> {<constant>NULL</constant>, <constant>NULL</constant>, PRECEDENCE_NONE, {<constant>0</constant>}},
    [TOKEN_ASSIGN_MULTIPLY] <keyword>=</keyword> {<constant>NULL</constant>, <constant>NULL</constant>, PRECEDENCE_NONE, {<constant>0</constant>}},
    [TOKEN_ASSIGN_SUBTRACT] <keyword>=</keyword> {<constant>NULL</constant>, <constant>NULL</constant>, PRECEDENCE_NONE, {<constant>0</constant>}},
    [TOKEN_BIT_AND] <keyword>=</keyword> {<constant>NULL</constant>, compile_binary, PRECEDENCE_BITS, {<constant>0</constant>}},
    [TOKEN_BIT_LEFT_SHIFT] <keyword>=</keyword> {<constant>NULL</constant>, compile_binary, PRECEDENCE_BITS, {<constant>0</constant>}},
    [TOKEN_BIT_NOT] <keyword>=</keyword> {compile_unary, <constant>NULL</constant>, PRECEDENCE_NONE, {<constant>0</constant>}},
    [TOKEN_BIT_OR] <keyword>=</keyword> {<constant>NULL</constant>, compile_binary, PRECEDENCE_BITS, {<constant>0</constant>}},
    [TOKEN_BIT_RIGHT_SHIFT] <keyword>=</keyword> {<constant>NULL</constant>, compile_binary, PRECEDENCE_BITS, {<constant>0</constant>}},
    [TOKEN_BIT_XOR] <keyword>=</keyword> {<constant>NULL</constant>, compile_binary, PRECEDENCE_BITS, {<constant>0</constant>}},
    [TOKEN_BREAK] <keyword>=</keyword> {<constant>NULL</constant>, <constant>NULL</constant>, PRECEDENCE_NONE, {<constant>0</constant>}},
    [TOKEN_CLEAR] <keyword>=</keyword> {clear_expression, <constant>NULL</constant>, PRECEDENCE_NONE, {<constant>0</constant>}},
    [TOKEN_COLON] <keyword>=</keyword> {<constant>NULL</constant>, <constant>NULL</constant>, PRECEDENCE_NONE, {<constant>0</constant>}},
    [TOKEN_COMMA] <keyword>=</keyword> {<constant>NULL</constant>, <constant>NULL</constant>, PRECEDENCE_NONE, {<constant>0</constant>}},
    [TOKEN_CONTINUE] <keyword>=</keyword> {<constant>NULL</constant>, <constant>NULL</constant>, PRECEDENCE_NONE, {<constant>0</constant>}},
    [TOKEN_COPY] <keyword>=</keyword> {copy_expression, <constant>NULL</constant>, PRECEDENCE_NONE, {<constant>0</constant>}},
    [TOKEN_DEBUG] <keyword>=</keyword> {debug_expression, <constant>NULL</constant>, PRECEDENCE_NONE, {<constant>0</constant>}},
    [TOKEN_DELETE] <keyword>=</keyword> {delete_expression, <constant>NULL</constant>, PRECEDENCE_NONE, {<constant>0</constant>}},
    [TOKEN_DIVIDE] <keyword>=</keyword> {<constant>NULL</constant>, compile_binary, PRECEDENCE_FACTOR, {<constant>0</constant>}},
    [TOKEN_DOT] <keyword>=</keyword> {<constant>NULL</constant>, compile_dot, PRECEDENCE_CALL, {<constant>0</constant>}},
    [TOKEN_ECHO] <keyword>=</keyword> {<constant>NULL</constant>, <constant>NULL</constant>, PRECEDENCE_NONE, {<constant>0</constant>}},
    [TOKEN_ELIF] <keyword>=</keyword> {<constant>NULL</constant>, <constant>NULL</constant>, PRECEDENCE_NONE, {<constant>0</constant>}},
    [TOKEN_ELSE] <keyword>=</keyword> {<constant>NULL</constant>, <constant>NULL</constant>, PRECEDENCE_NONE, {<constant>0</constant>}},
    [TOKEN_EOF] <keyword>=</keyword> {<constant>NULL</constant>, <constant>NULL</constant>, PRECEDENCE_NONE, {<constant>0</constant>}},
    [TOKEN_EQUAL] <keyword>=</keyword> {<constant>NULL</constant>, compile_binary, PRECEDENCE_EQUALITY, {<constant>0</constant>}},
    [TOKEN_ERROR] <keyword>=</keyword> {<constant>NULL</constant>, <constant>NULL</constant>, PRECEDENCE_NONE, {<constant>0</constant>}},
    [TOKEN_EXCEPT] <keyword>=</keyword> {<constant>NULL</constant>, <constant>NULL</constant>, PRECEDENCE_NONE, {<constant>0</constant>}},
    [TOKEN_EXISTS] <keyword>=</keyword> {exists_expression, <constant>NULL</constant>, PRECEDENCE_NONE, {<constant>0</constant>}},
    [TOKEN_FALSE] <keyword>=</keyword> {compile_<constant>false</constant>, <constant>NULL</constant>, PRECEDENCE_NONE, {<constant>0</constant>}},
    [TOKEN_FLOAT] <keyword>=</keyword> {compile_<constant>float</constant>, <constant>NULL</constant>, PRECEDENCE_NONE, {<constant>0</constant>}},
    [TOKEN_FOR] <keyword>=</keyword> {<constant>NULL</constant>, <constant>NULL</constant>, PRECEDENCE_NONE, {<constant>0</constant>}},
    [TOKEN_FUNCTION] <keyword>=</keyword> {function_expression, <constant>NULL</constant>, PRECEDENCE_NONE, {<constant>0</constant>}},
    [TOKEN_GREATER] <keyword>=</keyword> {<constant>NULL</constant>, compile_binary, PRECEDENCE_COMPARE, {<constant>0</constant>}},
    [TOKEN_GREATER_EQUAL] <keyword>=</keyword> {<constant>NULL</constant>, compile_binary, PRECEDENCE_COMPARE, {<constant>0</constant>}},
    [TOKEN_IDENT] <keyword>=</keyword> {compile_variable, <constant>NULL</constant>, PRECEDENCE_NONE, {<constant>0</constant>}},
    [TOKEN_INSPECT] <keyword>=</keyword> {inspect_expression, <constant>NULL</constant>, PRECEDENCE_NONE, {<constant>0</constant>}},
    [TOKEN_IF] <keyword>=</keyword> {<constant>NULL</constant>, <constant>NULL</constant>, PRECEDENCE_NONE, {<constant>0</constant>}},
    [TOKEN_IN] <keyword>=</keyword> {<constant>NULL</constant>, <constant>NULL</constant>, PRECEDENCE_NONE, {<constant>0</constant>}},
    [TOKEN_INDEX] <keyword>=</keyword> {index_expression, <constant>NULL</constant>, PRECEDENCE_NONE, {<constant>0</constant>}},
    [TOKEN_INSERT] <keyword>=</keyword> {<constant>NULL</constant>, <constant>NULL</constant>, PRECEDENCE_NONE, {<constant>0</constant>}},
    [TOKEN_INTEGER] <keyword>=</keyword> {compile_integer, <constant>NULL</constant>, PRECEDENCE_NONE, {<constant>0</constant>}},
    [TOKEN_KEYS] <keyword>=</keyword> {keys_expression, <constant>NULL</constant>, PRECEDENCE_NONE, {<constant>0</constant>}},
    [TOKEN_LEFT_CURLY] <keyword>=</keyword> {compile_table, <constant>NULL</constant>, PRECEDENCE_NONE, {<constant>0</constant>}},
    [TOKEN_LEFT_PAREN] <keyword>=</keyword> {compile_group, compile_call, PRECEDENCE_CALL, {<constant>0</constant>}},
    [TOKEN_LEFT_SQUARE] <keyword>=</keyword> {compile_array, compile_square, PRECEDENCE_CALL, {<constant>0</constant>}},
    [TOKEN_LEN] <keyword>=</keyword> {len_expression, <constant>NULL</constant>, PRECEDENCE_NONE, {<constant>0</constant>}},
    [TOKEN_LESS] <keyword>=</keyword> {<constant>NULL</constant>, compile_binary, PRECEDENCE_COMPARE, {<constant>0</constant>}},
    [TOKEN_LESS_EQUAL] <keyword>=</keyword> {<constant>NULL</constant>, compile_binary, PRECEDENCE_COMPARE, {<constant>0</constant>}},
    [TOKEN_LET] <keyword>=</keyword> {<constant>NULL</constant>, <constant>NULL</constant>, PRECEDENCE_NONE, {<constant>0</constant>}},
    [TOKEN_MODULO] <keyword>=</keyword> {<constant>NULL</constant>, compile_binary, PRECEDENCE_FACTOR, {<constant>0</constant>}},
    [TOKEN_MULTIPLY] <keyword>=</keyword> {<constant>NULL</constant>, compile_binary, PRECEDENCE_FACTOR, {<constant>0</constant>}},
    [TOKEN_NONE] <keyword>=</keyword> {compile_none, <constant>NULL</constant>, PRECEDENCE_NONE, {<constant>0</constant>}},
    [TOKEN_NOT] <keyword>=</keyword> {compile_unary, <constant>NULL</constant>, PRECEDENCE_NONE, {<constant>0</constant>}},
    [TOKEN_NOT_EQUAL] <keyword>=</keyword> {<constant>NULL</constant>, compile_binary, PRECEDENCE_EQUALITY, {<constant>0</constant>}},
    [TOKEN_OR] <keyword>=</keyword> {<constant>NULL</constant>, compile_or, PRECEDENCE_OR, {<constant>0</constant>}},
    [TOKEN_POINTER] <keyword>=</keyword> {<constant>NULL</constant>, compile_pointer, PRECEDENCE_CALL, {<constant>0</constant>}},
    [TOKEN_POP] <keyword>=</keyword> {array_pop_expression, <constant>NULL</constant>, PRECEDENCE_NONE, {<constant>0</constant>}},
    [TOKEN_PRINT] <keyword>=</keyword> {<constant>NULL</constant>, <constant>NULL</constant>, PRECEDENCE_NONE, {<constant>0</constant>}},
    [TOKEN_PUSH] <keyword>=</keyword> {<constant>NULL</constant>, <constant>NULL</constant>, PRECEDENCE_NONE, {<constant>0</constant>}},
    [TOKEN_RETURN] <keyword>=</keyword> {<constant>NULL</constant>, <constant>NULL</constant>, PRECEDENCE_NONE, {<constant>0</constant>}},
    [TOKEN_RIGHT_CURLY] <keyword>=</keyword> {<constant>NULL</constant>, <constant>NULL</constant>, PRECEDENCE_NONE, {<constant>0</constant>}},
    [TOKEN_RIGHT_PAREN] <keyword>=</keyword> {<constant>NULL</constant>, <constant>NULL</constant>, PRECEDENCE_NONE, {<constant>0</constant>}},
    [TOKEN_RIGHT_SQUARE] <keyword>=</keyword> {<constant>NULL</constant>, <constant>NULL</constant>, PRECEDENCE_NONE, {<constant>0</constant>}},
    [TOKEN_STRING] <keyword>=</keyword> {compile_string, <constant>NULL</constant>, PRECEDENCE_NONE, {<constant>0</constant>}},
    [TOKEN_SUBTRACT] <keyword>=</keyword> {compile_unary, compile_binary, PRECEDENCE_TERM, {<constant>0</constant>}},
    [TOKEN_THROW] <keyword>=</keyword> {<constant>NULL</constant>, <constant>NULL</constant>, PRECEDENCE_NONE, {<constant>0</constant>}},
    [TOKEN_TO_FLOAT] <keyword>=</keyword> {cast_<constant>float</constant>_expression, <constant>NULL</constant>, PRECEDENCE_NONE, {<constant>0</constant>}},
    [TOKEN_TO_INTEGER] <keyword>=</keyword> {cast_integer_expression, <constant>NULL</constant>, PRECEDENCE_NONE, {<constant>0</constant>}},
    [TOKEN_TO_STRING] <keyword>=</keyword> {cast_string_expression, <constant>NULL</constant>, PRECEDENCE_NONE, {<constant>0</constant>}},
    [TOKEN_TRUE] <keyword>=</keyword> {compile_<constant>true</constant>, <constant>NULL</constant>, PRECEDENCE_NONE, {<constant>0</constant>}},
    [TOKEN_TRY] <keyword>=</keyword> {<constant>NULL</constant>, <constant>NULL</constant>, PRECEDENCE_NONE, {<constant>0</constant>}},
    [TOKEN_TYPE_FUNC] <keyword>=</keyword> {type_expression, <constant>NULL</constant>, PRECEDENCE_NONE, {<constant>0</constant>}},
    [TOKEN_UNDEFINED] <keyword>=</keyword> {<constant>NULL</constant>, <constant>NULL</constant>, PRECEDENCE_NONE, {<constant>0</constant>}},
    [TOKEN_USE] <keyword>=</keyword> {<constant>NULL</constant>, <constant>NULL</constant>, PRECEDENCE_NONE, {<constant>0</constant>}},
    [TOKEN_VALUE] <keyword>=</keyword> {<constant>NULL</constant>, <constant>NULL</constant>, PRECEDENCE_NONE, {<constant>0</constant>}},
    [TOKEN_WHILE] <keyword>=</keyword> {<constant>NULL</constant>, <constant>NULL</constant>, PRECEDENCE_NONE, {<constant>0</constant>}},
};

<keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>hymn_value_type(<keyword>enum</keyword> HymnValueType type) {
    <keyword>switch</keyword> (type) {
    <keyword>case</keyword> HYMN_VALUE_UNDEFINED: <keyword>return</keyword> <string>&quot;undefined&quot;</string>;
    <keyword>case</keyword> HYMN_VALUE_NONE: <keyword>return</keyword> <string>&quot;none&quot;</string>;
    <keyword>case</keyword> HYMN_VALUE_BOOL: <keyword>return</keyword> <string>&quot;boolean&quot;</string>;
    <keyword>case</keyword> HYMN_VALUE_INTEGER: <keyword>return</keyword> <string>&quot;integer&quot;</string>;
    <keyword>case</keyword> HYMN_VALUE_FLOAT: <keyword>return</keyword> <string>&quot;float&quot;</string>;
    <keyword>case</keyword> HYMN_VALUE_STRING: <keyword>return</keyword> <string>&quot;string&quot;</string>;
    <keyword>case</keyword> HYMN_VALUE_ARRAY: <keyword>return</keyword> <string>&quot;array&quot;</string>;
    <keyword>case</keyword> HYMN_VALUE_TABLE: <keyword>return</keyword> <string>&quot;table&quot;</string>;
    <keyword>case</keyword> HYMN_VALUE_FUNC: <keyword>return</keyword> <string>&quot;function&quot;</string>;
    <keyword>case</keyword> HYMN_VALUE_FUNC_NATIVE: <keyword>return</keyword> <string>&quot;native&quot;</string>;
    <keyword>case</keyword> HYMN_VALUE_POINTER: <keyword>return</keyword> <string>&quot;pointer&quot;</string>;
    <keyword>default</keyword>: <keyword>return</keyword> <string>&quot;?&quot;</string>;
    }
}

<keyword>static</keyword> <keyword>unsigned</keyword> <constant>int</constant> string_mix_code(HymnString <keyword>*</keyword>key) {
    <constant>size_t</constant> length <keyword>=</keyword> hymn_string_len(key);
    <keyword>unsigned</keyword> <constant>int</constant> hash <keyword>=</keyword> <constant>0</constant>;
    <keyword>for</keyword> (<constant>size_t</constant> i <keyword>=</keyword> <constant>0</constant>; i <keyword>&lt;</keyword> length; i++) {
        hash <keyword>=</keyword> <constant>31</constant><comment> * hash + (unsigned int)key[i];</comment>
    }
    <keyword>return</keyword> hash <keyword>^</keyword> (hash <keyword>&gt;&gt;</keyword> <constant>16</constant>);
}

<keyword>static</keyword> <keyword>unsigned</keyword> <constant>int</constant> string_mix_code_<keyword>const</keyword>(<keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>key) {
    <constant>size_t</constant> length <keyword>=</keyword> strlen(key);
    <keyword>unsigned</keyword> <constant>int</constant> hash <keyword>=</keyword> <constant>0</constant>;
    <keyword>for</keyword> (<constant>size_t</constant> i <keyword>=</keyword> <constant>0</constant>; i <keyword>&lt;</keyword> length; i++) {
        hash <keyword>=</keyword> <constant>31</constant><comment> * hash + (unsigned int)key[i];</comment>
    }
    <keyword>return</keyword> hash <keyword>^</keyword> (hash <keyword>&gt;&gt;</keyword> <constant>16</constant>);
}

<keyword>static</keyword> HymnObjectString <keyword>*</keyword>new_hymn_string_with_hash(HymnString <keyword>*</keyword>string, <keyword>unsigned</keyword> <constant>int</constant> hash) {
    HymnObjectString <keyword>*</keyword>object <keyword>=</keyword> hymn_calloc(<constant>1</constant>, sizeof(HymnObjectString));
    object-&gt;string = string;
    object-&gt;hash = hash;
    <keyword>return</keyword> object;
}

HymnObjectString <keyword>*</keyword>hymn_new_string_object(HymnString <keyword>*</keyword>string) {
    <keyword>return</keyword> new_hymn_string_with_hash(string, string_mix_code(string));
}

<keyword>static</keyword> <constant>void</constant> table_init(HymnTable <keyword>*</keyword>this) {
    this-&gt;size = <constant>0</constant>;
    this-&gt;bins = INITIAL_BINS;
    this-&gt;items = hymn_calloc(this-&gt;bins, sizeof(HymnTableItem *));
}

<keyword>static</keyword> <keyword>unsigned</keyword> <constant>int</constant> table_get_bin(HymnTable <keyword>*</keyword>this, <keyword>unsigned</keyword> <constant>int</constant> hash) {
    <keyword>return</keyword> (this-&gt;bins - <constant>1</constant>U) <keyword>&</keyword> hash;
}

<keyword>static</keyword> <constant>void</constant> table_resize(HymnTable <keyword>*</keyword>this) {
    <keyword>unsigned</keyword> <constant>int</constant> old_bins <keyword>=</keyword> this-&gt;bins;

    <keyword>if</keyword> (old_bins <keyword>&gt;</keyword><keyword>=</keyword> MAXIMUM_BINS) {
        <keyword>return</keyword>;
    }

    <keyword>unsigned</keyword> <constant>int</constant> bins <keyword>=</keyword> old_bins <keyword>&lt;&lt;</keyword> <constant>1</constant>U;

    HymnTableItem <keyword>*</keyword><keyword>*</keyword>old_items <keyword>=</keyword> this-&gt;items;
    HymnTableItem <keyword>*</keyword><keyword>*</keyword>items <keyword>=</keyword> hymn_calloc(bins, sizeof(HymnTableItem <keyword>*</keyword>));

    <keyword>for</keyword> (<keyword>unsigned</keyword> <constant>int</constant> i <keyword>=</keyword> <constant>0</constant>; i <keyword>&lt;</keyword> old_bins; i++) {
        HymnTableItem <keyword>*</keyword>item <keyword>=</keyword> old_items[i];
        <keyword>if</keyword> (item <keyword>==</keyword> <constant>NULL</constant>) {
            <keyword>continue</keyword>;
        }
        <keyword>if</keyword> (item-&gt;next <keyword>==</keyword> <constant>NULL</constant>) {
            items[(bins <keyword>-</keyword> <constant>1</constant>) <keyword>&</keyword> item-&gt;key-&gt;hash] = item;
        } <keyword>else</keyword> {
            HymnTableItem <keyword>*</keyword>low_head <keyword>=</keyword> <constant>NULL</constant>;
            HymnTableItem <keyword>*</keyword>low_tail <keyword>=</keyword> <constant>NULL</constant>;
            HymnTableItem <keyword>*</keyword>high_head <keyword>=</keyword> <constant>NULL</constant>;
            HymnTableItem <keyword>*</keyword>high_tail <keyword>=</keyword> <constant>NULL</constant>;
            do {
                <keyword>if</keyword> ((old_bins <keyword>&</keyword> item-&gt;key-&gt;hash) <keyword>==</keyword> <constant>0</constant>) {
                    <keyword>if</keyword> (low_tail <keyword>==</keyword> <constant>NULL</constant>) {
                        low_head <keyword>=</keyword> item;
                    } <keyword>else</keyword> {
                        low_tail-&gt;next = item;
                    }
                    low_tail <keyword>=</keyword> item;
                } <keyword>else</keyword> {
                    <keyword>if</keyword> (high_tail <keyword>==</keyword> <constant>NULL</constant>) {
                        high_head <keyword>=</keyword> item;
                    } <keyword>else</keyword> {
                        high_tail-&gt;next = item;
                    }
                    high_tail <keyword>=</keyword> item;
                }
                item <keyword>=</keyword> item-&gt;next;
            } <keyword>while</keyword> (item <keyword>!=</keyword> <constant>NULL</constant>);

            <keyword>if</keyword> (low_tail <keyword>!=</keyword> <constant>NULL</constant>) {
                low_tail-&gt;next = <constant>NULL</constant>;
                items[i] <keyword>=</keyword> low_head;
            }

            <keyword>if</keyword> (high_tail <keyword>!=</keyword> <constant>NULL</constant>) {
                high_tail-&gt;next = <constant>NULL</constant>;
                items[i <keyword>+</keyword> old_bins] <keyword>=</keyword> high_head;
            }
        }
    }

    <constant>free</constant>(old_items);

    this-&gt;bins = bins;
    this-&gt;items = items;
}

<keyword>static</keyword> HymnValue table_put(HymnTable <keyword>*</keyword>this, HymnObjectString <keyword>*</keyword>key, HymnValue value) {
    <keyword>unsigned</keyword> <constant>int</constant> bin <keyword>=</keyword> table_get_bin(this, key-&gt;hash);
    HymnTableItem <keyword>*</keyword>item <keyword>=</keyword> this-&gt;items[bin];
    HymnTableItem <keyword>*</keyword>previous <keyword>=</keyword> <constant>NULL</constant>;
    <keyword>while</keyword> (item <keyword>!=</keyword> <constant>NULL</constant>) {
        <keyword>if</keyword> (key <keyword>==</keyword> item-&gt;key) {
            HymnValue old <keyword>=</keyword> item-&gt;value;
            item-&gt;value = value;
            <keyword>return</keyword> old;
        }
        previous <keyword>=</keyword> item;
        item <keyword>=</keyword> item-&gt;next;
    }
    item <keyword>=</keyword> hymn_malloc(sizeof(HymnTableItem));
    item-&gt;key = key;
    item-&gt;value = value;
    item-&gt;next = <constant>NULL</constant>;
    <keyword>if</keyword> (previous <keyword>==</keyword> <constant>NULL</constant>) {
        this-&gt;items[bin] = item;
    } <keyword>else</keyword> {
        previous-&gt;next = item;
    }
    this-&gt;size++;
    <keyword>if</keyword> (this-&gt;size &gt;= (<constant>int</constant>)((<constant>float</constant>)this-&gt;bins * LOAD_FACTOR)) {
        table_resize(this);
    }
    <keyword>return</keyword> hymn_new_undefined();
}

<keyword>static</keyword> HymnValue table_get(HymnTable <keyword>*</keyword>this, HymnObjectString <keyword>*</keyword>key) {
    <keyword>unsigned</keyword> <constant>int</constant> bin <keyword>=</keyword> table_get_bin(this, key-&gt;hash);
    HymnTableItem <keyword>*</keyword>item <keyword>=</keyword> this-&gt;items[bin];
    <keyword>while</keyword> (item <keyword>!=</keyword> <constant>NULL</constant>) {
        <keyword>if</keyword> (key <keyword>==</keyword> item-&gt;key) {
            <keyword>return</keyword> item-&gt;value;
        }
        item <keyword>=</keyword> item-&gt;next;
    }
    <keyword>return</keyword> hymn_new_undefined();
}

HymnValue hymn_table_get(HymnTable <keyword>*</keyword>this, <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>key) {
    <keyword>unsigned</keyword> <constant>int</constant> hash <keyword>=</keyword> string_mix_code_<keyword>const</keyword>(key);
    <keyword>unsigned</keyword> <constant>int</constant> bin <keyword>=</keyword> table_get_bin(this, hash);
    HymnTableItem <keyword>*</keyword>item <keyword>=</keyword> this-&gt;items[bin];
    <keyword>while</keyword> (item <keyword>!=</keyword> <constant>NULL</constant>) {
        <keyword>if</keyword> (hymn_string_equal(key, item-&gt;key-&gt;string)) {
            <keyword>return</keyword> item-&gt;value;
        }
        item <keyword>=</keyword> item-&gt;next;
    }
    <keyword>return</keyword> hymn_new_undefined();
}

<keyword>static</keyword> HymnTableItem <keyword>*</keyword>table_next(HymnTable <keyword>*</keyword>this, HymnObjectString <keyword>*</keyword>key) {
    <keyword>unsigned</keyword> <constant>int</constant> bins <keyword>=</keyword> this-&gt;bins;
    <keyword>if</keyword> (key <keyword>==</keyword> <constant>NULL</constant>) {
        <keyword>for</keyword> (<keyword>unsigned</keyword> <constant>int</constant> i <keyword>=</keyword> <constant>0</constant>; i <keyword>&lt;</keyword> bins; i++) {
            HymnTableItem <keyword>*</keyword>item <keyword>=</keyword> this-&gt;items[i];
            <keyword>if</keyword> (item <keyword>!=</keyword> <constant>NULL</constant>) {
                <keyword>return</keyword> item;
            }
        }
        <keyword>return</keyword> <constant>NULL</constant>;
    }
    <keyword>unsigned</keyword> <constant>int</constant> bin <keyword>=</keyword> table_get_bin(this, key-&gt;hash);
    {
        HymnTableItem <keyword>*</keyword>item <keyword>=</keyword> this-&gt;items[bin];
        <keyword>while</keyword> (item <keyword>!=</keyword> <constant>NULL</constant>) {
            HymnTableItem <keyword>*</keyword>next <keyword>=</keyword> item-&gt;next;
            <keyword>if</keyword> (key <keyword>==</keyword> item-&gt;key) {
                <keyword>if</keyword> (next <keyword>!=</keyword> <constant>NULL</constant>) {
                    <keyword>return</keyword> next;
                }
            }
            item <keyword>=</keyword> next;
        }
    }
    <keyword>for</keyword> (<keyword>unsigned</keyword> <constant>int</constant> i <keyword>=</keyword> bin <keyword>+</keyword> <constant>1</constant>; i <keyword>&lt;</keyword> bins; i++) {
        HymnTableItem <keyword>*</keyword>item <keyword>=</keyword> this-&gt;items[i];
        <keyword>if</keyword> (item <keyword>!=</keyword> <constant>NULL</constant>) {
            <keyword>return</keyword> item;
        }
    }
    <keyword>return</keyword> <constant>NULL</constant>;
}

<keyword>static</keyword> HymnValue table_remove(HymnTable <keyword>*</keyword>this, HymnObjectString <keyword>*</keyword>key) {
    <keyword>unsigned</keyword> <constant>int</constant> bin <keyword>=</keyword> table_get_bin(this, key-&gt;hash);
    HymnTableItem <keyword>*</keyword>item <keyword>=</keyword> this-&gt;items[bin];
    HymnTableItem <keyword>*</keyword>previous <keyword>=</keyword> <constant>NULL</constant>;
    <keyword>while</keyword> (item <keyword>!=</keyword> <constant>NULL</constant>) {
        <keyword>if</keyword> (key <keyword>==</keyword> item-&gt;key) {
            <keyword>if</keyword> (previous <keyword>==</keyword> <constant>NULL</constant>) {
                this-&gt;items[bin] = item-&gt;next;
            } <keyword>else</keyword> {
                previous-&gt;next = item-&gt;next;
            }
            HymnValue value <keyword>=</keyword> item-&gt;value;
            <constant>free</constant>(item);
            this-&gt;size--;
            <keyword>return</keyword> value;
        }
        previous <keyword>=</keyword> item;
        item <keyword>=</keyword> item-&gt;next;
    }
    <keyword>return</keyword> hymn_new_undefined();
}

<keyword>static</keyword> <constant>void</constant> table_clear(Hymn <keyword>*</keyword>H, HymnTable <keyword>*</keyword>this) {
    this-&gt;size = <constant>0</constant>;
    <keyword>unsigned</keyword> <constant>int</constant> bins <keyword>=</keyword> this-&gt;bins;
    <keyword>for</keyword> (<keyword>unsigned</keyword> <constant>int</constant> i <keyword>=</keyword> <constant>0</constant>; i <keyword>&lt;</keyword> bins; i++) {
        HymnTableItem <keyword>*</keyword>item <keyword>=</keyword> this-&gt;items[i];
        <keyword>while</keyword> (item <keyword>!=</keyword> <constant>NULL</constant>) {
            HymnTableItem <keyword>*</keyword>next <keyword>=</keyword> item-&gt;next;
            hymn_dereference(H, item-&gt;value);
            hymn_dereference_string(H, item-&gt;key);
            <constant>free</constant>(item);
            item <keyword>=</keyword> next;
        }
        this-&gt;items[i] = <constant>NULL</constant>;
    }
}

<keyword>static</keyword> <constant>void</constant> table_release(Hymn <keyword>*</keyword>H, HymnTable <keyword>*</keyword>this) {
    table_clear(H, this);
    <constant>free</constant>(this-&gt;items);
}

<keyword>static</keyword> <constant>void</constant> table_delete(Hymn <keyword>*</keyword>H, HymnTable <keyword>*</keyword>this) {
    table_release(H, this);
    <constant>free</constant>(this);
}

<constant>void</constant> hymn_set_property(Hymn <keyword>*</keyword>H, HymnTable <keyword>*</keyword>table, HymnObjectString <keyword>*</keyword>name, HymnValue value) {
    hymn_reference(value);
    HymnValue previous <keyword>=</keyword> table_put(table, name, value);
    <keyword>if</keyword> (hymn_is_undefined(previous)) {
        hymn_reference_string(name);
    } <keyword>else</keyword> {
        hymn_dereference(H, previous);
    }
}

<constant>void</constant> hymn_set_property_<keyword>const</keyword>(Hymn <keyword>*</keyword>H, HymnTable <keyword>*</keyword>table, <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>name, HymnValue value) {
    HymnObjectString <keyword>*</keyword>key <keyword>=</keyword> hymn_new_intern_string(H, name);
    hymn_set_property(H, table, key, value);
}

<keyword>static</keyword> <constant>void</constant> set_init(HymnSet <keyword>*</keyword>this) {
    this-&gt;size = <constant>0</constant>;
    this-&gt;bins = INITIAL_BINS;
    this-&gt;items = hymn_calloc(this-&gt;bins, sizeof(HymnSetItem *));
}

<keyword>static</keyword> <keyword>unsigned</keyword> <constant>int</constant> set_get_bin(HymnSet <keyword>*</keyword>this, <keyword>unsigned</keyword> <constant>int</constant> hash) {
    <keyword>return</keyword> (this-&gt;bins - <constant>1</constant>U) <keyword>&</keyword> hash;
}

<keyword>static</keyword> <constant>void</constant> set_resize(HymnSet <keyword>*</keyword>this) {
    <keyword>unsigned</keyword> <constant>int</constant> old_bins <keyword>=</keyword> this-&gt;bins;

    <keyword>if</keyword> (old_bins <keyword>&gt;</keyword><keyword>=</keyword> MAXIMUM_BINS) {
        <keyword>return</keyword>;
    }

    <keyword>unsigned</keyword> <constant>int</constant> bins <keyword>=</keyword> old_bins <keyword>&lt;&lt;</keyword> <constant>1</constant>U;

    HymnSetItem <keyword>*</keyword><keyword>*</keyword>old_items <keyword>=</keyword> this-&gt;items;
    HymnSetItem <keyword>*</keyword><keyword>*</keyword>items <keyword>=</keyword> hymn_calloc(bins, sizeof(HymnSetItem <keyword>*</keyword>));

    <keyword>for</keyword> (<keyword>unsigned</keyword> <constant>int</constant> i <keyword>=</keyword> <constant>0</constant>; i <keyword>&lt;</keyword> old_bins; i++) {
        HymnSetItem <keyword>*</keyword>item <keyword>=</keyword> old_items[i];
        <keyword>if</keyword> (item <keyword>==</keyword> <constant>NULL</constant>) {
            <keyword>continue</keyword>;
        }
        <keyword>if</keyword> (item-&gt;next <keyword>==</keyword> <constant>NULL</constant>) {
            items[(bins <keyword>-</keyword> <constant>1</constant>) <keyword>&</keyword> item-&gt;string-&gt;hash] = item;
        } <keyword>else</keyword> {
            HymnSetItem <keyword>*</keyword>low_head <keyword>=</keyword> <constant>NULL</constant>;
            HymnSetItem <keyword>*</keyword>low_tail <keyword>=</keyword> <constant>NULL</constant>;
            HymnSetItem <keyword>*</keyword>high_head <keyword>=</keyword> <constant>NULL</constant>;
            HymnSetItem <keyword>*</keyword>high_tail <keyword>=</keyword> <constant>NULL</constant>;
            do {
                <keyword>if</keyword> ((old_bins <keyword>&</keyword> item-&gt;string-&gt;hash) <keyword>==</keyword> <constant>0</constant>) {
                    <keyword>if</keyword> (low_tail <keyword>==</keyword> <constant>NULL</constant>) {
                        low_head <keyword>=</keyword> item;
                    } <keyword>else</keyword> {
                        low_tail-&gt;next = item;
                    }
                    low_tail <keyword>=</keyword> item;
                } <keyword>else</keyword> {
                    <keyword>if</keyword> (high_tail <keyword>==</keyword> <constant>NULL</constant>) {
                        high_head <keyword>=</keyword> item;
                    } <keyword>else</keyword> {
                        high_tail-&gt;next = item;
                    }
                    high_tail <keyword>=</keyword> item;
                }
                item <keyword>=</keyword> item-&gt;next;
            } <keyword>while</keyword> (item <keyword>!=</keyword> <constant>NULL</constant>);

            <keyword>if</keyword> (low_tail <keyword>!=</keyword> <constant>NULL</constant>) {
                low_tail-&gt;next = <constant>NULL</constant>;
                items[i] <keyword>=</keyword> low_head;
            }

            <keyword>if</keyword> (high_tail <keyword>!=</keyword> <constant>NULL</constant>) {
                high_tail-&gt;next = <constant>NULL</constant>;
                items[i <keyword>+</keyword> old_bins] <keyword>=</keyword> high_head;
            }
        }
    }

    <constant>free</constant>(old_items);

    this-&gt;bins = bins;
    this-&gt;items = items;
}

<keyword>static</keyword> HymnObjectString <keyword>*</keyword>set_add_or_get(HymnSet <keyword>*</keyword>this, HymnString <keyword>*</keyword>add) {
    <keyword>unsigned</keyword> <constant>int</constant> hash <keyword>=</keyword> string_mix_code(add);
    <keyword>unsigned</keyword> <constant>int</constant> bin <keyword>=</keyword> set_get_bin(this, hash);
    HymnSetItem <keyword>*</keyword>item <keyword>=</keyword> this-&gt;items[bin];
    HymnSetItem <keyword>*</keyword>previous <keyword>=</keyword> <constant>NULL</constant>;
    <keyword>while</keyword> (item <keyword>!=</keyword> <constant>NULL</constant>) {
        <keyword>if</keyword> (hymn_string_equal(add, item-&gt;string-&gt;string)) {
            <keyword>return</keyword> item-&gt;string;
        }
        previous <keyword>=</keyword> item;
        item <keyword>=</keyword> item-&gt;next;
    }
    HymnObjectString <keyword>*</keyword>new <keyword>=</keyword> new_hymn_string_with_hash(add, hash);
    item <keyword>=</keyword> hymn_malloc(sizeof(HymnSetItem));
    item-&gt;string = new;
    item-&gt;next = <constant>NULL</constant>;
    <keyword>if</keyword> (previous <keyword>==</keyword> <constant>NULL</constant>) {
        this-&gt;items[bin] = item;
    } <keyword>else</keyword> {
        previous-&gt;next = item;
    }
    this-&gt;size++;
    <keyword>if</keyword> (this-&gt;size &gt;= (<constant>int</constant>)((<constant>float</constant>)this-&gt;bins * LOAD_FACTOR)) {
        set_resize(this);
    }
    <keyword>return</keyword> new;
}

<keyword>static</keyword> HymnObjectString <keyword>*</keyword>set_remove(HymnSet <keyword>*</keyword>this, HymnString <keyword>*</keyword>remove) {
    <keyword>unsigned</keyword> <constant>int</constant> hash <keyword>=</keyword> string_mix_code(remove);
    <keyword>unsigned</keyword> <constant>int</constant> bin <keyword>=</keyword> set_get_bin(this, hash);
    HymnSetItem <keyword>*</keyword>item <keyword>=</keyword> this-&gt;items[bin];
    HymnSetItem <keyword>*</keyword>previous <keyword>=</keyword> <constant>NULL</constant>;
    <keyword>while</keyword> (item <keyword>!=</keyword> <constant>NULL</constant>) {
        <keyword>if</keyword> (hymn_string_equal(remove, item-&gt;string-&gt;string)) {
            <keyword>if</keyword> (previous <keyword>==</keyword> <constant>NULL</constant>) {
                this-&gt;items[bin] = item-&gt;next;
            } <keyword>else</keyword> {
                previous-&gt;next = item-&gt;next;
            }
            HymnObjectString <keyword>*</keyword>string <keyword>=</keyword> item-&gt;string;
            <constant>free</constant>(item);
            this-&gt;size--;
            <keyword>return</keyword> string;
        }
        previous <keyword>=</keyword> item;
        item <keyword>=</keyword> item-&gt;next;
    }
    <keyword>return</keyword> <constant>NULL</constant>;
}

<keyword>static</keyword> HymnByteCode <keyword>*</keyword>current(Compiler <keyword>*</keyword>C) {
    <keyword>return</keyword> <keyword>&</keyword>C-&gt;scope-&gt;func-&gt;code;
}

<keyword>static</keyword> <constant>void</constant> compile_error(Compiler <keyword>*</keyword>C, Token <keyword>*</keyword>token, <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>format, ...) {
    <keyword>if</keyword> (C-&gt;error <keyword>!=</keyword> <constant>NULL</constant>) {
        <keyword>return</keyword>;
    }

    <keyword>if</keyword> (C-&gt;interactive && token-&gt;type <keyword>==</keyword> TOKEN_EOF) {
        C-&gt;error = hymn_new_string(<string>&quot;&lt;eof&gt;&quot;</string>);
        <keyword>goto</keyword> clean;
    }

    va_list ap;
    va_start(ap, format);
    <constant>size_t</constant> len <keyword>=</keyword> (<constant>size_t</constant>)vsnprintf(<constant>NULL</constant>, <constant>0</constant>, format, ap);
    va_end(ap);
    <constant>char</constant> <keyword>*</keyword>chars <keyword>=</keyword> hymn_malloc((len <keyword>+</keyword> <constant>1</constant>) <keyword>*</keyword> sizeof(<constant>char</constant>));
    va_start(ap, format);
    len <keyword>=</keyword> (<constant>size_t</constant>)vsnprintf(chars, len <keyword>+</keyword> <constant>1</constant>, format, ap);
    va_end(ap);

    HymnString <keyword>*</keyword>error <keyword>=</keyword> hymn_new_string_with_capacity(len <keyword>+</keyword> <constant>128</constant>);
    error <keyword>=</keyword> hymn_string_append(error, chars);

    <constant>free</constant>(chars);

    <keyword>if</keyword> (token-&gt;type <keyword>!=</keyword> TOKEN_EOF <keyword>&</keyword><keyword>&</keyword> token-&gt;length &gt; <constant>0</constant>) {
        <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>source <keyword>=</keyword> C-&gt;source;
        <keyword>const</keyword> <constant>size_t</constant> size <keyword>=</keyword> C-&gt;size;
        <keyword>const</keyword> <constant>size_t</constant> start <keyword>=</keyword> token-&gt;start;

        <constant>size_t</constant> begin <keyword>=</keyword> start;
        <keyword>while</keyword> (<constant>true</constant>) {
            <keyword>if</keyword> (source[begin] <keyword>==</keyword> <string>'\n'</string>) {
                begin++;
                <keyword>break</keyword>;
            }
            <keyword>if</keyword> (begin <keyword>==</keyword> <constant>0</constant>) <keyword>break</keyword>;
            begin--;
        }

        <keyword>while</keyword> (<constant>true</constant>) {
            <keyword>if</keyword> (source[begin] <keyword>!=</keyword> <string>' '</string> || begin <keyword>==</keyword> size) <keyword>break</keyword>;
            begin++;
        }

        <constant>size_t</constant> end <keyword>=</keyword> start;
        <keyword>while</keyword> (<constant>true</constant>) {
            <keyword>if</keyword> (source[end] <keyword>==</keyword> <string>'\n'</string> || end <keyword>==</keyword> size) <keyword>break</keyword>;
            end++;
        }

        <keyword>if</keyword> (begin <keyword>&lt;</keyword> end) {
            error <keyword>=</keyword> string_append_format(error, <string>&quot;\n  | %.*s\n    &quot;</string>, end <keyword>-</keyword> begin, <keyword>&</keyword>source[begin]);
            <keyword>for</keyword> (<constant>int</constant> i <keyword>=</keyword> <constant>0</constant>; i <keyword>&lt;</keyword> (<constant>int</constant>)(start <keyword>-</keyword> begin); i++) {
                error <keyword>=</keyword> hymn_string_append_<constant>char</constant>(error, <string>' '</string>);
            }
            error <keyword>=</keyword> hymn_string_append(error, ANSI_COLOR_RED);
            <keyword>for</keyword> (<keyword>unsigned</keyword> <constant>int</constant> i <keyword>=</keyword> <constant>0</constant>; i <keyword>&lt;</keyword> token-&gt;length; i++) {
                error <keyword>=</keyword> hymn_string_append_<constant>char</constant>(error, <string>'^'</string>);
            }
            error <keyword>=</keyword> hymn_string_append(error, ANSI_COLOR_RESET);
        }
    }

    error <keyword>=</keyword> string_append_format(error, <string>&quot;\n  at %s:%d&quot;</string>, C-&gt;script <keyword>==</keyword> <constant>NULL</constant> ? <string>&quot;script&quot;</string> : C-&gt;script, token-&gt;row);

    C-&gt;error = error;

clean:
    C-&gt;current.type = TOKEN_EOF;
    C-&gt;previous.type = TOKEN_EOF;
}

<keyword>static</keyword> <constant>char</constant> next_<constant>char</constant>(Compiler <keyword>*</keyword>C) {
    <constant>size_t</constant> pos <keyword>=</keyword> C-&gt;pos;
    <keyword>if</keyword> (pos <keyword>==</keyword> C-&gt;size) {
        <keyword>return</keyword> <string>'\0'</string>;
    }
    <constant>char</constant> c <keyword>=</keyword> C-&gt;source[pos];
    C-&gt;pos = pos + <constant>1</constant>;
    <keyword>if</keyword> (c <keyword>==</keyword> <string>'\n'</string>) {
        C-&gt;row++;
        C-&gt;column = <constant>0</constant>;
    } <keyword>else</keyword> {
        C-&gt;column++;
    }
    <keyword>return</keyword> c;
}

<keyword>static</keyword> <constant>char</constant> peek_<constant>char</constant>(Compiler <keyword>*</keyword>C) {
    <keyword>if</keyword> (C-&gt;pos <keyword>==</keyword> C-&gt;size) {
        <keyword>return</keyword> <string>'\0'</string>;
    }
    <keyword>return</keyword> C-&gt;source[C-&gt;pos];
}

<keyword>static</keyword> <constant>char</constant> peek_two_<constant>char</constant>(Compiler <keyword>*</keyword>C) {
    <keyword>if</keyword> (C-&gt;pos + <constant>1</constant> <keyword>&gt;</keyword><keyword>=</keyword> C-&gt;size) {
        <keyword>return</keyword> <string>'\0'</string>;
    }
    <keyword>return</keyword> C-&gt;source[C-&gt;pos + <constant>1</constant>];
}

<keyword>static</keyword> <constant>void</constant> token(Compiler <keyword>*</keyword>C, <keyword>enum</keyword> TokenType type) {
    Token <keyword>*</keyword>current <keyword>=</keyword> <keyword>&</keyword>C-&gt;current;
    current-&gt;type = type;
    current-&gt;row = C-&gt;row;
    current-&gt;column = C-&gt;column;
    <keyword>if</keyword> (C-&gt;pos <keyword>==</keyword> <constant>0</constant>) {
        current-&gt;start = <constant>0</constant>;
    } <keyword>else</keyword> {
        current-&gt;start = C-&gt;pos - <constant>1</constant>;
    }
    current-&gt;length = <constant>1</constant>;
}

<keyword>static</keyword> <constant>void</constant> token_special(Compiler <keyword>*</keyword>C, <keyword>enum</keyword> TokenType type, <constant>size_t</constant> offset, <constant>size_t</constant> length) {
    Token <keyword>*</keyword>current <keyword>=</keyword> <keyword>&</keyword>C-&gt;current;
    current-&gt;type = type;
    current-&gt;row = C-&gt;row;
    current-&gt;column = C-&gt;column;
    <keyword>if</keyword> (C-&gt;pos &lt; offset) {
        current-&gt;start = <constant>0</constant>;
    } <keyword>else</keyword> {
        current-&gt;start = C-&gt;pos - offset;
    }
    current-&gt;length = (<keyword>unsigned</keyword> <constant>int</constant>)length;
}

<keyword>static</keyword> <constant>void</constant> value_token(Compiler <keyword>*</keyword>C, <keyword>enum</keyword> TokenType type, <constant>size_t</constant> start, <constant>size_t</constant> end) {
    Token <keyword>*</keyword>current <keyword>=</keyword> <keyword>&</keyword>C-&gt;current;
    current-&gt;type = type;
    current-&gt;row = C-&gt;row;
    current-&gt;column = C-&gt;column;
    current-&gt;start = start;
    current-&gt;length = (<keyword>unsigned</keyword> <constant>int</constant>)(end <keyword>-</keyword> start);
}

<keyword>static</keyword> <constant>void</constant> <constant>int</constant>_token(Compiler <keyword>*</keyword>C, <keyword>enum</keyword> TokenType type, <constant>size_t</constant> start, <constant>size_t</constant> end, HymnInt integer) {
    Token <keyword>*</keyword>current <keyword>=</keyword> <keyword>&</keyword>C-&gt;current;
    current-&gt;type = type;
    current-&gt;row = C-&gt;row;
    current-&gt;column = C-&gt;column;
    current-&gt;start = start;
    current-&gt;length = (<keyword>unsigned</keyword> <constant>int</constant>)(end <keyword>-</keyword> start);
    current-&gt;integer = integer;
}

<keyword>static</keyword> <constant>void</constant> <constant>float</constant>_token(Compiler <keyword>*</keyword>C, <keyword>enum</keyword> TokenType type, <constant>size_t</constant> start, <constant>size_t</constant> end, HymnFloat floating) {
    Token <keyword>*</keyword>current <keyword>=</keyword> <keyword>&</keyword>C-&gt;current;
    current-&gt;type = type;
    current-&gt;row = C-&gt;row;
    current-&gt;column = C-&gt;column;
    current-&gt;start = start;
    current-&gt;length = (<keyword>unsigned</keyword> <constant>int</constant>)(end <keyword>-</keyword> start);
    current-&gt;floating = floating;
}

<keyword>static</keyword> <keyword>enum</keyword> TokenType ident_trie(<keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>ident, <constant>int</constant> offset, <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>rest, <keyword>enum</keyword> TokenType type) {
    <constant>int</constant> i <keyword>=</keyword> <constant>0</constant>;
    do {
        <keyword>if</keyword> (ident[offset <keyword>+</keyword> i] <keyword>!=</keyword> rest[i]) {
            <keyword>return</keyword> TOKEN_UNDEFINED;
        }
        i++;
    } <keyword>while</keyword> (rest[i] <keyword>!=</keyword> <string>'\0'</string>);
    <keyword>return</keyword> type;
}

<keyword>static</keyword> <keyword>enum</keyword> TokenType ident_keyword(<keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>ident, <constant>size_t</constant> size) {
    <keyword>switch</keyword> (ident[<constant>0</constant>]) {
    <keyword>case</keyword> <string>'o'</string>:
        <keyword>if</keyword> (size <keyword>==</keyword> <constant>2</constant>) <keyword>return</keyword> ident_trie(ident, <constant>1</constant>, <string>&quot;r&quot;</string>, TOKEN_OR);
        <keyword>break</keyword>;
    <keyword>case</keyword> <string>'u'</string>:
        <keyword>if</keyword> (size <keyword>==</keyword> <constant>3</constant>) <keyword>return</keyword> ident_trie(ident, <constant>1</constant>, <string>&quot;se&quot;</string>, TOKEN_USE);
        <keyword>break</keyword>;
    <keyword>case</keyword> <string>'a'</string>:
        <keyword>if</keyword> (size <keyword>==</keyword> <constant>3</constant>) <keyword>return</keyword> ident_trie(ident, <constant>1</constant>, <string>&quot;nd&quot;</string>, TOKEN_AND);
        <keyword>break</keyword>;
    <keyword>case</keyword> <string>'n'</string>:
        <keyword>if</keyword> (size <keyword>==</keyword> <constant>4</constant>) <keyword>return</keyword> ident_trie(ident, <constant>1</constant>, <string>&quot;one&quot;</string>, TOKEN_NONE);
        <keyword>break</keyword>;
    <keyword>case</keyword> <string>'w'</string>:
        <keyword>if</keyword> (size <keyword>==</keyword> <constant>5</constant>) <keyword>return</keyword> ident_trie(ident, <constant>1</constant>, <string>&quot;hile&quot;</string>, TOKEN_WHILE);
        <keyword>break</keyword>;
    <keyword>case</keyword> <string>'b'</string>:
        <keyword>if</keyword> (size <keyword>==</keyword> <constant>5</constant>) <keyword>return</keyword> ident_trie(ident, <constant>1</constant>, <string>&quot;reak&quot;</string>, TOKEN_BREAK);
        <keyword>break</keyword>;
    <keyword>case</keyword> <string>'d'</string>:
        <keyword>if</keyword> (size <keyword>==</keyword> <constant>5</constant>) <keyword>return</keyword> ident_trie(ident, <constant>1</constant>, <string>&quot;ebug&quot;</string>, TOKEN_DEBUG);
        <keyword>if</keyword> (size <keyword>==</keyword> <constant>6</constant>) <keyword>return</keyword> ident_trie(ident, <constant>1</constant>, <string>&quot;elete&quot;</string>, TOKEN_DELETE);
        <keyword>break</keyword>;
    <keyword>case</keyword> <string>'r'</string>:
        <keyword>if</keyword> (size <keyword>==</keyword> <constant>6</constant>) <keyword>return</keyword> ident_trie(ident, <constant>1</constant>, <string>&quot;eturn&quot;</string>, TOKEN_RETURN);
        <keyword>break</keyword>;
    <keyword>case</keyword> <string>'s'</string>:
        <keyword>if</keyword> (size <keyword>==</keyword> <constant>3</constant>) <keyword>return</keyword> ident_trie(ident, <constant>1</constant>, <string>&quot;tr&quot;</string>, TOKEN_TO_STRING);
        <keyword>break</keyword>;
    <keyword>case</keyword> <string>'k'</string>:
        <keyword>if</keyword> (size <keyword>==</keyword> <constant>4</constant>) <keyword>return</keyword> ident_trie(ident, <constant>1</constant>, <string>&quot;eys&quot;</string>, TOKEN_KEYS);
        <keyword>break</keyword>;
    <keyword>case</keyword> <string>'c'</string>:
        <keyword>if</keyword> (size <keyword>==</keyword> <constant>4</constant>) <keyword>return</keyword> ident_trie(ident, <constant>1</constant>, <string>&quot;opy&quot;</string>, TOKEN_COPY);
        <keyword>if</keyword> (size <keyword>==</keyword> <constant>5</constant>) <keyword>return</keyword> ident_trie(ident, <constant>1</constant>, <string>&quot;lear&quot;</string>, TOKEN_CLEAR);
        <keyword>if</keyword> (size <keyword>==</keyword> <constant>8</constant>) <keyword>return</keyword> ident_trie(ident, <constant>1</constant>, <string>&quot;ontinue&quot;</string>, TOKEN_CONTINUE);
        <keyword>break</keyword>;
    <keyword>case</keyword> <string>'l'</string>:
        <keyword>if</keyword> (size <keyword>==</keyword> <constant>3</constant> <keyword>&</keyword><keyword>&</keyword> ident[<constant>1</constant>] <keyword>==</keyword> <string>'e'</string>) {
            <keyword>if</keyword> (ident[<constant>2</constant>] <keyword>==</keyword> <string>'t'</string>) <keyword>return</keyword> TOKEN_LET;
            <keyword>if</keyword> (ident[<constant>2</constant>] <keyword>==</keyword> <string>'n'</string>) <keyword>return</keyword> TOKEN_LEN;
        }
        <keyword>break</keyword>;
    <keyword>case</keyword> <string>'t'</string>:
        <keyword>if</keyword> (size <keyword>==</keyword> <constant>3</constant>) <keyword>return</keyword> ident_trie(ident, <constant>1</constant>, <string>&quot;ry&quot;</string>, TOKEN_TRY);
        <keyword>if</keyword> (size <keyword>==</keyword> <constant>5</constant>) <keyword>return</keyword> ident_trie(ident, <constant>1</constant>, <string>&quot;hrow&quot;</string>, TOKEN_THROW);
        <keyword>if</keyword> (size <keyword>==</keyword> <constant>4</constant>) {
            <keyword>if</keyword> (ident[<constant>1</constant>] <keyword>==</keyword> <string>'r'</string>) <keyword>return</keyword> ident_trie(ident, <constant>2</constant>, <string>&quot;ue&quot;</string>, TOKEN_TRUE);
            <keyword>if</keyword> (ident[<constant>1</constant>] <keyword>==</keyword> <string>'y'</string>) <keyword>return</keyword> ident_trie(ident, <constant>2</constant>, <string>&quot;pe&quot;</string>, TOKEN_TYPE_FUNC);
        }
        <keyword>break</keyword>;
    <keyword>case</keyword> <string>'i'</string>:
        <keyword>if</keyword> (size <keyword>==</keyword> <constant>3</constant>) <keyword>return</keyword> ident_trie(ident, <constant>1</constant>, <string>&quot;nt&quot;</string>, TOKEN_TO_INTEGER);
        <keyword>if</keyword> (size <keyword>==</keyword> <constant>5</constant>) <keyword>return</keyword> ident_trie(ident, <constant>1</constant>, <string>&quot;ndex&quot;</string>, TOKEN_INDEX);
        <keyword>if</keyword> (size <keyword>==</keyword> <constant>6</constant>) <keyword>return</keyword> ident_trie(ident, <constant>1</constant>, <string>&quot;nsert&quot;</string>, TOKEN_INSERT);
        <keyword>if</keyword> (size <keyword>==</keyword> <constant>7</constant>) <keyword>return</keyword> ident_trie(ident, <constant>1</constant>, <string>&quot;nspect&quot;</string>, TOKEN_INSPECT);
        <keyword>if</keyword> (size <keyword>==</keyword> <constant>2</constant>) {
            <keyword>if</keyword> (ident[<constant>1</constant>] <keyword>==</keyword> <string>'f'</string>) <keyword>return</keyword> TOKEN_IF;
            <keyword>if</keyword> (ident[<constant>1</constant>] <keyword>==</keyword> <string>'n'</string>) <keyword>return</keyword> TOKEN_IN;
        }
        <keyword>break</keyword>;
    <keyword>case</keyword> <string>'p'</string>:
        <keyword>if</keyword> (size <keyword>==</keyword> <constant>3</constant>) <keyword>return</keyword> ident_trie(ident, <constant>1</constant>, <string>&quot;op&quot;</string>, TOKEN_POP);
        <keyword>if</keyword> (size <keyword>==</keyword> <constant>5</constant>) <keyword>return</keyword> ident_trie(ident, <constant>1</constant>, <string>&quot;rint&quot;</string>, TOKEN_PRINT);
        <keyword>if</keyword> (size <keyword>==</keyword> <constant>4</constant>) <keyword>return</keyword> ident_trie(ident, <constant>1</constant>, <string>&quot;ush&quot;</string>, TOKEN_PUSH);
        <keyword>break</keyword>;
    <keyword>case</keyword> <string>'e'</string>:
        <keyword>if</keyword> (size <keyword>==</keyword> <constant>6</constant>) {
            <keyword>if</keyword> (ident[<constant>1</constant>] <keyword>==</keyword> <string>'x'</string>) {
                <keyword>if</keyword> (ident[<constant>2</constant>] <keyword>==</keyword> <string>'c'</string>) <keyword>return</keyword> ident_trie(ident, <constant>3</constant>, <string>&quot;ept&quot;</string>, TOKEN_EXCEPT);
                <keyword>if</keyword> (ident[<constant>2</constant>] <keyword>==</keyword> <string>'i'</string>) <keyword>return</keyword> ident_trie(ident, <constant>3</constant>, <string>&quot;sts&quot;</string>, TOKEN_EXISTS);
            }
        } <keyword>else</keyword> <keyword>if</keyword> (size <keyword>==</keyword> <constant>4</constant>) {
            <keyword>if</keyword> (ident[<constant>1</constant>] <keyword>==</keyword> <string>'l'</string>) {
                <keyword>if</keyword> (ident[<constant>2</constant>] <keyword>==</keyword> <string>'s'</string>) {
                    <keyword>if</keyword> (ident[<constant>3</constant>] <keyword>==</keyword> <string>'e'</string>) {
                        <keyword>return</keyword> TOKEN_ELSE;
                    }
                } <keyword>else</keyword> <keyword>if</keyword> (ident[<constant>2</constant>] <keyword>==</keyword> <string>'i'</string> <keyword>&</keyword><keyword>&</keyword> ident[<constant>3</constant>] <keyword>==</keyword> <string>'f'</string>) {
                    <keyword>return</keyword> TOKEN_ELIF;
                }
            } <keyword>else</keyword> <keyword>if</keyword> (ident[<constant>1</constant>] <keyword>==</keyword> <string>'c'</string>) {
                <keyword>return</keyword> ident_trie(ident, <constant>2</constant>, <string>&quot;ho&quot;</string>, TOKEN_ECHO);
            }
        }
        <keyword>break</keyword>;
    <keyword>case</keyword> <string>'f'</string>:
        <keyword>if</keyword> (size <keyword>==</keyword> <constant>3</constant>) <keyword>return</keyword> ident_trie(ident, <constant>1</constant>, <string>&quot;or&quot;</string>, TOKEN_FOR);
        <keyword>if</keyword> (size <keyword>==</keyword> <constant>4</constant>) <keyword>return</keyword> ident_trie(ident, <constant>1</constant>, <string>&quot;unc&quot;</string>, TOKEN_FUNCTION);
        <keyword>if</keyword> (size <keyword>==</keyword> <constant>5</constant>) {
            <keyword>if</keyword> (ident[<constant>1</constant>] <keyword>==</keyword> <string>'a'</string>) <keyword>return</keyword> ident_trie(ident, <constant>2</constant>, <string>&quot;lse&quot;</string>, TOKEN_FALSE);
            <keyword>if</keyword> (ident[<constant>1</constant>] <keyword>==</keyword> <string>'l'</string>) <keyword>return</keyword> ident_trie(ident, <constant>2</constant>, <string>&quot;oat&quot;</string>, TOKEN_TO_FLOAT);
        }
        <keyword>break</keyword>;
    <keyword>default</keyword>:
        <keyword>break</keyword>;
    }
    <keyword>return</keyword> TOKEN_UNDEFINED;
}

<keyword>static</keyword> <constant>void</constant> push_ident_token(Compiler <keyword>*</keyword>C, <constant>size_t</constant> start, <constant>size_t</constant> end) {
    <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>ident <keyword>=</keyword> <keyword>&</keyword>C-&gt;source[start];
    <constant>size_t</constant> size <keyword>=</keyword> end <keyword>-</keyword> start;
    <keyword>enum</keyword> TokenType keyword <keyword>=</keyword> ident_keyword(ident, size);
    <keyword>if</keyword> (keyword <keyword>!=</keyword> TOKEN_UNDEFINED <keyword>&</keyword><keyword>&</keyword> C-&gt;previous.type <keyword>!=</keyword> TOKEN_DOT) {
        value_token(C, keyword, start, end);
    } <keyword>else</keyword> {
        value_token(C, TOKEN_IDENT, start, end);
    }
}

<keyword>static</keyword> <constant>bool</constant> is_digit(<constant>char</constant> c) {
    <keyword>return</keyword> c <keyword>&gt;</keyword><keyword>=</keyword> <string>'0'</string> <keyword>&</keyword><keyword>&</keyword> c <keyword>&lt;</keyword><keyword>=</keyword> <string>'9'</string>;
}

<keyword>static</keyword> <constant>bool</constant> is_ident(<constant>char</constant> c) {
    <keyword>return</keyword> (c <keyword>&gt;</keyword><keyword>=</keyword> <string>'a'</string> <keyword>&</keyword><keyword>&</keyword> c <keyword>&lt;</keyword><keyword>=</keyword> <string>'z'</string>) || (c <keyword>&gt;</keyword><keyword>=</keyword> <string>'A'</string> <keyword>&</keyword><keyword>&</keyword> c <keyword>&lt;</keyword><keyword>=</keyword> <string>'Z'</string>) || (c <keyword>&gt;</keyword><keyword>=</keyword> <string>'0'</string> <keyword>&</keyword><keyword>&</keyword> c <keyword>&lt;</keyword><keyword>=</keyword> <string>'9'</string>) || c <keyword>==</keyword> <string>'_'</string>;
}

<keyword>static</keyword> <keyword>enum</keyword> StringStatus string_status(Compiler <keyword>*</keyword>C) {
    <constant>size_t</constant> i <keyword>=</keyword> C-&gt;pos;
    <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>source <keyword>=</keyword> C-&gt;source;
    <keyword>const</keyword> <constant>size_t</constant> size <keyword>=</keyword> C-&gt;size;
    <constant>bool</constant> expression <keyword>=</keyword> <constant>false</constant>;
    <constant>int</constant> brackets <keyword>=</keyword> <constant>1</constant>;
    <keyword>while</keyword> (<constant>true</constant>) {
        <keyword>if</keyword> (i <keyword>&gt;</keyword><keyword>=</keyword> size) <keyword>return</keyword> <constant>false</constant>;
        <keyword>switch</keyword> (source[i]) {
        <keyword>case</keyword> <string>'}'</string>:
            <keyword>if</keyword> (brackets <keyword>&gt;</keyword> <constant>1</constant>) {
                expression <keyword>=</keyword> <constant>true</constant>;
                i++;
                brackets--;
                <keyword>continue</keyword>;
            }
            <keyword>return</keyword> expression ? STRING_STATUS_BEGIN : STRING_STATUS_CONTINUE;
        <keyword>case</keyword> <string>'&quot;'</string>:
            <keyword>return</keyword> STRING_STATUS_NONE;
        <keyword>case</keyword> <string>' '</string>:
        <keyword>case</keyword> <string>'\t'</string>:
        <keyword>case</keyword> <string>'\r'</string>:
        <keyword>case</keyword> <string>'\n'</string>:
            i++;
            <keyword>continue</keyword>;
        <keyword>case</keyword> <string>'{'</string>:
            expression <keyword>=</keyword> <constant>true</constant>;
            i++;
            brackets++;
            <keyword>continue</keyword>;
        <keyword>default</keyword>:
            expression <keyword>=</keyword> <constant>true</constant>;
            i++;
            <keyword>continue</keyword>;
        }
    }
}

<keyword>static</keyword> <constant>void</constant> parse_string(Compiler <keyword>*</keyword>C, <constant>size_t</constant> start) {
    <keyword>while</keyword> (<constant>true</constant>) {
        <constant>char</constant> c <keyword>=</keyword> next_<constant>char</constant>(C);
        <keyword>if</keyword> (c <keyword>==</keyword> <string>'\\'</string>) {
            next_<constant>char</constant>(C);
            <keyword>continue</keyword>;
        } <keyword>else</keyword> <keyword>if</keyword> (c <keyword>==</keyword> <string>'$'</string>) {
            <keyword>if</keyword> (peek_<constant>char</constant>(C) <keyword>==</keyword> <string>'{'</string>) {
                next_<constant>char</constant>(C);
                <keyword>enum</keyword> StringStatus status <keyword>=</keyword> string_status(C);
                <keyword>if</keyword> (status <keyword>==</keyword> STRING_STATUS_BEGIN) {
                    C-&gt;string_format = <constant>1</constant>;
                    C-&gt;string_status = STRING_STATUS_BEGIN;
                    <constant>size_t</constant> end <keyword>=</keyword> C-&gt;pos - <constant>2</constant>;
                    value_token(C, TOKEN_STRING, start, end);
                    <keyword>return</keyword>;
                } <keyword>else</keyword> <keyword>if</keyword> (status <keyword>==</keyword> STRING_STATUS_CONTINUE) {
                    C-&gt;string_status = STRING_STATUS_CONTINUE;
                    <constant>size_t</constant> end <keyword>=</keyword> C-&gt;pos - <constant>2</constant>;
                    value_token(C, TOKEN_STRING, start, end);
                    <keyword>while</keyword> (<constant>true</constant>) {
                        c <keyword>=</keyword> next_<constant>char</constant>(C);
                        <keyword>if</keyword> (c <keyword>==</keyword> <string>'}'</string> || c <keyword>==</keyword> <string>'\0'</string>) <keyword>return</keyword>;
                    }
                } <keyword>else</keyword> {
                    <keyword>continue</keyword>;
                }
            }
        } <keyword>else</keyword> <keyword>if</keyword> (c <keyword>==</keyword> <string>'&quot;'</string> || c <keyword>==</keyword> <string>'\0'</string>) {
            <keyword>break</keyword>;
        }
    }
    <constant>size_t</constant> end <keyword>=</keyword> C-&gt;pos - <constant>1</constant>;
    value_token(C, TOKEN_STRING, start, end);
}

<keyword>static</keyword> <constant>void</constant> advance(Compiler <keyword>*</keyword>C) {
    C-&gt;previous = C-&gt;current;
    <keyword>if</keyword> (C-&gt;previous.type <keyword>==</keyword> TOKEN_EOF) {
        <keyword>return</keyword>;
    }
    <keyword>switch</keyword> (C-&gt;string_status) {
    <keyword>case</keyword> STRING_STATUS_BEGIN:
        C-&gt;string_status = STRING_STATUS_ADD;
        token(C, TOKEN_ADD);
        <keyword>return</keyword>;
    <keyword>case</keyword> STRING_STATUS_ADD:
        C-&gt;string_status = STRING_STATUS_NONE;
        token(C, TOKEN_LEFT_PAREN);
        <keyword>return</keyword>;
    <keyword>case</keyword> STRING_STATUS_CLOSE:
        C-&gt;string_status = STRING_STATUS_CONTINUE;
        token(C, TOKEN_ADD);
        <keyword>return</keyword>;
    <keyword>case</keyword> STRING_STATUS_CONTINUE: {
        C-&gt;string_status = STRING_STATUS_NONE;
        <constant>size_t</constant> start <keyword>=</keyword> C-&gt;pos;
        parse_string(C, start);
        <keyword>return</keyword>;
    }
    <keyword>default</keyword>:
        <keyword>break</keyword>;
    }
    <keyword>while</keyword> (<constant>true</constant>) {
        <constant>char</constant> c <keyword>=</keyword> next_<constant>char</constant>(C);
        <keyword>switch</keyword> (c) {
        <keyword>case</keyword> <string>' '</string>:
        <keyword>case</keyword> <string>'\t'</string>:
        <keyword>case</keyword> <string>'\r'</string>:
        <keyword>case</keyword> <string>'\n'</string>:
            c <keyword>=</keyword> peek_<constant>char</constant>(C);
            <keyword>while</keyword> (c <keyword>!=</keyword> <string>'\0'</string> <keyword>&</keyword><keyword>&</keyword> (c <keyword>==</keyword> <string>' '</string> || c <keyword>==</keyword> <string>'\t'</string> || c <keyword>==</keyword> <string>'\r'</string> || c <keyword>==</keyword> <string>'\n'</string>)) {
                next_<constant>char</constant>(C);
                c <keyword>=</keyword> peek_<constant>char</constant>(C);
            }
            <keyword>continue</keyword>;
        <keyword>case</keyword> <string>'#'</string>: {
            next_<constant>char</constant>(C);
            c <keyword>=</keyword> peek_<constant>char</constant>(C);
            <keyword>while</keyword> (c <keyword>!=</keyword> <string>'\n'</string> <keyword>&</keyword><keyword>&</keyword> c <keyword>!=</keyword> <string>'\0'</string>) {
                next_<constant>char</constant>(C);
                c <keyword>=</keyword> peek_<constant>char</constant>(C);
            }
            <keyword>continue</keyword>;
        }
        <keyword>case</keyword> <string>'!'</string>:
            <keyword>if</keyword> (peek_<constant>char</constant>(C) <keyword>==</keyword> <string>'='</string>) {
                next_<constant>char</constant>(C);
                token_special(C, TOKEN_NOT_EQUAL, <constant>2</constant>, <constant>2</constant>);
            } <keyword>else</keyword> {
                token(C, TOKEN_NOT);
            }
            <keyword>return</keyword>;
        <keyword>case</keyword> <string>'='</string>:
            <keyword>if</keyword> (peek_<constant>char</constant>(C) <keyword>==</keyword> <string>'='</string>) {
                next_<constant>char</constant>(C);
                token_special(C, TOKEN_EQUAL, <constant>2</constant>, <constant>2</constant>);
            } <keyword>else</keyword> {
                token(C, TOKEN_ASSIGN);
            }
            <keyword>return</keyword>;
        <keyword>case</keyword> <string>'-'</string>: {
            <keyword>if</keyword> (peek_<constant>char</constant>(C) <keyword>==</keyword> <string>'='</string>) {
                next_<constant>char</constant>(C);
                token_special(C, TOKEN_ASSIGN_SUBTRACT, <constant>2</constant>, <constant>2</constant>);
                <keyword>return</keyword>;
            } <keyword>else</keyword> <keyword>if</keyword> (peek_<constant>char</constant>(C) <keyword>==</keyword> <string>'&gt;'</string>) {
                next_<constant>char</constant>(C);
                token_special(C, TOKEN_POINTER, <constant>2</constant>, <constant>2</constant>);
                <keyword>return</keyword>;
            } <keyword>else</keyword> {
                token(C, TOKEN_SUBTRACT);
                <keyword>return</keyword>;
            }
        }
        <keyword>case</keyword> <string>'+'</string>:
            <keyword>if</keyword> (peek_<constant>char</constant>(C) <keyword>==</keyword> <string>'='</string>) {
                next_<constant>char</constant>(C);
                token_special(C, TOKEN_ASSIGN_ADD, <constant>2</constant>, <constant>2</constant>);
            } <keyword>else</keyword> {
                token(C, TOKEN_ADD);
            }
            <keyword>return</keyword>;
        <keyword>case</keyword> <string>'*'</string>:
            <keyword>if</keyword> (peek_<constant>char</constant>(C) <keyword>==</keyword> <string>'='</string>) {
                next_<constant>char</constant>(C);
                token_special(C, TOKEN_ASSIGN_MULTIPLY, <constant>2</constant>, <constant>2</constant>);
            } <keyword>else</keyword> {
                token(C, TOKEN_MULTIPLY);
            }
            <keyword>return</keyword>;
        <keyword>case</keyword> <string>'/'</string>:
            <keyword>if</keyword> (peek_<constant>char</constant>(C) <keyword>==</keyword> <string>'='</string>) {
                next_<constant>char</constant>(C);
                token_special(C, TOKEN_ASSIGN_DIVIDE, <constant>2</constant>, <constant>2</constant>);
            } <keyword>else</keyword> {
                token(C, TOKEN_DIVIDE);
            }
            <keyword>return</keyword>;
        <keyword>case</keyword> <string>'%'</string>:
            <keyword>if</keyword> (peek_<constant>char</constant>(C) <keyword>==</keyword> <string>'='</string>) {
                next_<constant>char</constant>(C);
                token_special(C, TOKEN_ASSIGN_MODULO, <constant>2</constant>, <constant>2</constant>);
            } <keyword>else</keyword> {
                token(C, TOKEN_MODULO);
            }
            <keyword>return</keyword>;
        <keyword>case</keyword> <string>'&'</string>:
            <keyword>if</keyword> (peek_<constant>char</constant>(C) <keyword>==</keyword> <string>'='</string>) {
                next_<constant>char</constant>(C);
                token_special(C, TOKEN_ASSIGN_BIT_AND, <constant>2</constant>, <constant>2</constant>);
            } <keyword>else</keyword> {
                token(C, TOKEN_BIT_AND);
            }
            <keyword>return</keyword>;
        <keyword>case</keyword> <string>'|'</string>:
            <keyword>if</keyword> (peek_<constant>char</constant>(C) <keyword>==</keyword> <string>'='</string>) {
                next_<constant>char</constant>(C);
                token_special(C, TOKEN_ASSIGN_BIT_OR, <constant>2</constant>, <constant>2</constant>);
            } <keyword>else</keyword> {
                token(C, TOKEN_BIT_OR);
            }
            <keyword>return</keyword>;
        <keyword>case</keyword> <string>'^'</string>:
            <keyword>if</keyword> (peek_<constant>char</constant>(C) <keyword>==</keyword> <string>'='</string>) {
                next_<constant>char</constant>(C);
                token_special(C, TOKEN_ASSIGN_BIT_XOR, <constant>2</constant>, <constant>2</constant>);
            } <keyword>else</keyword> {
                token(C, TOKEN_BIT_XOR);
            }
            <keyword>return</keyword>;
        <keyword>case</keyword> <string>'&gt;'</string>:
            <keyword>if</keyword> (peek_<constant>char</constant>(C) <keyword>==</keyword> <string>'='</string>) {
                next_<constant>char</constant>(C);
                token_special(C, TOKEN_GREATER_EQUAL, <constant>2</constant>, <constant>2</constant>);
            } <keyword>else</keyword> <keyword>if</keyword> (peek_<constant>char</constant>(C) <keyword>==</keyword> <string>'&gt;'</string>) {
                next_<constant>char</constant>(C);
                <keyword>if</keyword> (peek_<constant>char</constant>(C) <keyword>==</keyword> <string>'='</string>) {
                    next_<constant>char</constant>(C);
                    token_special(C, TOKEN_ASSIGN_BIT_RIGHT_SHIFT, <constant>2</constant>, <constant>2</constant>);
                } <keyword>else</keyword> {
                    token_special(C, TOKEN_BIT_RIGHT_SHIFT, <constant>2</constant>, <constant>2</constant>);
                }
            } <keyword>else</keyword> {
                token(C, TOKEN_GREATER);
            }
            <keyword>return</keyword>;
        <keyword>case</keyword> <string>'&lt;'</string>:
            <keyword>if</keyword> (peek_<constant>char</constant>(C) <keyword>==</keyword> <string>'='</string>) {
                next_<constant>char</constant>(C);
                token_special(C, TOKEN_LESS_EQUAL, <constant>2</constant>, <constant>2</constant>);
            } <keyword>else</keyword> <keyword>if</keyword> (peek_<constant>char</constant>(C) <keyword>==</keyword> <string>'&lt;'</string>) {
                next_<constant>char</constant>(C);
                <keyword>if</keyword> (peek_<constant>char</constant>(C) <keyword>==</keyword> <string>'='</string>) {
                    next_<constant>char</constant>(C);
                    token_special(C, TOKEN_ASSIGN_BIT_LEFT_SHIFT, <constant>2</constant>, <constant>2</constant>);
                } <keyword>else</keyword> {
                    token_special(C, TOKEN_BIT_LEFT_SHIFT, <constant>2</constant>, <constant>2</constant>);
                }
            } <keyword>else</keyword> {
                token(C, TOKEN_LESS);
            }
            <keyword>return</keyword>;
        <keyword>case</keyword> <string>'~'</string>: token(C, TOKEN_BIT_NOT); <keyword>return</keyword>;
        <keyword>case</keyword> <string>','</string>: token(C, TOKEN_COMMA); <keyword>return</keyword>;
        <keyword>case</keyword> <string>'.'</string>: token(C, TOKEN_DOT); <keyword>return</keyword>;
        <keyword>case</keyword> <string>'('</string>: token(C, TOKEN_LEFT_PAREN); <keyword>return</keyword>;
        <keyword>case</keyword> <string>')'</string>: token(C, TOKEN_RIGHT_PAREN); <keyword>return</keyword>;
        <keyword>case</keyword> <string>'['</string>: token(C, TOKEN_LEFT_SQUARE); <keyword>return</keyword>;
        <keyword>case</keyword> <string>']'</string>: token(C, TOKEN_RIGHT_SQUARE); <keyword>return</keyword>;
        <keyword>case</keyword> <string>'{'</string>:
            <keyword>if</keyword> (C-&gt;string_format &gt;= <constant>1</constant>) {
                C-&gt;string_format++;
            }
            token(C, TOKEN_LEFT_CURLY);
            <keyword>return</keyword>;
        <keyword>case</keyword> <string>'}'</string>:
            <keyword>if</keyword> (C-&gt;string_format <keyword>==</keyword> <constant>1</constant>) {
                C-&gt;string_format = <constant>0</constant>;
                C-&gt;string_status = STRING_STATUS_CLOSE;
                token(C, TOKEN_RIGHT_PAREN);
                <keyword>return</keyword>;
            } <keyword>else</keyword> <keyword>if</keyword> (C-&gt;string_format &gt; <constant>1</constant>) {
                C-&gt;string_format--;
            }
            token(C, TOKEN_RIGHT_CURLY);
            <keyword>return</keyword>;
        <keyword>case</keyword> <string>':'</string>: token(C, TOKEN_COLON); <keyword>return</keyword>;
        <keyword>case</keyword> <string>'\0'</string>: token(C, TOKEN_EOF); <keyword>return</keyword>;
        <keyword>case</keyword> <string>'&quot;'</string>: {
            <constant>size_t</constant> start <keyword>=</keyword> C-&gt;pos;
            parse_string(C, start);
            <keyword>return</keyword>;
        }
        <keyword>case</keyword> <string>'\'</string>': {
            <constant>size_t</constant> start <keyword>=</keyword> C-&gt;pos;
            <keyword>while</keyword> (<constant>true</constant>) {
                c <keyword>=</keyword> next_<constant>char</constant>(C);
                <keyword>if</keyword> (c <keyword>==</keyword> <string>'\\'</string>) {
                    next_<constant>char</constant>(C);
                    <keyword>continue</keyword>;
                } <keyword>else</keyword> <keyword>if</keyword> (c <keyword>==</keyword> <string>'\'</string><string>' || c == '</string>\<constant>0</constant>') {
                    <keyword>break</keyword>;
                }
            }
            <constant>size_t</constant> end <keyword>=</keyword> C-&gt;pos - <constant>1</constant>;
            value_token(C, TOKEN_STRING, start, end);
            <keyword>return</keyword>;
        }
        <keyword>default</keyword>: {
            <keyword>if</keyword> (is_digit(c)) {
                <constant>size_t</constant> start <keyword>=</keyword> C-&gt;pos - <constant>1</constant>;
                <keyword>if</keyword> (c <keyword>==</keyword> <string>'0'</string>) {
                    <keyword>const</keyword> <constant>char</constant> p <keyword>=</keyword> peek_<constant>char</constant>(C);
                    <keyword>if</keyword> (p <keyword>==</keyword> <string>'b'</string>) {
                        next_<constant>char</constant>(C);
                        <keyword>while</keyword> (<constant>true</constant>) {
                            c <keyword>=</keyword> peek_<constant>char</constant>(C);
                            <keyword>if</keyword> (c <keyword>!=</keyword> <string>'0'</string> <keyword>&</keyword><keyword>&</keyword> c <keyword>!=</keyword> <string>'1'</string>) {
                                <keyword>break</keyword>;
                            }
                            next_<constant>char</constant>(C);
                        }
                        <constant>size_t</constant> end <keyword>=</keyword> C-&gt;pos;
                        long long number <keyword>=</keyword> (long long)strtoll(<keyword>&</keyword>C-&gt;source[start + <constant>2</constant>], <constant>NULL</constant>, <constant>2</constant>);
                        <constant>int</constant>_token(C, TOKEN_INTEGER, start, end, number);
                        <keyword>return</keyword>;
                    } <keyword>else</keyword> <keyword>if</keyword> (p <keyword>==</keyword> <string>'x'</string>) {
                        next_<constant>char</constant>(C);
                        <keyword>while</keyword> (<constant>true</constant>) {
                            c <keyword>=</keyword> peek_<constant>char</constant>(C);
                            <keyword>if</keyword> (<keyword>!</keyword>(c <keyword>&gt;</keyword><keyword>=</keyword> <string>'0'</string> <keyword>&</keyword><keyword>&</keyword> c <keyword>&lt;</keyword><keyword>=</keyword> <string>'9'</string>) <keyword>&</keyword><keyword>&</keyword> <keyword>!</keyword>(c <keyword>&gt;</keyword><keyword>=</keyword> <string>'a'</string> <keyword>&</keyword><keyword>&</keyword> c <keyword>&lt;</keyword><keyword>=</keyword> <string>'f'</string>)) {
                                <keyword>break</keyword>;
                            }
                            next_<constant>char</constant>(C);
                        }
                        <constant>size_t</constant> end <keyword>=</keyword> C-&gt;pos;
                        long long number <keyword>=</keyword> (long long)strtoll(<keyword>&</keyword>C-&gt;source[start + <constant>2</constant>], <constant>NULL</constant>, <constant>16</constant>);
                        <constant>int</constant>_token(C, TOKEN_INTEGER, start, end, number);
                        <keyword>return</keyword>;
                    }
                }
                <keyword>while</keyword> (is_digit(peek_<constant>char</constant>(C))) {
                    next_<constant>char</constant>(C);
                }
                <keyword>const</keyword> <constant>char</constant> p <keyword>=</keyword> peek_<constant>char</constant>(C);
                <keyword>if</keyword> (p <keyword>==</keyword> <string>'.'</string>) {
                    next_<constant>char</constant>(C);
                    <keyword>while</keyword> (is_digit(peek_<constant>char</constant>(C))) {
                        next_<constant>char</constant>(C);
                    }
                    <keyword>const</keyword> <constant>char</constant> n <keyword>=</keyword> peek_<constant>char</constant>(C);
                    <keyword>if</keyword> (n <keyword>==</keyword> <string>'e'</string> || n <keyword>==</keyword> <string>'E'</string>) {
                        next_<constant>char</constant>(C);
                        <keyword>const</keyword> <constant>char</constant> e <keyword>=</keyword> peek_<constant>char</constant>(C);
                        <keyword>if</keyword> (e <keyword>==</keyword> <string>'-'</string> || e <keyword>==</keyword> <string>'+'</string>) next_<constant>char</constant>(C);
                        <keyword>while</keyword> (is_digit(peek_<constant>char</constant>(C))) {
                            next_<constant>char</constant>(C);
                        }
                    }
                    <constant>size_t</constant> end <keyword>=</keyword> C-&gt;pos;
                    <constant>double</constant> number <keyword>=</keyword> atof(<keyword>&</keyword>C-&gt;source[start]);
                    <constant>float</constant>_token(C, TOKEN_FLOAT, start, end, number);
                    <keyword>return</keyword>;
                } <keyword>else</keyword> <keyword>if</keyword> (p <keyword>==</keyword> <string>'e'</string> || p <keyword>==</keyword> <string>'E'</string>) {
                    next_<constant>char</constant>(C);
                    <keyword>const</keyword> <constant>char</constant> n <keyword>=</keyword> peek_<constant>char</constant>(C);
                    <keyword>if</keyword> (n <keyword>==</keyword> <string>'-'</string> || n <keyword>==</keyword> <string>'+'</string>) next_<constant>char</constant>(C);
                    <keyword>while</keyword> (is_digit(peek_<constant>char</constant>(C))) {
                        next_<constant>char</constant>(C);
                    }
                    <constant>size_t</constant> end <keyword>=</keyword> C-&gt;pos;
                    <constant>double</constant> number <keyword>=</keyword> atof(<keyword>&</keyword>C-&gt;source[start]);
                    <keyword>if</keyword> (trunc(number) <keyword>==</keyword> number) {
                        <constant>int</constant>_token(C, TOKEN_INTEGER, start, end, (long long)number);
                    } <keyword>else</keyword> {
                        <constant>float</constant>_token(C, TOKEN_FLOAT, start, end, number);
                    }
                    <keyword>return</keyword>;
                }
                <constant>size_t</constant> end <keyword>=</keyword> C-&gt;pos;
                long long number <keyword>=</keyword> atoll(<keyword>&</keyword>C-&gt;source[start]);
                <constant>int</constant>_token(C, TOKEN_INTEGER, start, end, number);
                <keyword>return</keyword>;
            } <keyword>else</keyword> <keyword>if</keyword> (is_ident(c)) {
                <constant>size_t</constant> start <keyword>=</keyword> C-&gt;pos - <constant>1</constant>;
                <keyword>while</keyword> (<constant>true</constant>) {
                    c <keyword>=</keyword> peek_<constant>char</constant>(C);
                    <keyword>if</keyword> (is_ident(c)) {
                        next_<constant>char</constant>(C);
                        <keyword>continue</keyword>;
                    } <keyword>else</keyword> <keyword>if</keyword> (c <keyword>==</keyword> <string>'-'</string>) {
                        <keyword>if</keyword> (is_ident(peek_two_<constant>char</constant>(C))) {
                            next_<constant>char</constant>(C);
                            next_<constant>char</constant>(C);
                            <keyword>continue</keyword>;
                        }
                    }
                    <keyword>break</keyword>;
                }
                <constant>size_t</constant> end <keyword>=</keyword> C-&gt;pos;
                push_ident_token(C, start, end);
                <keyword>return</keyword>;
            } <keyword>else</keyword> {
                token(C, TOKEN_ERROR);
                compile_error(C, <keyword>&</keyword>C-&gt;current, <string>&quot;unknown character: %c&quot;</string>, c);
            }
        }
        }
    }
}

<constant>bool</constant> hymn_value_<constant>false</constant>(HymnValue value) {
    <keyword>switch</keyword> (value.is) {
    <keyword>case</keyword> HYMN_VALUE_NONE: <keyword>return</keyword> <constant>true</constant>;
    <keyword>case</keyword> HYMN_VALUE_BOOL: <keyword>return</keyword> <keyword>!</keyword>hymn_as_<constant>bool</constant>(value);
    <keyword>case</keyword> HYMN_VALUE_INTEGER: <keyword>return</keyword> hymn_as_<constant>int</constant>(value) <keyword>==</keyword> <constant>0</constant>;
    <keyword>case</keyword> HYMN_VALUE_FLOAT: <keyword>return</keyword> hymn_as_<constant>float</constant>(value) <keyword>==</keyword> <constant>0.0</constant>;
    <keyword>case</keyword> HYMN_VALUE_STRING: <keyword>return</keyword> hymn_string_len(hymn_as_string(value)) <keyword>==</keyword> <constant>0</constant>;
    <keyword>case</keyword> HYMN_VALUE_ARRAY: <keyword>return</keyword> hymn_as_array(value)<keyword>-&gt;</keyword>length <keyword>==</keyword> <constant>0</constant>;
    <keyword>case</keyword> HYMN_VALUE_TABLE: <keyword>return</keyword> hymn_as_table(value)<keyword>-&gt;</keyword>size <keyword>==</keyword> <constant>0</constant>;
    <keyword>case</keyword> HYMN_VALUE_FUNC: <keyword>return</keyword> hymn_as_func(value) <keyword>==</keyword> <constant>NULL</constant>;
    <keyword>case</keyword> HYMN_VALUE_FUNC_NATIVE: <keyword>return</keyword> hymn_as_native(value) <keyword>==</keyword> <constant>NULL</constant>;
    <keyword>default</keyword>: <keyword>return</keyword> <constant>false</constant>;
    }
}

<constant>bool</constant> hymn_values_equal(HymnValue a, HymnValue b) {
    <keyword>switch</keyword> (a.is) {
    <keyword>case</keyword> HYMN_VALUE_NONE: <keyword>return</keyword> hymn_is_none(b);
    <keyword>case</keyword> HYMN_VALUE_BOOL: <keyword>return</keyword> hymn_is_<constant>bool</constant>(b) <keyword>&</keyword><keyword>&</keyword> hymn_as_<constant>bool</constant>(a) <keyword>==</keyword> hymn_as_<constant>bool</constant>(b);
    <keyword>case</keyword> HYMN_VALUE_INTEGER:
        <keyword>switch</keyword> (b.is) {
        <keyword>case</keyword> HYMN_VALUE_INTEGER: <keyword>return</keyword> hymn_as_<constant>int</constant>(a) <keyword>==</keyword> hymn_as_<constant>int</constant>(b);
        <keyword>case</keyword> HYMN_VALUE_FLOAT: <keyword>return</keyword> (HymnFloat)hymn_as_<constant>int</constant>(a) <keyword>==</keyword> hymn_as_<constant>float</constant>(b);
        <keyword>default</keyword>: <keyword>return</keyword> <constant>false</constant>;
        }
    <keyword>case</keyword> HYMN_VALUE_FLOAT:
        <keyword>switch</keyword> (b.is) {
        <keyword>case</keyword> HYMN_VALUE_INTEGER: <keyword>return</keyword> hymn_as_<constant>float</constant>(a) <keyword>==</keyword> (HymnFloat)hymn_as_<constant>int</constant>(b);
        <keyword>case</keyword> HYMN_VALUE_FLOAT: <keyword>return</keyword> hymn_as_<constant>float</constant>(a) <keyword>==</keyword> hymn_as_<constant>float</constant>(b);
        <keyword>default</keyword>: <keyword>return</keyword> <constant>false</constant>;
        }
    <keyword>case</keyword> HYMN_VALUE_STRING:
    <keyword>case</keyword> HYMN_VALUE_ARRAY:
    <keyword>case</keyword> HYMN_VALUE_TABLE:
    <keyword>case</keyword> HYMN_VALUE_FUNC:
    <keyword>case</keyword> HYMN_VALUE_FUNC_NATIVE:
        <keyword>return</keyword> b.is <keyword>==</keyword> a.is <keyword>&</keyword><keyword>&</keyword> hymn_as_object(a) <keyword>==</keyword> hymn_as_object(b);
    <keyword>case</keyword> HYMN_VALUE_POINTER:
        <keyword>return</keyword> hymn_is_pointer(b) <keyword>&</keyword><keyword>&</keyword> hymn_as_pointer(a) <keyword>==</keyword> hymn_as_pointer(b);
    <keyword>default</keyword>: <keyword>return</keyword> <constant>false</constant>;
    }
}

<constant>bool</constant> hymn_match_values(HymnValue a, HymnValue b) {
    <keyword>if</keyword> (a.is <keyword>!=</keyword> b.is) {
        <keyword>return</keyword> <constant>false</constant>;
    }
    <keyword>switch</keyword> (a.is) {
    <keyword>case</keyword> HYMN_VALUE_UNDEFINED:
    <keyword>case</keyword> HYMN_VALUE_NONE: <keyword>return</keyword> <constant>true</constant>;
    <keyword>case</keyword> HYMN_VALUE_BOOL: <keyword>return</keyword> hymn_as_<constant>bool</constant>(a) <keyword>==</keyword> hymn_as_<constant>bool</constant>(b);
    <keyword>case</keyword> HYMN_VALUE_INTEGER: <keyword>return</keyword> hymn_as_<constant>int</constant>(a) <keyword>==</keyword> hymn_as_<constant>int</constant>(b);
    <keyword>case</keyword> HYMN_VALUE_FLOAT: <keyword>return</keyword> hymn_as_<constant>float</constant>(a) <keyword>==</keyword> hymn_as_<constant>float</constant>(b);
    <keyword>case</keyword> HYMN_VALUE_STRING:
    <keyword>case</keyword> HYMN_VALUE_ARRAY:
    <keyword>case</keyword> HYMN_VALUE_TABLE:
    <keyword>case</keyword> HYMN_VALUE_FUNC:
    <keyword>case</keyword> HYMN_VALUE_FUNC_NATIVE:
        <keyword>return</keyword> hymn_as_object(a) <keyword>==</keyword> hymn_as_object(b);
    <keyword>case</keyword> HYMN_VALUE_POINTER: <keyword>return</keyword> hymn_as_pointer(a) <keyword>==</keyword> hymn_as_pointer(b);
    <keyword>default</keyword>:
        <keyword>return</keyword> <constant>false</constant>;
    }
}

<keyword>static</keyword> <constant>void</constant> value_pool_init(HymnValuePool <keyword>*</keyword>this) {
    this-&gt;count = <constant>0</constant>;
    this-&gt;capacity = <constant>8</constant>;
    this-&gt;values = hymn_malloc(<constant>8</constant><comment> * sizeof(HymnValue));</comment>
}

<keyword>static</keyword> <constant>int</constant> value_pool_add(HymnValuePool <keyword>*</keyword>this, HymnValue value) {
    <constant>int</constant> count <keyword>=</keyword> this-&gt;count;
    <keyword>for</keyword> (<constant>int</constant> c <keyword>=</keyword> <constant>0</constant>; c <keyword>&lt;</keyword> count; c++) {
        <keyword>if</keyword> (hymn_match_values(this-&gt;values[c], value)) {
            <keyword>return</keyword> c;
        }
    }
    <keyword>if</keyword> (count <keyword>&gt;</keyword><keyword>=</keyword> this-&gt;capacity) {
        this-&gt;capacity *= <constant>2</constant>;
        this-&gt;values = hymn_realloc_<constant>int</constant>(this-&gt;values, this-&gt;capacity, sizeof(HymnValue));
    }
    this-&gt;values[count] = value;
    this-&gt;count = count + <constant>1</constant>;
    <keyword>return</keyword> count;
}

<keyword>static</keyword> <constant>void</constant> byte_code_init(HymnByteCode <keyword>*</keyword>this) {
    this-&gt;count = <constant>0</constant>;
    this-&gt;capacity = <constant>8</constant>;
    this-&gt;instructions = hymn_malloc(<constant>8</constant><comment> * sizeof(uint8_t));</comment>
    this-&gt;lines = hymn_malloc(<constant>8</constant><comment> * sizeof(int));</comment>
    value_pool_init(<keyword>&</keyword>this-&gt;constants);
}

<keyword>static</keyword> HymnFunction <keyword>*</keyword>new_function(<keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>script) {
    HymnFunction <keyword>*</keyword>func <keyword>=</keyword> hymn_calloc(<constant>1</constant>, sizeof(HymnFunction));
    byte_code_init(<keyword>&</keyword>func-&gt;code);
    <keyword>if</keyword> (script <keyword>!=</keyword> <constant>NULL</constant>) {
        func-&gt;script = hymn_new_string(script);
    }
    <keyword>return</keyword> func;
}

<keyword>static</keyword> HymnNativeFunction <keyword>*</keyword>new_native_function(HymnObjectString <keyword>*</keyword>name, HymnNativeCall func) {
    HymnNativeFunction <keyword>*</keyword>native <keyword>=</keyword> hymn_calloc(<constant>1</constant>, sizeof(HymnNativeFunction));
    native-&gt;name = name;
    native-&gt;func = func;
    hymn_reference_string(name);
    <keyword>return</keyword> native;
}

<keyword>static</keyword> <constant>void</constant> array_init_with_capacity(HymnArray <keyword>*</keyword>this, HymnInt length, HymnInt capacity) {
    <keyword>if</keyword> (capacity <keyword>==</keyword> <constant>0</constant>) {
        this-&gt;items = <constant>NULL</constant>;
    } <keyword>else</keyword> {
        this-&gt;items = hymn_calloc((<constant>size_t</constant>)capacity, sizeof(HymnValue));
    }
    this-&gt;length = length;
    this-&gt;capacity = capacity;
}

<keyword>static</keyword> HymnArray <keyword>*</keyword>new_array_with_capacity(HymnInt length, HymnInt capacity) {
    HymnArray <keyword>*</keyword>this <keyword>=</keyword> hymn_calloc(<constant>1</constant>, sizeof(HymnArray));
    array_init_with_capacity(this, length, capacity);
    <keyword>return</keyword> this;
}

HymnArray <keyword>*</keyword>hymn_new_array(HymnInt length) {
    <keyword>return</keyword> new_array_with_capacity(length, length);
}

<keyword>static</keyword> HymnArray <keyword>*</keyword>new_array_slice(HymnArray <keyword>*</keyword>from, HymnInt start, HymnInt end) {
    HymnInt length <keyword>=</keyword> end <keyword>-</keyword> start;
    <constant>size_t</constant> size <keyword>=</keyword> (<constant>size_t</constant>)length <keyword>*</keyword> sizeof(HymnValue);
    HymnArray <keyword>*</keyword>this <keyword>=</keyword> hymn_calloc(<constant>1</constant>, sizeof(HymnArray));
    this-&gt;items = hymn_malloc(size);
    <constant>memcpy</constant>(this-&gt;items, &from-&gt;items[start], size);
    this-&gt;length = length;
    this-&gt;capacity = length;
    <keyword>for</keyword> (HymnInt i <keyword>=</keyword> <constant>0</constant>; i <keyword>&lt;</keyword> length; i++) {
        hymn_reference(this-&gt;items[i]);
    }
    <keyword>return</keyword> this;
}

<keyword>static</keyword> HymnArray <keyword>*</keyword>new_array_copy(HymnArray <keyword>*</keyword>from) {
    <keyword>return</keyword> new_array_slice(from, <constant>0</constant>, from-&gt;length);
}

<keyword>static</keyword> <constant>void</constant> array_update_capacity(HymnArray <keyword>*</keyword>this, HymnInt length) {
    <keyword>if</keyword> (length <keyword>&gt;</keyword> this-&gt;capacity) {
        <keyword>if</keyword> (this-&gt;capacity <keyword>==</keyword> <constant>0</constant>) {
            this-&gt;capacity = length;
            this-&gt;items = hymn_calloc((<constant>size_t</constant>)length, sizeof(HymnValue));
        } <keyword>else</keyword> {
            this-&gt;capacity = length * <constant>2</constant>;
            this-&gt;items = hymn_realloc(this-&gt;items, (<constant>size_t</constant>)this-&gt;capacity * sizeof(HymnValue));
            memset(this-&gt;items + (<constant>size_t</constant>)this-&gt;length, <constant>0</constant>, (<constant>size_t</constant>)(this-&gt;capacity - this-&gt;length));
        }
    }
}

<constant>void</constant> hymn_array_push(HymnArray <keyword>*</keyword>this, HymnValue value) {
    HymnInt length <keyword>=</keyword> this-&gt;length + <constant>1</constant>;
    array_update_capacity(this, length);
    this-&gt;length = length;
    this-&gt;items[length - <constant>1</constant>] <keyword>=</keyword> value;
}

<constant>void</constant> hymn_array_insert(HymnArray <keyword>*</keyword>this, HymnInt index, HymnValue value) {
    HymnInt length <keyword>=</keyword> this-&gt;length + <constant>1</constant>;
    array_update_capacity(this, length);
    this-&gt;length = length;
    HymnValue <keyword>*</keyword>items <keyword>=</keyword> this-&gt;items;
    <keyword>for</keyword> (HymnInt i <keyword>=</keyword> length <keyword>-</keyword> <constant>1</constant>; i <keyword>&gt;</keyword> index; i--) {
        items[i] <keyword>=</keyword> items[i <keyword>-</keyword> <constant>1</constant>];
    }
    items[index] <keyword>=</keyword> value;
}

HymnValue hymn_array_get(HymnArray <keyword>*</keyword>this, HymnInt index) {
    <keyword>if</keyword> (index <keyword>&gt;</keyword><keyword>=</keyword> this-&gt;length) {
        <keyword>return</keyword> hymn_new_undefined();
    }
    <keyword>return</keyword> this-&gt;items[index];
}

HymnInt hymn_array_index_of(HymnArray <keyword>*</keyword>this, HymnValue match) {
    HymnInt len <keyword>=</keyword> this-&gt;length;
    HymnValue <keyword>*</keyword>items <keyword>=</keyword> this-&gt;items;
    <keyword>for</keyword> (HymnInt i <keyword>=</keyword> <constant>0</constant>; i <keyword>&lt;</keyword> len; i++) {
        <keyword>if</keyword> (hymn_match_values(match, items[i])) {
            <keyword>return</keyword> i;
        }
    }
    <keyword>return</keyword> <keyword>-</keyword><constant>1</constant>;
}

HymnValue hymn_array_pop(HymnArray <keyword>*</keyword>this) {
    <keyword>if</keyword> (this-&gt;length <keyword>==</keyword> <constant>0</constant>) {
        <keyword>return</keyword> hymn_new_none();
    }
    <keyword>return</keyword> this-&gt;items[--this-&gt;length];
}

HymnValue hymn_array_remove_index(HymnArray <keyword>*</keyword>this, HymnInt index) {
    HymnInt len <keyword>=</keyword> <keyword>-</keyword><keyword>-</keyword>this-&gt;length;
    HymnValue <keyword>*</keyword>items <keyword>=</keyword> this-&gt;items;
    HymnValue deleted <keyword>=</keyword> items[index];
    <keyword>while</keyword> (index <keyword>&lt;</keyword> len) {
        items[index] <keyword>=</keyword> items[index <keyword>+</keyword> <constant>1</constant>];
        index++;
    }
    <keyword>return</keyword> deleted;
}

<constant>void</constant> hymn_array_clear(Hymn <keyword>*</keyword>H, HymnArray <keyword>*</keyword>this) {
    HymnInt len <keyword>=</keyword> this-&gt;length;
    HymnValue <keyword>*</keyword>items <keyword>=</keyword> this-&gt;items;
    <keyword>for</keyword> (HymnInt i <keyword>=</keyword> <constant>0</constant>; i <keyword>&lt;</keyword> len; i++) {
        hymn_dereference(H, items[i]);
    }
    this-&gt;length = <constant>0</constant>;
}

<constant>void</constant> hymn_array_delete(Hymn <keyword>*</keyword>H, HymnArray <keyword>*</keyword>this) {
    hymn_array_clear(H, this);
    <constant>free</constant>(this-&gt;items);
    <constant>free</constant>(this);
}

HymnTable <keyword>*</keyword>hymn_new_table(<constant>void</constant>) {
    HymnTable <keyword>*</keyword>this <keyword>=</keyword> hymn_calloc(<constant>1</constant>, sizeof(HymnTable));
    table_init(this);
    <keyword>return</keyword> this;
}

<keyword>static</keyword> HymnTable <keyword>*</keyword>new_table_copy(HymnTable <keyword>*</keyword>from) {
    HymnTable <keyword>*</keyword>this <keyword>=</keyword> hymn_new_table();
    <keyword>unsigned</keyword> <constant>int</constant> bins <keyword>=</keyword> from-&gt;bins;
    <keyword>for</keyword> (<keyword>unsigned</keyword> <constant>int</constant> i <keyword>=</keyword> <constant>0</constant>; i <keyword>&lt;</keyword> bins; i++) {
        HymnTableItem <keyword>*</keyword>item <keyword>=</keyword> from-&gt;items[i];
        <keyword>while</keyword> (item <keyword>!=</keyword> <constant>NULL</constant>) {
            table_put(this, item-&gt;key, item-&gt;value);
            hymn_reference_string(item-&gt;key);
            hymn_reference(item-&gt;value);
            item <keyword>=</keyword> item-&gt;next;
        }
    }
    <keyword>return</keyword> this;
}

<keyword>static</keyword> HymnArray <keyword>*</keyword>table_keys(HymnTable <keyword>*</keyword>this) {
    <constant>int</constant> size <keyword>=</keyword> this-&gt;size;
    HymnArray <keyword>*</keyword>array <keyword>=</keyword> hymn_new_array((HymnInt)size);
    <keyword>if</keyword> (size <keyword>==</keyword> <constant>0</constant>) {
        <keyword>return</keyword> array;
    }
    HymnValue <keyword>*</keyword>keys <keyword>=</keyword> array-&gt;items;
    <keyword>unsigned</keyword> <constant>int</constant> total <keyword>=</keyword> <constant>0</constant>;
    <keyword>unsigned</keyword> <constant>int</constant> bins <keyword>=</keyword> this-&gt;bins;
    <keyword>for</keyword> (<keyword>unsigned</keyword> <constant>int</constant> i <keyword>=</keyword> <constant>0</constant>; i <keyword>&lt;</keyword> bins; i++) {
        HymnTableItem <keyword>*</keyword>item <keyword>=</keyword> this-&gt;items[i];
        <keyword>while</keyword> (item <keyword>!=</keyword> <constant>NULL</constant>) {
            HymnString <keyword>*</keyword>string <keyword>=</keyword> item-&gt;key-&gt;string;
            <keyword>unsigned</keyword> <constant>int</constant> insert <keyword>=</keyword> <constant>0</constant>;
            <keyword>while</keyword> (insert <keyword>!=</keyword> total) {
                <keyword>if</keyword> (strcmp(string, hymn_as_string(keys[insert])) <keyword>&lt;</keyword> <constant>0</constant>) {
                    <keyword>for</keyword> (<keyword>unsigned</keyword> <constant>int</constant> swap <keyword>=</keyword> total; swap <keyword>&gt;</keyword> insert; swap--) {
                        keys[swap] <keyword>=</keyword> keys[swap <keyword>-</keyword> <constant>1</constant>];
                    }
                    <keyword>break</keyword>;
                }
                insert++;
            }
            HymnValue value <keyword>=</keyword> hymn_new_string_value(item-&gt;key);
            hymn_reference(value);
            keys[insert] <keyword>=</keyword> value;
            total++;
            item <keyword>=</keyword> item-&gt;next;
        }
    }
    <keyword>return</keyword> array;
}

<keyword>static</keyword> HymnObjectString <keyword>*</keyword>table_key_of(HymnTable <keyword>*</keyword>this, HymnValue match) {
    <keyword>unsigned</keyword> <constant>int</constant> bin <keyword>=</keyword> <constant>0</constant>;
    HymnTableItem <keyword>*</keyword>item <keyword>=</keyword> <constant>NULL</constant>;

    <keyword>unsigned</keyword> <constant>int</constant> bins <keyword>=</keyword> this-&gt;bins;
    <keyword>for</keyword> (<keyword>unsigned</keyword> <constant>int</constant> i <keyword>=</keyword> <constant>0</constant>; i <keyword>&lt;</keyword> bins; i++) {
        HymnTableItem <keyword>*</keyword>start <keyword>=</keyword> this-&gt;items[i];
        <keyword>if</keyword> (start) {
            bin <keyword>=</keyword> i;
            item <keyword>=</keyword> start;
            <keyword>break</keyword>;
        }
    }

    <keyword>if</keyword> (item <keyword>==</keyword> <constant>NULL</constant>) <keyword>return</keyword> <constant>NULL</constant>;
    <keyword>if</keyword> (hymn_match_values(match, item-&gt;value)) <keyword>return</keyword> item-&gt;key;

    <keyword>while</keyword> (<constant>true</constant>) {
        item <keyword>=</keyword> item-&gt;next;
        <keyword>if</keyword> (item <keyword>==</keyword> <constant>NULL</constant>) {
            <keyword>for</keyword> (bin <keyword>=</keyword> bin <keyword>+</keyword> <constant>1</constant>; bin <keyword>&lt;</keyword> bins; bin++) {
                HymnTableItem <keyword>*</keyword>start <keyword>=</keyword> this-&gt;items[bin];
                <keyword>if</keyword> (start) {
                    item <keyword>=</keyword> start;
                    <keyword>break</keyword>;
                }
            }
            <keyword>if</keyword> (item <keyword>==</keyword> <constant>NULL</constant>) <keyword>return</keyword> <constant>NULL</constant>;
        }
        <keyword>if</keyword> (hymn_match_values(match, item-&gt;value)) <keyword>return</keyword> item-&gt;key;
    }
}

<keyword>static</keyword> <constant>void</constant> scope_init(Compiler <keyword>*</keyword>C, Scope <keyword>*</keyword>scope, <keyword>enum</keyword> FunctionType type, <constant>size_t</constant> begin) {
    scope-&gt;enclosing = C-&gt;scope;
    C-&gt;scope = scope;

    scope-&gt;local_count = <constant>0</constant>;
    scope-&gt;depth = <constant>0</constant>;
    scope-&gt;func = new_function(C-&gt;script);
    scope-&gt;type = type;
    scope-&gt;begin = begin;

    <keyword>if</keyword> (type <keyword>==</keyword> TYPE_FUNCTION) {
        scope-&gt;func-&gt;name = hymn_substring(C-&gt;source, C-&gt;previous.start, C-&gt;previous.start + C-&gt;previous.length);
    }

    Local <keyword>*</keyword>local <keyword>=</keyword> <keyword>&</keyword>scope-&gt;locals[scope-&gt;local_count++];
    local-&gt;depth = <constant>0</constant>;
    local-&gt;name.start = <constant>0</constant>;
    local-&gt;name.length = <constant>0</constant>;
}

<keyword>static</keyword> <constant>void</constant> byte_code_delete(HymnByteCode <keyword>*</keyword>this) {
    <constant>free</constant>(this-&gt;instructions);
    <constant>free</constant>(this-&gt;lines);
    <constant>free</constant>(this-&gt;constants.values);
}

<keyword>static</keyword> <constant>uint8_t</constant> byte_code_new_constant(Compiler <keyword>*</keyword>C, HymnValue value) {
    HymnByteCode <keyword>*</keyword>code <keyword>=</keyword> current(C);
    <constant>int</constant> constant <keyword>=</keyword> value_pool_add(<keyword>&</keyword>code-&gt;constants, value);
    <keyword>if</keyword> (constant <keyword>&gt;</keyword> UINT8_MAX) {
        compile_error(C, <keyword>&</keyword>C-&gt;previous, <string>&quot;too many constants&quot;</string>);
        constant <keyword>=</keyword> <constant>0</constant>;
    }
    <keyword>return</keyword> (<constant>uint8_t</constant>)constant;
}

<keyword>static</keyword> <constant>void</constant> write_byte(HymnByteCode <keyword>*</keyword>code, <constant>uint8_t</constant> b, <constant>int</constant> row) {
    <constant>int</constant> count <keyword>=</keyword> code-&gt;count;
    <keyword>if</keyword> (count <keyword>&gt;</keyword><keyword>=</keyword> code-&gt;capacity) {
        code-&gt;capacity *= <constant>2</constant>;
        code-&gt;instructions = hymn_realloc_<constant>int</constant>(code-&gt;instructions, code-&gt;capacity, sizeof(<constant>uint8_t</constant>));
        code-&gt;lines = hymn_realloc_<constant>int</constant>(code-&gt;lines, code-&gt;capacity, sizeof(<constant>int</constant>));
    }
    code-&gt;instructions[count] = b;
    code-&gt;lines[count] = row;
    code-&gt;count = count + <constant>1</constant>;
}

<keyword>static</keyword> <constant>void</constant> emit(Compiler <keyword>*</keyword>C, <constant>uint8_t</constant> i) {
    write_byte(current(C), i, C-&gt;previous.row);
}

<keyword>static</keyword> <constant>void</constant> emit_pop(Compiler <keyword>*</keyword>C) {
    HymnByteCode <keyword>*</keyword>code <keyword>=</keyword> current(C);
    write_byte(code, OP_POP, C-&gt;previous.row);
    C-&gt;pop = code-&gt;count;
}

<keyword>static</keyword> <constant>void</constant> emit_short(Compiler <keyword>*</keyword>C, <constant>uint8_t</constant> i, <constant>uint8_t</constant> b) {
    <constant>int</constant> row <keyword>=</keyword> C-&gt;previous.row;
    HymnByteCode <keyword>*</keyword>code <keyword>=</keyword> current(C);
    write_byte(code, i, row);
    write_byte(code, b, row);
}

<keyword>static</keyword> <constant>void</constant> emit_word(Compiler <keyword>*</keyword>C, <constant>uint8_t</constant> i, <constant>uint8_t</constant> b, <constant>uint8_t</constant> n) {
    <constant>int</constant> row <keyword>=</keyword> C-&gt;previous.row;
    HymnByteCode <keyword>*</keyword>code <keyword>=</keyword> current(C);
    write_byte(code, i, row);
    write_byte(code, b, row);
    write_byte(code, n, row);
}

<keyword>static</keyword> <constant>uint8_t</constant> emit_constant(Compiler <keyword>*</keyword>C, HymnValue value) {
    <constant>uint8_t</constant> constant <keyword>=</keyword> byte_code_new_constant(C, value);
    emit_short(C, OP_CONSTANT, constant);
    <keyword>return</keyword> constant;
}

<keyword>static</keyword> Rule <keyword>*</keyword>token_rule(<keyword>enum</keyword> TokenType type) {
    <keyword>return</keyword> <keyword>&</keyword>rules[type];
}

HymnObjectString <keyword>*</keyword>hymn_intern_string(Hymn <keyword>*</keyword>H, HymnString <keyword>*</keyword>string) {
    HymnObjectString <keyword>*</keyword>object <keyword>=</keyword> set_add_or_get(<keyword>&</keyword>H-&gt;strings, string);
    <keyword>if</keyword> (object-&gt;string <keyword>!=</keyword> string) {
        hymn_string_delete(string);
    }
    <keyword>return</keyword> object;
}

HymnObjectString <keyword>*</keyword>hymn_new_intern_string(Hymn <keyword>*</keyword>H, <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>value) {
    <keyword>return</keyword> hymn_intern_string(H, hymn_new_string(value));
}

<keyword>static</keyword> HymnValue compile_intern_string(Hymn <keyword>*</keyword>H, HymnString <keyword>*</keyword>string) {
    HymnObjectString <keyword>*</keyword>object <keyword>=</keyword> set_add_or_get(<keyword>&</keyword>H-&gt;strings, string);
    <keyword>if</keyword> (object-&gt;string <keyword>==</keyword> string) {
        hymn_reference_string(object);
    } <keyword>else</keyword> {
        hymn_string_delete(string);
    }
    <keyword>return</keyword> hymn_new_string_value(object);
}

<keyword>static</keyword> <constant>bool</constant> check_assign(Compiler <keyword>*</keyword>C) {
    <keyword>switch</keyword> (C-&gt;current.type) {
    <keyword>case</keyword> TOKEN_ASSIGN:
    <keyword>case</keyword> TOKEN_ASSIGN_ADD:
    <keyword>case</keyword> TOKEN_ASSIGN_BIT_AND:
    <keyword>case</keyword> TOKEN_ASSIGN_BIT_LEFT_SHIFT:
    <keyword>case</keyword> TOKEN_ASSIGN_BIT_OR:
    <keyword>case</keyword> TOKEN_ASSIGN_BIT_RIGHT_SHIFT:
    <keyword>case</keyword> TOKEN_ASSIGN_BIT_XOR:
    <keyword>case</keyword> TOKEN_ASSIGN_DIVIDE:
    <keyword>case</keyword> TOKEN_ASSIGN_MODULO:
    <keyword>case</keyword> TOKEN_ASSIGN_MULTIPLY:
    <keyword>case</keyword> TOKEN_ASSIGN_SUBTRACT:
        <keyword>return</keyword> <constant>true</constant>;
    <keyword>default</keyword>:
        <keyword>return</keyword> <constant>false</constant>;
    }
}

<keyword>static</keyword> <constant>bool</constant> check(Compiler <keyword>*</keyword>C, <keyword>enum</keyword> TokenType type) {
    <keyword>return</keyword> C-&gt;current.type <keyword>==</keyword> type;
}

<keyword>static</keyword> <constant>bool</constant> match(Compiler <keyword>*</keyword>C, <keyword>enum</keyword> TokenType type) {
    <keyword>if</keyword> (C-&gt;current.type <keyword>!=</keyword> type) {
        <keyword>return</keyword> <constant>false</constant>;
    }
    advance(C);
    <keyword>return</keyword> <constant>true</constant>;
}

<keyword>static</keyword> <constant>void</constant> compile_with_precedence(Compiler <keyword>*</keyword>C, <keyword>enum</keyword> Precedence precedence) {
    advance(C);
    Rule <keyword>*</keyword>rule <keyword>=</keyword> token_rule(C-&gt;previous.type);
    <constant>void</constant> (<keyword>*</keyword>prefix)(Compiler <keyword>*</keyword>, <constant>bool</constant>) <keyword>=</keyword> rule-&gt;prefix;
    <keyword>if</keyword> (prefix <keyword>==</keyword> <constant>NULL</constant>) {
        compile_error(C, <keyword>&</keyword>C-&gt;previous, <string>&quot;expression expected near '%.*s'&quot;</string>, C-&gt;previous.length, &C-&gt;source[C-&gt;previous.start]);
        <keyword>return</keyword>;
    }
    <constant>bool</constant> assign <keyword>=</keyword> precedence <keyword>&lt;</keyword><keyword>=</keyword> PRECEDENCE_ASSIGN;
    prefix(C, assign);
    <keyword>while</keyword> (precedence <keyword>&lt;</keyword><keyword>=</keyword> token_rule(C-&gt;current.type)-&gt;precedence) {
        advance(C);
        <constant>void</constant> (<keyword>*</keyword>infix)(Compiler <keyword>*</keyword>, <constant>bool</constant>) <keyword>=</keyword> token_rule(C-&gt;previous.type)-&gt;infix;
        <keyword>if</keyword> (infix <keyword>==</keyword> <constant>NULL</constant>) {
            compile_error(C, <keyword>&</keyword>C-&gt;previous, <string>&quot;expected infix&quot;</string>);
            <keyword>return</keyword>;
        }
        infix(C, assign);
    }
    <keyword>if</keyword> (assign <keyword>&</keyword><keyword>&</keyword> check_assign(C)) {
        advance(C);
        compile_error(C, <keyword>&</keyword>C-&gt;current, <string>&quot;invalid assignment&quot;</string>);
    }
}

<keyword>static</keyword> <constant>void</constant> consume(Compiler <keyword>*</keyword>C, <keyword>enum</keyword> TokenType type, <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>error) {
    <keyword>if</keyword> (C-&gt;current.type <keyword>==</keyword> type) {
        advance(C);
        <keyword>return</keyword>;
    }
    compile_error(C, <keyword>&</keyword>C-&gt;current, error);
}

<keyword>static</keyword> <constant>uint8_t</constant> push_hidden_local(Compiler <keyword>*</keyword>C) {
    Scope <keyword>*</keyword>scope <keyword>=</keyword> C-&gt;scope;
    <keyword>if</keyword> (scope-&gt;local_count <keyword>==</keyword> HYMN_UINT8_COUNT) {
        compile_error(C, <keyword>&</keyword>C-&gt;previous, <string>&quot;too many local variables in scope&quot;</string>);
        <keyword>return</keyword> <constant>0</constant>;
    }
    <constant>uint8_t</constant> index <keyword>=</keyword> (<constant>uint8_t</constant>)scope-&gt;local_count++;
    Local <keyword>*</keyword>local <keyword>=</keyword> <keyword>&</keyword>scope-&gt;locals[index];
    local-&gt;name = (Token){<constant>0</constant>};
    local-&gt;depth = scope-&gt;depth;
    <keyword>return</keyword> index;
}

<keyword>static</keyword> <constant>uint8_t</constant> arguments(Compiler <keyword>*</keyword>C) {
    <constant>uint8_t</constant> count <keyword>=</keyword> <constant>0</constant>;
    <keyword>if</keyword> (<keyword>!</keyword>check(C, TOKEN_RIGHT_PAREN)) {
        do {
            expression(C);
            <keyword>if</keyword> (count <keyword>==</keyword> UINT8_MAX) {
                compile_error(C, <keyword>&</keyword>C-&gt;previous, <string>&quot;too many function arguments&quot;</string>);
                <keyword>break</keyword>;
            }
            count++;
        } <keyword>while</keyword> (match(C, TOKEN_COMMA));
    }
    consume(C, TOKEN_RIGHT_PAREN, <string>&quot;function has no closing ')'&quot;</string>);
    <keyword>return</keyword> count;
}

<keyword>static</keyword> <constant>void</constant> compile_call(Compiler <keyword>*</keyword>C, <constant>bool</constant> assign) {
    (<constant>void</constant>)assign;
    <constant>uint8_t</constant> count <keyword>=</keyword> arguments(C);
    emit_short(C, OP_CALL, count);
}

<keyword>static</keyword> <constant>void</constant> compile_group(Compiler <keyword>*</keyword>C, <constant>bool</constant> assign) {
    (<constant>void</constant>)assign;
    expression(C);
    consume(C, TOKEN_RIGHT_PAREN, <string>&quot;parenthesis group has no closing ')'&quot;</string>);
}

<keyword>static</keyword> <constant>void</constant> compile_none(Compiler <keyword>*</keyword>C, <constant>bool</constant> assign) {
    (<constant>void</constant>)assign;
    emit(C, OP_NONE);
}

<keyword>static</keyword> <constant>void</constant> compile_<constant>true</constant>(Compiler <keyword>*</keyword>C, <constant>bool</constant> assign) {
    (<constant>void</constant>)assign;
    emit(C, OP_TRUE);
}

<keyword>static</keyword> <constant>void</constant> compile_<constant>false</constant>(Compiler <keyword>*</keyword>C, <constant>bool</constant> assign) {
    (<constant>void</constant>)assign;
    emit(C, OP_FALSE);
}

<keyword>static</keyword> <constant>void</constant> compile_integer(Compiler <keyword>*</keyword>C, <constant>bool</constant> assign) {
    (<constant>void</constant>)assign;
    emit_constant(C, hymn_new_<constant>int</constant>(C-&gt;current.integer));
}

<keyword>static</keyword> <constant>void</constant> compile_<constant>float</constant>(Compiler <keyword>*</keyword>C, <constant>bool</constant> assign) {
    (<constant>void</constant>)assign;
    emit_constant(C, hymn_new_<constant>float</constant>(C-&gt;current.floating));
}

<keyword>static</keyword> <constant>char</constant> escape_sequence(<keyword>const</keyword> <constant>char</constant> c) {
    <keyword>switch</keyword> (c) {
    <keyword>case</keyword> <string>'b'</string>:
        <keyword>return</keyword> <string>'\b'</string>;
    <keyword>case</keyword> <string>'f'</string>:
        <keyword>return</keyword> <string>'\f'</string>;
    <keyword>case</keyword> <string>'n'</string>:
        <keyword>return</keyword> <string>'\n'</string>;
    <keyword>case</keyword> <string>'r'</string>:
        <keyword>return</keyword> <string>'\r'</string>;
    <keyword>case</keyword> <string>'t'</string>:
        <keyword>return</keyword> <string>'\t'</string>;
    <keyword>case</keyword> <string>'v'</string>:
        <keyword>return</keyword> <string>'\v'</string>;
    <keyword>default</keyword>:
        <keyword>return</keyword> c;
    }
}

<keyword>static</keyword> HymnString <keyword>*</keyword>parse_string_literal(<keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>string, <constant>size_t</constant> start, <constant>size_t</constant> len) {
    <keyword>const</keyword> <constant>size_t</constant> end <keyword>=</keyword> start <keyword>+</keyword> len;
    HymnString <keyword>*</keyword>literal <keyword>=</keyword> hymn_new_string_with_capacity(len);
    <keyword>for</keyword> (<constant>size_t</constant> i <keyword>=</keyword> start; i <keyword>&lt;</keyword> end; i++) {
        <keyword>const</keyword> <constant>char</constant> c <keyword>=</keyword> string[i];
        <keyword>if</keyword> (c <keyword>==</keyword> <string>'\\'</string> <keyword>&</keyword><keyword>&</keyword> i <keyword>+</keyword> <constant>1</constant> <keyword>&lt;</keyword> end) {
            <keyword>const</keyword> <constant>char</constant> e <keyword>=</keyword> escape_sequence(string[i <keyword>+</keyword> <constant>1</constant>]);
            literal <keyword>=</keyword> hymn_string_append_<constant>char</constant>(literal, e);
            i++;
        } <keyword>else</keyword> {
            literal <keyword>=</keyword> hymn_string_append_<constant>char</constant>(literal, c);
        }
    }
    <keyword>return</keyword> literal;
}

<keyword>static</keyword> HymnValue string_literal(Compiler <keyword>*</keyword>C) {
    Token <keyword>*</keyword>previous <keyword>=</keyword> <keyword>&</keyword>C-&gt;previous;
    HymnString <keyword>*</keyword>string <keyword>=</keyword> parse_string_literal(C-&gt;source, previous-&gt;start, previous-&gt;length);
    <keyword>while</keyword> (check(C, TOKEN_STRING)) {
        Token <keyword>*</keyword>current <keyword>=</keyword> <keyword>&</keyword>C-&gt;current;
        HymnString <keyword>*</keyword>and <keyword>=</keyword> parse_string_literal(C-&gt;source, current-&gt;start, current-&gt;length);
        string <keyword>=</keyword> hymn_string_append(string, and);
        hymn_string_delete(and);
        advance(C);
    }
    <keyword>return</keyword> compile_intern_string(C-&gt;H, string);
}

<keyword>static</keyword> <constant>void</constant> compile_string(Compiler <keyword>*</keyword>C, <constant>bool</constant> assign) {
    (<constant>void</constant>)assign;
    emit_constant(C, string_literal(C));
}

<keyword>static</keyword> <constant>uint8_t</constant> ident_constant_string(Compiler <keyword>*</keyword>C) {
    <keyword>return</keyword> byte_code_new_constant(C, string_literal(C));
}

<keyword>static</keyword> <constant>uint8_t</constant> ident_constant(Compiler <keyword>*</keyword>C, Token <keyword>*</keyword>token) {
    HymnString <keyword>*</keyword>string <keyword>=</keyword> hymn_substring(C-&gt;source, token-&gt;start, token-&gt;start + token-&gt;length);
    <keyword>return</keyword> byte_code_new_constant(C, compile_intern_string(C-&gt;H, string));
}

<keyword>static</keyword> <constant>void</constant> begin_scope(Compiler <keyword>*</keyword>C) {
    C-&gt;scope-&gt;depth++;
}

<keyword>static</keyword> <constant>void</constant> end_scope(Compiler <keyword>*</keyword>C) {
    Scope <keyword>*</keyword>scope <keyword>=</keyword> C-&gt;scope;
    scope-&gt;depth--;
    <keyword>while</keyword> (scope-&gt;local_count &gt; <constant>0</constant> <keyword>&</keyword><keyword>&</keyword> scope-&gt;locals[scope-&gt;local_count - <constant>1</constant>].depth <keyword>&gt;</keyword> scope-&gt;depth) {
        emit_pop(C);
        scope-&gt;local_count--;
    }
    C-&gt;barrier = scope-&gt;func-&gt;code.count;
}

<keyword>static</keyword> <constant>void</constant> compile_array(Compiler <keyword>*</keyword>C, <constant>bool</constant> assign) {
    (<constant>void</constant>)assign;
    emit(C, OP_NEW_ARRAY);
    <keyword>if</keyword> (match(C, TOKEN_RIGHT_SQUARE)) {
        <keyword>return</keyword>;
    }
    <keyword>while</keyword> (<keyword>!</keyword>check(C, TOKEN_RIGHT_SQUARE) <keyword>&</keyword><keyword>&</keyword> <keyword>!</keyword>check(C, TOKEN_EOF)) {
        emit(C, OP_DUPLICATE);
        expression(C);
        emit(C, OP_ARRAY_PUSH);
        <keyword>if</keyword> (<keyword>!</keyword>check(C, TOKEN_RIGHT_SQUARE)) {
            consume(C, TOKEN_COMMA, <string>&quot;expected ',' between array elements&quot;</string>);
        }
    }
    consume(C, TOKEN_RIGHT_SQUARE, <string>&quot;expected ']' at end of array declaration&quot;</string>);
}

<keyword>static</keyword> <constant>void</constant> compile_table(Compiler <keyword>*</keyword>C, <constant>bool</constant> assign) {
    (<constant>void</constant>)assign;
    emit(C, OP_NEW_TABLE);
    <keyword>if</keyword> (match(C, TOKEN_RIGHT_CURLY)) {
        <keyword>return</keyword>;
    }
    <keyword>while</keyword> (<keyword>!</keyword>check(C, TOKEN_RIGHT_CURLY) <keyword>&</keyword><keyword>&</keyword> <keyword>!</keyword>check(C, TOKEN_EOF)) {
        emit(C, OP_DUPLICATE);
        <constant>uint8_t</constant> name;
        <keyword>if</keyword> (match(C, TOKEN_IDENT)) {
            name <keyword>=</keyword> ident_constant(C, <keyword>&</keyword>C-&gt;previous);
        } <keyword>else</keyword> <keyword>if</keyword> (match(C, TOKEN_STRING)) {
            name <keyword>=</keyword> ident_constant_string(C);
        } <keyword>else</keyword> {
            name <keyword>=</keyword> UINT8_MAX;
            compile_error(C, <keyword>&</keyword>C-&gt;current, <string>&quot;expected table key&quot;</string>);
        }
        consume(C, TOKEN_COLON, <string>&quot;expected ':' between table key and value&quot;</string>);
        expression(C);
        emit_short(C, OP_SET_PROPERTY, name);
        emit_pop(C);
        <keyword>if</keyword> (<keyword>!</keyword>check(C, TOKEN_RIGHT_CURLY)) {
            consume(C, TOKEN_COMMA, <string>&quot;expected ',' between table elements&quot;</string>);
        }
    }
    consume(C, TOKEN_RIGHT_CURLY, <string>&quot;expected '}' at end of table declaration&quot;</string>);
}

<keyword>static</keyword> <constant>void</constant> function_delete(HymnFunction <keyword>*</keyword>this) {
    byte_code_delete(<keyword>&</keyword>this-&gt;code);
    hymn_string_delete(this-&gt;name);
    hymn_string_delete(this-&gt;script);
    hymn_string_delete(this-&gt;source);
    HymnExceptList <keyword>*</keyword>except <keyword>=</keyword> this-&gt;except;
    <keyword>while</keyword> (except <keyword>!=</keyword> <constant>NULL</constant>) {
        HymnExceptList <keyword>*</keyword>next <keyword>=</keyword> except-&gt;next;
        <constant>free</constant>(except);
        except <keyword>=</keyword> next;
    }
    <constant>free</constant>(this);
}

<keyword>static</keyword> <constant>void</constant> native_function_delete(Hymn <keyword>*</keyword>H, HymnNativeFunction <keyword>*</keyword>this) {
    hymn_dereference_string(H, this-&gt;name);
    <constant>free</constant>(this);
}

<keyword>static</keyword> <constant>void</constant> push_local(Compiler <keyword>*</keyword>C, Token name) {
    Scope <keyword>*</keyword>scope <keyword>=</keyword> C-&gt;scope;
    <keyword>if</keyword> (scope-&gt;local_count <keyword>==</keyword> HYMN_UINT8_COUNT) {
        compile_error(C, <keyword>&</keyword>name, <string>&quot;too many local variables in scope&quot;</string>);
        <keyword>return</keyword>;
    }
    Local <keyword>*</keyword>local <keyword>=</keyword> <keyword>&</keyword>scope-&gt;locals[scope-&gt;local_count++];
    local-&gt;name = name;
    local-&gt;depth = -<constant>1</constant>;
}

<keyword>static</keyword> <constant>bool</constant> ident_match(Compiler <keyword>*</keyword>C, Token <keyword>*</keyword>a, Token <keyword>*</keyword>b) {
    <keyword>if</keyword> (a-&gt;length <keyword>!=</keyword> b-&gt;length) {
        <keyword>return</keyword> <constant>false</constant>;
    }
    <keyword>return</keyword> memcmp(<keyword>&</keyword>C-&gt;source[a-&gt;start], &C-&gt;source[b-&gt;start], a-&gt;length) <keyword>==</keyword> <constant>0</constant>;
}

<keyword>static</keyword> <constant>uint8_t</constant> variable(Compiler <keyword>*</keyword>C, <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>error) {
    consume(C, TOKEN_IDENT, error);
    Scope <keyword>*</keyword>scope <keyword>=</keyword> C-&gt;scope;
    <keyword>if</keyword> (scope-&gt;depth <keyword>==</keyword> <constant>0</constant>) {
        <keyword>return</keyword> ident_constant(C, <keyword>&</keyword>C-&gt;previous);
    }
    Token <keyword>*</keyword>name <keyword>=</keyword> <keyword>&</keyword>C-&gt;previous;
    <keyword>for</keyword> (<constant>int</constant> i <keyword>=</keyword> scope-&gt;local_count - <constant>1</constant>; i <keyword>&gt;</keyword><keyword>=</keyword> <constant>0</constant>; i--) {
        Local <keyword>*</keyword>local <keyword>=</keyword> <keyword>&</keyword>scope-&gt;locals[i];
        <keyword>if</keyword> (local-&gt;depth <keyword>!=</keyword> <keyword>-</keyword><constant>1</constant> <keyword>&</keyword><keyword>&</keyword> local-&gt;depth &lt; scope-&gt;depth) {
            <keyword>break</keyword>;
        } <keyword>else</keyword> <keyword>if</keyword> (ident_match(C, name, <keyword>&</keyword>local-&gt;name)) {
            compile_error(C, name, <string>&quot;variable '%.*s' already exists in scope&quot;</string>, name-&gt;length, &C-&gt;source[name-&gt;start]);
        }
    }
    push_local(C, <keyword>*</keyword>name);
    <keyword>return</keyword> <constant>0</constant>;
}

<keyword>static</keyword> <constant>void</constant> local_initialize(Compiler <keyword>*</keyword>C) {
    Scope <keyword>*</keyword>scope <keyword>=</keyword> C-&gt;scope;
    <keyword>if</keyword> (scope-&gt;depth <keyword>==</keyword> <constant>0</constant>) {
        <keyword>return</keyword>;
    }
    scope-&gt;locals[scope-&gt;local_count - <constant>1</constant>].depth <keyword>=</keyword> scope-&gt;depth;
}

<keyword>static</keyword> <constant>void</constant> finalize_variable(Compiler <keyword>*</keyword>C, <constant>uint8_t</constant> global) {
    <keyword>if</keyword> (C-&gt;scope-&gt;depth &gt; <constant>0</constant>) {
        local_initialize(C);
        <keyword>return</keyword>;
    }
    emit_short(C, OP_DEFINE_GLOBAL, global);
}

<keyword>static</keyword> <constant>void</constant> type_declaration(Compiler <keyword>*</keyword>C) {
    <keyword>if</keyword> (match(C, TOKEN_COLON)) {
        <keyword>enum</keyword> TokenType type <keyword>=</keyword> C-&gt;current.type;
        <keyword>switch</keyword> (type) {
        <keyword>case</keyword> TOKEN_NONE:
        <keyword>case</keyword> TOKEN_TO_FLOAT:
        <keyword>case</keyword> TOKEN_TO_STRING:
        <keyword>case</keyword> TOKEN_TO_INTEGER:
            advance(C);
            <keyword>return</keyword>;
        <keyword>default</keyword>:
            compile_error(C, <keyword>&</keyword>C-&gt;previous, <string>&quot;unavailable type declaration&quot;</string>);
            <keyword>return</keyword>;
        }
    }
}

<keyword>static</keyword> <constant>void</constant> define_new_variable(Compiler <keyword>*</keyword>C) {
    <constant>uint8_t</constant> global <keyword>=</keyword> variable(C, <string>&quot;expected a variable name&quot;</string>);
    type_declaration(C);
    consume(C, TOKEN_ASSIGN, <string>&quot;expected '=' after variable&quot;</string>);
    expression(C);
    finalize_variable(C, global);
}

<keyword>static</keyword> <constant>int</constant> resolve_local(Compiler <keyword>*</keyword>C, Token <keyword>*</keyword>name) {
    Scope <keyword>*</keyword>scope <keyword>=</keyword> C-&gt;scope;
    <keyword>for</keyword> (<constant>int</constant> i <keyword>=</keyword> scope-&gt;local_count - <constant>1</constant>; i <keyword>&gt;</keyword><keyword>=</keyword> <constant>0</constant>; i--) {
        Local <keyword>*</keyword>local <keyword>=</keyword> <keyword>&</keyword>scope-&gt;locals[i];
        <keyword>if</keyword> (ident_match(C, name, <keyword>&</keyword>local-&gt;name)) {
            <keyword>if</keyword> (local-&gt;depth <keyword>==</keyword> <keyword>-</keyword><constant>1</constant>) {
                compile_error(C, name, <string>&quot;local variable '%.*s' referenced before assignment&quot;</string>, name-&gt;length, &C-&gt;source[name-&gt;start]);
            }
            <keyword>return</keyword> i;
        }
    }
    <keyword>return</keyword> <keyword>-</keyword><constant>1</constant>;
}

<keyword>static</keyword> <constant>void</constant> named_variable(Compiler <keyword>*</keyword>C, Token token, <constant>bool</constant> assign) {
    <constant>uint8_t</constant> get;
    <constant>uint8_t</constant> set;
    <constant>int</constant> var <keyword>=</keyword> resolve_local(C, <keyword>&</keyword>token);
    <keyword>if</keyword> (var <keyword>!=</keyword> <keyword>-</keyword><constant>1</constant>) {
        get <keyword>=</keyword> OP_GET_LOCAL;
        set <keyword>=</keyword> OP_SET_LOCAL;
    } <keyword>else</keyword> {
        get <keyword>=</keyword> OP_GET_GLOBAL;
        set <keyword>=</keyword> OP_SET_GLOBAL;
        var <keyword>=</keyword> ident_constant(C, <keyword>&</keyword>token);
    }
    <keyword>if</keyword> (assign <keyword>&</keyword><keyword>&</keyword> check_assign(C)) {
        <keyword>enum</keyword> TokenType type <keyword>=</keyword> C-&gt;current.type;
        advance(C);
        <keyword>if</keyword> (type <keyword>!=</keyword> TOKEN_ASSIGN) {
            emit_short(C, get, (<constant>uint8_t</constant>)var);
        }
        expression(C);
        <keyword>switch</keyword> (type) {
        <keyword>case</keyword> TOKEN_ASSIGN_ADD: emit(C, OP_ADD); <keyword>break</keyword>;
        <keyword>case</keyword> TOKEN_ASSIGN_BIT_AND: emit(C, OP_BIT_AND); <keyword>break</keyword>;
        <keyword>case</keyword> TOKEN_ASSIGN_BIT_LEFT_SHIFT: emit(C, OP_BIT_LEFT_SHIFT); <keyword>break</keyword>;
        <keyword>case</keyword> TOKEN_ASSIGN_BIT_OR: emit(C, OP_BIT_OR); <keyword>break</keyword>;
        <keyword>case</keyword> TOKEN_ASSIGN_BIT_RIGHT_SHIFT: emit(C, OP_BIT_RIGHT_SHIFT); <keyword>break</keyword>;
        <keyword>case</keyword> TOKEN_ASSIGN_BIT_XOR: emit(C, OP_BIT_XOR); <keyword>break</keyword>;
        <keyword>case</keyword> TOKEN_ASSIGN_DIVIDE: emit(C, OP_DIVIDE); <keyword>break</keyword>;
        <keyword>case</keyword> TOKEN_ASSIGN_MODULO: emit(C, OP_MODULO); <keyword>break</keyword>;
        <keyword>case</keyword> TOKEN_ASSIGN_MULTIPLY: emit(C, OP_MULTIPLY); <keyword>break</keyword>;
        <keyword>case</keyword> TOKEN_ASSIGN_SUBTRACT: emit(C, OP_SUBTRACT); <keyword>break</keyword>;
        <keyword>default</keyword>: <keyword>break</keyword>;
        }
        emit_short(C, set, (<constant>uint8_t</constant>)var);
    } <keyword>else</keyword> {
        emit_short(C, get, (<constant>uint8_t</constant>)var);
    }
}

<keyword>static</keyword> <constant>void</constant> compile_variable(Compiler <keyword>*</keyword>C, <constant>bool</constant> assign) {
    named_variable(C, C-&gt;previous, assign);
}

<keyword>static</keyword> <constant>void</constant> compile_unary(Compiler <keyword>*</keyword>C, <constant>bool</constant> assign) {
    (<constant>void</constant>)assign;
    <keyword>enum</keyword> TokenType type <keyword>=</keyword> C-&gt;previous.type;
    compile_with_precedence(C, PRECEDENCE_UNARY);
    <keyword>switch</keyword> (type) {
    <keyword>case</keyword> TOKEN_NOT: emit(C, OP_NOT); <keyword>break</keyword>;
    <keyword>case</keyword> TOKEN_SUBTRACT: emit(C, OP_NEGATE); <keyword>break</keyword>;
    <keyword>case</keyword> TOKEN_BIT_NOT: emit(C, OP_BIT_NOT); <keyword>break</keyword>;
    <keyword>default</keyword>: <keyword>return</keyword>;
    }
}

<keyword>static</keyword> <constant>void</constant> compile_binary(Compiler <keyword>*</keyword>C, <constant>bool</constant> assign) {
    (<constant>void</constant>)assign;
    <keyword>enum</keyword> TokenType type <keyword>=</keyword> C-&gt;previous.type;
    Rule <keyword>*</keyword>rule <keyword>=</keyword> token_rule(type);
    compile_with_precedence(C, (<keyword>enum</keyword> Precedence)(rule-&gt;precedence + <constant>1</constant>));
    <keyword>switch</keyword> (type) {
    <keyword>case</keyword> TOKEN_ADD: emit(C, OP_ADD); <keyword>break</keyword>;
    <keyword>case</keyword> TOKEN_SUBTRACT: emit(C, OP_SUBTRACT); <keyword>break</keyword>;
    <keyword>case</keyword> TOKEN_MODULO: emit(C, OP_MODULO); <keyword>break</keyword>;
    <keyword>case</keyword> TOKEN_MULTIPLY: emit(C, OP_MULTIPLY); <keyword>break</keyword>;
    <keyword>case</keyword> TOKEN_DIVIDE: emit(C, OP_DIVIDE); <keyword>break</keyword>;
    <keyword>case</keyword> TOKEN_EQUAL: emit(C, OP_EQUAL); <keyword>break</keyword>;
    <keyword>case</keyword> TOKEN_NOT_EQUAL: emit(C, OP_NOT_EQUAL); <keyword>break</keyword>;
    <keyword>case</keyword> TOKEN_LESS: emit(C, OP_LESS); <keyword>break</keyword>;
    <keyword>case</keyword> TOKEN_LESS_EQUAL: emit(C, OP_LESS_EQUAL); <keyword>break</keyword>;
    <keyword>case</keyword> TOKEN_GREATER: emit(C, OP_GREATER); <keyword>break</keyword>;
    <keyword>case</keyword> TOKEN_GREATER_EQUAL: emit(C, OP_GREATER_EQUAL); <keyword>break</keyword>;
    <keyword>case</keyword> TOKEN_BIT_OR: emit(C, OP_BIT_OR); <keyword>break</keyword>;
    <keyword>case</keyword> TOKEN_BIT_AND: emit(C, OP_BIT_AND); <keyword>break</keyword>;
    <keyword>case</keyword> TOKEN_BIT_XOR: emit(C, OP_BIT_XOR); <keyword>break</keyword>;
    <keyword>case</keyword> TOKEN_BIT_LEFT_SHIFT: emit(C, OP_BIT_LEFT_SHIFT); <keyword>break</keyword>;
    <keyword>case</keyword> TOKEN_BIT_RIGHT_SHIFT: emit(C, OP_BIT_RIGHT_SHIFT); <keyword>break</keyword>;
    <keyword>default</keyword>: <keyword>return</keyword>;
    }
}

<keyword>static</keyword> <constant>void</constant> compile_dot(Compiler <keyword>*</keyword>C, <constant>bool</constant> assign) {
    consume(C, TOKEN_IDENT, <string>&quot;expected table key after '.'&quot;</string>);
    <constant>uint8_t</constant> name <keyword>=</keyword> ident_constant(C, <keyword>&</keyword>C-&gt;previous);
    <keyword>if</keyword> (assign <keyword>&</keyword><keyword>&</keyword> match(C, TOKEN_ASSIGN)) {
        expression(C);
        emit_short(C, OP_SET_PROPERTY, name);
    } <keyword>else</keyword> {
        emit_short(C, OP_GET_PROPERTY, name);
    }
}

<keyword>static</keyword> <constant>void</constant> compile_pointer(Compiler <keyword>*</keyword>C, <constant>bool</constant> assign) {
    (<constant>void</constant>)assign;
    consume(C, TOKEN_IDENT, <string>&quot;expected table key after '-&gt;'&quot;</string>);
    <constant>uint8_t</constant> name <keyword>=</keyword> ident_constant(C, <keyword>&</keyword>C-&gt;previous);
    consume(C, TOKEN_LEFT_PAREN, <string>&quot;expected '(' after function name&quot;</string>);
    emit_short(C, OP_SELF, name);
    <constant>uint8_t</constant> count <keyword>=</keyword> arguments(C);
    <keyword>if</keyword> (count <keyword>==</keyword> UINT8_MAX) {
        compile_error(C, <keyword>&</keyword>C-&gt;previous, <string>&quot;too many function arguments&quot;</string>);
        <keyword>return</keyword>;
    }
    emit_short(C, OP_CALL, (<constant>uint8_t</constant>)(count <keyword>+</keyword> <constant>1</constant>));
}

<keyword>static</keyword> <constant>void</constant> compile_square(Compiler <keyword>*</keyword>C, <constant>bool</constant> assign) {
    <keyword>if</keyword> (match(C, TOKEN_COLON)) {
        emit_constant(C, hymn_new_<constant>int</constant>(<constant>0</constant>));
        <keyword>if</keyword> (match(C, TOKEN_RIGHT_SQUARE)) {
            emit_constant(C, hymn_new_none());
        } <keyword>else</keyword> {
            expression(C);
            consume(C, TOKEN_RIGHT_SQUARE, <string>&quot;expected ']' after square bracket expression&quot;</string>);
        }
        emit(C, OP_SLICE);
    } <keyword>else</keyword> {
        expression(C);
        <keyword>if</keyword> (match(C, TOKEN_COLON)) {
            <keyword>if</keyword> (match(C, TOKEN_RIGHT_SQUARE)) {
                emit_constant(C, hymn_new_none());
            } <keyword>else</keyword> {
                expression(C);
                consume(C, TOKEN_RIGHT_SQUARE, <string>&quot;expected ']' after square bracket expression&quot;</string>);
            }
            emit(C, OP_SLICE);
        } <keyword>else</keyword> {
            consume(C, TOKEN_RIGHT_SQUARE, <string>&quot;expected ']' after square bracket expression&quot;</string>);
            <keyword>if</keyword> (assign <keyword>&</keyword><keyword>&</keyword> match(C, TOKEN_ASSIGN)) {
                expression(C);
                emit(C, OP_SET_DYNAMIC);
            } <keyword>else</keyword> {
                emit(C, OP_GET_DYNAMIC);
            }
        }
    }
}

<keyword>static</keyword> <constant>int</constant> emit_jump(Compiler <keyword>*</keyword>C, <constant>uint8_t</constant> instruction) {
    emit(C, instruction);
    emit_short(C, UINT8_MAX, UINT8_MAX);
    <keyword>return</keyword> current(C)<keyword>-&gt;</keyword>count <keyword>-</keyword> <constant>2</constant>;
}

<keyword>static</keyword> <constant>void</constant> patch_jump(Compiler <keyword>*</keyword>C, <constant>int</constant> jump) {
    <keyword>if</keyword> (jump <keyword>==</keyword> <keyword>-</keyword><constant>1</constant>) {
        <keyword>return</keyword>;
    }
    HymnByteCode <keyword>*</keyword>code <keyword>=</keyword> current(C);
    <constant>int</constant> count <keyword>=</keyword> code-&gt;count;
    <constant>int</constant> offset <keyword>=</keyword> count <keyword>-</keyword> jump <keyword>-</keyword> <constant>2</constant>;
    <keyword>if</keyword> (offset <keyword>&gt;</keyword> UINT16_MAX) {
        compile_error(C, <keyword>&</keyword>C-&gt;previous, <string>&quot;jump offset too large&quot;</string>);
        <keyword>return</keyword>;
    }
    code-&gt;instructions[jump] = (<constant>uint8_t</constant>)((offset <keyword>&gt;&gt;</keyword> <constant>8</constant>) <keyword>&</keyword> UINT8_MAX);
    code-&gt;instructions[jump + <constant>1</constant>] <keyword>=</keyword> (<constant>uint8_t</constant>)(offset <keyword>&</keyword> UINT8_MAX);
}

<keyword>static</keyword> JumpList <keyword>*</keyword>add_jump(Compiler <keyword>*</keyword>C, JumpList <keyword>*</keyword>list, <keyword>enum</keyword> OpCode instruction) {
    JumpList <keyword>*</keyword>jump <keyword>=</keyword> hymn_calloc(<constant>1</constant>, sizeof(JumpList));
    jump-&gt;jump = emit_jump(C, (<constant>uint8_t</constant>)instruction);
    jump-&gt;depth = C-&gt;scope-&gt;depth;
    jump-&gt;code = current(C);
    jump-&gt;next = list;
    <keyword>return</keyword> jump;
}

<keyword>static</keyword> <constant>void</constant> <constant>free</constant>_jump_and_list(Compiler <keyword>*</keyword>C) {
    JumpList <keyword>*</keyword>jump <keyword>=</keyword> C-&gt;jump_and;
    HymnByteCode <keyword>*</keyword>code <keyword>=</keyword> current(C);
    <constant>int</constant> depth <keyword>=</keyword> C-&gt;scope-&gt;depth;
    <keyword>while</keyword> (jump <keyword>!=</keyword> <constant>NULL</constant>) {
        <keyword>if</keyword> (jump-&gt;code <keyword>!=</keyword> code || jump-&gt;depth &lt; depth) {
            <keyword>break</keyword>;
        }
        patch_jump(C, jump-&gt;jump);
        JumpList <keyword>*</keyword>next <keyword>=</keyword> jump-&gt;next;
        <constant>free</constant>(jump);
        jump <keyword>=</keyword> next;
    }
    C-&gt;jump_and = jump;
}

<keyword>static</keyword> <constant>void</constant> <constant>free</constant>_jump_or_list(Compiler <keyword>*</keyword>C) {
    JumpList <keyword>*</keyword>jump <keyword>=</keyword> C-&gt;jump_or;
    HymnByteCode <keyword>*</keyword>code <keyword>=</keyword> current(C);
    <constant>int</constant> depth <keyword>=</keyword> C-&gt;scope-&gt;depth;
    <keyword>while</keyword> (jump <keyword>!=</keyword> <constant>NULL</constant>) {
        <keyword>if</keyword> (jump-&gt;code <keyword>!=</keyword> code || jump-&gt;depth &lt; depth) {
            <keyword>break</keyword>;
        }
        patch_jump(C, jump-&gt;jump);
        JumpList <keyword>*</keyword>next <keyword>=</keyword> jump-&gt;next;
        <constant>free</constant>(jump);
        jump <keyword>=</keyword> next;
    }
    C-&gt;jump_or = jump;
}

<keyword>static</keyword> <constant>void</constant> <constant>free</constant>_jumps(Compiler <keyword>*</keyword>C, JumpList <keyword>*</keyword>jump) {
    <keyword>while</keyword> (jump <keyword>!=</keyword> <constant>NULL</constant>) {
        patch_jump(C, jump-&gt;jump);
        JumpList <keyword>*</keyword>next <keyword>=</keyword> jump-&gt;next;
        <constant>free</constant>(jump);
        jump <keyword>=</keyword> next;
    }
}

<keyword>static</keyword> <constant>void</constant> compile_and(Compiler <keyword>*</keyword>C, <constant>bool</constant> assign) {
    (<constant>void</constant>)assign;
    C-&gt;jump_and = add_jump(C, C-&gt;jump_and, OP_JUMP_IF_FALSE);
    compile_with_precedence(C, PRECEDENCE_AND);
}

<keyword>static</keyword> <constant>void</constant> compile_or(Compiler <keyword>*</keyword>C, <constant>bool</constant> assign) {
    (<constant>void</constant>)assign;
    C-&gt;jump_or = add_jump(C, C-&gt;jump_or, OP_JUMP_IF_TRUE);
    <constant>free</constant>_jump_and_list(C);
    compile_with_precedence(C, PRECEDENCE_OR);
}

<keyword>static</keyword> <constant>int</constant> next(<constant>uint8_t</constant> instruction) {
    <keyword>switch</keyword> (instruction) {
    <keyword>case</keyword> OP_CALL:
    <keyword>case</keyword> OP_CONSTANT:
    <keyword>case</keyword> OP_DEFINE_GLOBAL:
    <keyword>case</keyword> OP_EXISTS:
    <keyword>case</keyword> OP_GET_GLOBAL:
    <keyword>case</keyword> OP_GET_LOCAL:
    <keyword>case</keyword> OP_GET_PROPERTY:
    <keyword>case</keyword> OP_INCREMENT:
    <keyword>case</keyword> OP_POP_N:
    <keyword>case</keyword> OP_PRINT:
    <keyword>case</keyword> OP_SELF:
    <keyword>case</keyword> OP_SET_GLOBAL:
    <keyword>case</keyword> OP_SET_LOCAL:
    <keyword>case</keyword> OP_SET_PROPERTY:
    <keyword>case</keyword> OP_TAIL_CALL:
        <keyword>return</keyword> <constant>2</constant>;
    <keyword>case</keyword> OP_ADD_LOCALS:
    <keyword>case</keyword> OP_ARRAY_PUSH_LOCALS:
    <keyword>case</keyword> OP_GET_GLOBAL_PROPERTY:
    <keyword>case</keyword> OP_GET_LOCALS:
    <keyword>case</keyword> OP_INCREMENT_LOCAL:
    <keyword>case</keyword> OP_INCREMENT_LOCAL_AND_SET:
    <keyword>case</keyword> OP_JUMP:
    <keyword>case</keyword> OP_JUMP_IF_EQUAL:
    <keyword>case</keyword> OP_JUMP_IF_FALSE:
    <keyword>case</keyword> OP_JUMP_IF_GREATER:
    <keyword>case</keyword> OP_JUMP_IF_GREATER_EQUAL:
    <keyword>case</keyword> OP_JUMP_IF_LESS:
    <keyword>case</keyword> OP_JUMP_IF_LESS_EQUAL:
    <keyword>case</keyword> OP_JUMP_IF_NOT_EQUAL:
    <keyword>case</keyword> OP_JUMP_IF_TRUE:
    <keyword>case</keyword> OP_LOOP:
    <keyword>case</keyword> OP_MODULO_LOCALS:
        <keyword>return</keyword> <constant>3</constant>;
    <keyword>case</keyword> OP_FOR:
    <keyword>case</keyword> OP_FOR_LOOP:
        <keyword>return</keyword> <constant>4</constant>;
    <keyword>case</keyword> OP_INCREMENT_LOOP:
    <keyword>case</keyword> OP_JUMP_IF_GREATER_LOCALS:
        <keyword>return</keyword> <constant>5</constant>;
    <keyword>default</keyword>:
        <keyword>return</keyword> <constant>1</constant>;
    }
}

<keyword>struct</keyword> Instruction {
    Instruction <keyword>*</keyword>next;
    <constant>int</constant> index;
    <constant>uint8_t</constant> instruction;
    <constant>char</constant> padding[<constant>3</constant>];
};

<keyword>struct</keyword> Optimizer {
    HymnByteCode <keyword>*</keyword>code;
    Instruction <keyword>*</keyword>important;
    HymnExceptList <keyword>*</keyword>except;
};

<constant>#define</constant> GET_JUMP(instructions, index, x, y) (((<constant>int</constant>)instructions[index <keyword>+</keyword> x] <keyword>&lt;&lt;</keyword> <constant>8</constant>) | (<constant>int</constant>)instructions[index <keyword>+</keyword> y])

<constant>#define</constant> UPDATE_JUMP(instructions, index, x, y, jump)              \
    instructions[index <keyword>+</keyword> x] <keyword>=</keyword> (<constant>uint8_t</constant>)((jump <keyword>&gt;&gt;</keyword> <constant>8</constant>) <keyword>&</keyword> UINT8_MAX); \
    instructions[index <keyword>+</keyword> y] <keyword>=</keyword> (<constant>uint8_t</constant>)(jump <keyword>&</keyword> UINT8_MAX);

<constant>#define</constant> IS_ADJUSTABLE(off, compare, T, operator)                                         \
    <keyword>if</keyword> (index compare target) {                                                          \
        <constant>int</constant> offset <keyword>=</keyword> index <keyword>+</keyword> off;                                                        \
        <constant>int</constant> jump <keyword>=</keyword> ((<constant>int</constant>)instructions[offset <keyword>-</keyword> <constant>2</constant>] <keyword>&lt;&lt;</keyword> <constant>8</constant>) | (<constant>int</constant>)instructions[offset <keyword>-</keyword> <constant>1</constant>]; \
        <keyword>if</keyword> (offset operator jump <keyword>==</keyword> target) {                                            \
            <keyword>return</keyword> view;                                                                 \
        }                                                                                \
    }                                                                                    \
    <keyword>break</keyword>;

<keyword>static</keyword> Instruction <keyword>*</keyword>adjustable(Optimizer <keyword>*</keyword>optimizer, <constant>int</constant> target) {
    Instruction <keyword>*</keyword>view <keyword>=</keyword> optimizer-&gt;important;
    <constant>uint8_t</constant> <keyword>*</keyword>instructions <keyword>=</keyword> optimizer-&gt;code-&gt;instructions;
    <keyword>while</keyword> (view <keyword>!=</keyword> <constant>NULL</constant>) {
        <constant>int</constant> index <keyword>=</keyword> view-&gt;index;
        <constant>uint8_t</constant> instruction <keyword>=</keyword> view-&gt;instruction;
        <keyword>switch</keyword> (instruction) {
        <keyword>case</keyword> OP_JUMP:
        <keyword>case</keyword> OP_JUMP_IF_FALSE:
        <keyword>case</keyword> OP_JUMP_IF_TRUE:
        <keyword>case</keyword> OP_JUMP_IF_EQUAL:
        <keyword>case</keyword> OP_JUMP_IF_NOT_EQUAL:
        <keyword>case</keyword> OP_JUMP_IF_LESS:
        <keyword>case</keyword> OP_JUMP_IF_GREATER:
        <keyword>case</keyword> OP_JUMP_IF_LESS_EQUAL:
        <keyword>case</keyword> OP_JUMP_IF_GREATER_EQUAL: {
            IS_ADJUSTABLE(<constant>3</constant>, <keyword>&lt;</keyword>, target, <keyword>+</keyword>)
        }
        <keyword>case</keyword> OP_FOR: {
            IS_ADJUSTABLE(<constant>4</constant>, <keyword>&lt;</keyword>, target, <keyword>+</keyword>)
        }
        <keyword>case</keyword> OP_JUMP_IF_GREATER_LOCALS: {
            IS_ADJUSTABLE(<constant>5</constant>, <keyword>&lt;</keyword>, target, <keyword>+</keyword>)
        }
        <keyword>case</keyword> OP_LOOP: {
            IS_ADJUSTABLE(<constant>3</constant>, <keyword>&gt;</keyword><keyword>=</keyword>, target, <keyword>-</keyword>)
        }
        <keyword>case</keyword> OP_FOR_LOOP: {
            IS_ADJUSTABLE(<constant>4</constant>, <keyword>&gt;</keyword><keyword>=</keyword>, target, <keyword>-</keyword>)
        }
        <keyword>case</keyword> OP_INCREMENT_LOOP: {
            IS_ADJUSTABLE(<constant>5</constant>, <keyword>&gt;</keyword><keyword>=</keyword>, target, <keyword>-</keyword>)
        }
        <keyword>default</keyword>:
            <keyword>break</keyword>;
        }
        view <keyword>=</keyword> view-&gt;next;
    }
    <keyword>return</keyword> <constant>NULL</constant>;
}

<keyword>static</keyword> <constant>void</constant> rewriting(Optimizer <keyword>*</keyword>optimizer, <constant>int</constant> start, <constant>int</constant> shift, <constant>bool</constant> inside) {
    <constant>uint8_t</constant> <keyword>*</keyword>instructions <keyword>=</keyword> optimizer-&gt;code-&gt;instructions;
    Instruction <keyword>*</keyword>view <keyword>=</keyword> optimizer-&gt;important;
    <keyword>while</keyword> (view <keyword>!=</keyword> <constant>NULL</constant>) {
        <constant>int</constant> i <keyword>=</keyword> view-&gt;index;
        <keyword>switch</keyword> (view-&gt;instruction) {
        <keyword>case</keyword> OP_JUMP:
        <keyword>case</keyword> OP_JUMP_IF_FALSE:
        <keyword>case</keyword> OP_JUMP_IF_TRUE:
        <keyword>case</keyword> OP_JUMP_IF_EQUAL:
        <keyword>case</keyword> OP_JUMP_IF_NOT_EQUAL:
        <keyword>case</keyword> OP_JUMP_IF_LESS:
        <keyword>case</keyword> OP_JUMP_IF_GREATER:
        <keyword>case</keyword> OP_JUMP_IF_LESS_EQUAL:
        <keyword>case</keyword> OP_JUMP_IF_GREATER_EQUAL: {
            <keyword>if</keyword> (i <keyword>&lt;</keyword> start) {
                <constant>int</constant> jump <keyword>=</keyword> GET_JUMP(instructions, i, <constant>1</constant>, <constant>2</constant>);
                <constant>int</constant> destination <keyword>=</keyword> i <keyword>+</keyword> <constant>3</constant> <keyword>+</keyword> jump;
                assert((destination <keyword>&lt;</keyword> start || destination <keyword>&gt;</keyword> start <keyword>+</keyword> shift) || <keyword>!</keyword>inside);
                <keyword>if</keyword> (destination <keyword>&gt;</keyword> start) {
                    jump <keyword>-</keyword><keyword>=</keyword> shift;
                    UPDATE_JUMP(instructions, i, <constant>1</constant>, <constant>2</constant>, jump)
                } <keyword>else</keyword> <keyword>if</keyword> (destination <keyword>&gt;</keyword><keyword>=</keyword> start <keyword>&</keyword><keyword>&</keyword> destination <keyword>&lt;</keyword><keyword>=</keyword> start <keyword>+</keyword> shift <keyword>&</keyword><keyword>&</keyword> inside) {
<comment>                    // not sure about this</comment>
                    jump <keyword>-</keyword><keyword>=</keyword> next(optimizer-&gt;code-&gt;instructions[destination]);
                    UPDATE_JUMP(instructions, i, <constant>1</constant>, <constant>2</constant>, jump)
                }
            }
            <keyword>break</keyword>;
        }
        <keyword>case</keyword> OP_JUMP_IF_GREATER_LOCALS: {
            <keyword>if</keyword> (i <keyword>&lt;</keyword> start) {
                <constant>int</constant> jump <keyword>=</keyword> GET_JUMP(instructions, i, <constant>3</constant>, <constant>4</constant>);
                <constant>int</constant> destination <keyword>=</keyword> i <keyword>+</keyword> <constant>5</constant> <keyword>+</keyword> jump;
                assert((destination <keyword>&lt;</keyword> start || destination <keyword>&gt;</keyword> start <keyword>+</keyword> shift) || <keyword>!</keyword>inside);
                <keyword>if</keyword> (destination <keyword>&gt;</keyword> start) {
                    jump <keyword>-</keyword><keyword>=</keyword> shift;
                    UPDATE_JUMP(instructions, i, <constant>3</constant>, <constant>4</constant>, jump)
                } <keyword>else</keyword> <keyword>if</keyword> (destination <keyword>&gt;</keyword><keyword>=</keyword> start <keyword>&</keyword><keyword>&</keyword> destination <keyword>&lt;</keyword><keyword>=</keyword> start <keyword>+</keyword> shift <keyword>&</keyword><keyword>&</keyword> inside) {
<comment>                    // not sure about this</comment>
                    jump <keyword>-</keyword><keyword>=</keyword> next(optimizer-&gt;code-&gt;instructions[destination]);
                    UPDATE_JUMP(instructions, i, <constant>3</constant>, <constant>4</constant>, jump)
                }
            }
            <keyword>break</keyword>;
        }
        <keyword>case</keyword> OP_FOR: {
            <keyword>if</keyword> (i <keyword>&lt;</keyword> start) {
                <constant>int</constant> jump <keyword>=</keyword> GET_JUMP(instructions, i, <constant>2</constant>, <constant>3</constant>);
                <constant>int</constant> destination <keyword>=</keyword> i <keyword>+</keyword> <constant>4</constant> <keyword>+</keyword> jump;
                assert((destination <keyword>&lt;</keyword> start || destination <keyword>&gt;</keyword> start <keyword>+</keyword> shift) || <keyword>!</keyword>inside);
                <keyword>if</keyword> (destination <keyword>&gt;</keyword> start) {
                    jump <keyword>-</keyword><keyword>=</keyword> shift;
                    UPDATE_JUMP(instructions, i, <constant>2</constant>, <constant>3</constant>, jump)
                }
            }
            <keyword>break</keyword>;
        }
        <keyword>case</keyword> OP_LOOP: {
            <keyword>if</keyword> (i <keyword>&gt;</keyword><keyword>=</keyword> start) {
                <constant>int</constant> jump <keyword>=</keyword> GET_JUMP(instructions, i, <constant>1</constant>, <constant>2</constant>);
                <constant>int</constant> destination <keyword>=</keyword> i <keyword>+</keyword> <constant>3</constant> <keyword>-</keyword> jump;
                assert((destination <keyword>&lt;</keyword> start || destination <keyword>&gt;</keyword> start <keyword>+</keyword> shift) || <keyword>!</keyword>inside);
                <keyword>if</keyword> (destination <keyword>&lt;</keyword> start) {
                    jump <keyword>-</keyword><keyword>=</keyword> shift;
                    UPDATE_JUMP(instructions, i, <constant>1</constant>, <constant>2</constant>, jump)
                } <keyword>else</keyword> <keyword>if</keyword> (destination <keyword>&gt;</keyword><keyword>=</keyword> start <keyword>&</keyword><keyword>&</keyword> destination <keyword>&lt;</keyword><keyword>=</keyword> start <keyword>+</keyword> shift <keyword>&</keyword><keyword>&</keyword> inside) {
<comment>                    // not sure about this</comment>
                    jump <keyword>-</keyword><keyword>=</keyword> next(optimizer-&gt;code-&gt;instructions[destination]);
                    UPDATE_JUMP(instructions, i, <constant>1</constant>, <constant>2</constant>, jump)
                }
            }
            <keyword>break</keyword>;
        }
        <keyword>case</keyword> OP_FOR_LOOP: {
            <keyword>if</keyword> (i <keyword>&gt;</keyword><keyword>=</keyword> start) {
                <constant>int</constant> jump <keyword>=</keyword> GET_JUMP(instructions, i, <constant>2</constant>, <constant>3</constant>);
                <constant>int</constant> destination <keyword>=</keyword> i <keyword>+</keyword> <constant>3</constant> <keyword>-</keyword> jump;
                assert((destination <keyword>&lt;</keyword> start || destination <keyword>&gt;</keyword> start <keyword>+</keyword> shift) || <keyword>!</keyword>inside);
                <keyword>if</keyword> (destination <keyword>&lt;</keyword> start) {
                    jump <keyword>-</keyword><keyword>=</keyword> shift;
                    UPDATE_JUMP(instructions, i, <constant>2</constant>, <constant>3</constant>, jump)
                } <keyword>else</keyword> <keyword>if</keyword> (destination <keyword>&gt;</keyword><keyword>=</keyword> start <keyword>&</keyword><keyword>&</keyword> destination <keyword>&lt;</keyword><keyword>=</keyword> start <keyword>+</keyword> shift <keyword>&</keyword><keyword>&</keyword> inside) {
<comment>                    // not sure about this</comment>
                    jump <keyword>-</keyword><keyword>=</keyword> next(optimizer-&gt;code-&gt;instructions[destination]);
                    UPDATE_JUMP(instructions, i, <constant>2</constant>, <constant>3</constant>, jump)
                }
            }
            <keyword>break</keyword>;
        }
        <keyword>case</keyword> OP_INCREMENT_LOOP: {
            <keyword>if</keyword> (i <keyword>&gt;</keyword><keyword>=</keyword> start) {
                <constant>int</constant> jump <keyword>=</keyword> GET_JUMP(instructions, i, <constant>3</constant>, <constant>4</constant>);
                <constant>int</constant> destination <keyword>=</keyword> i <keyword>+</keyword> <constant>5</constant> <keyword>-</keyword> jump;
                assert((destination <keyword>&lt;</keyword> start || destination <keyword>&gt;</keyword> start <keyword>+</keyword> shift) || <keyword>!</keyword>inside);
                <keyword>if</keyword> (destination <keyword>&lt;</keyword> start) {
                    jump <keyword>-</keyword><keyword>=</keyword> shift;
                    UPDATE_JUMP(instructions, i, <constant>3</constant>, <constant>4</constant>, jump)
                } <keyword>else</keyword> <keyword>if</keyword> (destination <keyword>&gt;</keyword><keyword>=</keyword> start <keyword>&</keyword><keyword>&</keyword> destination <keyword>&lt;</keyword><keyword>=</keyword> start <keyword>+</keyword> shift <keyword>&</keyword><keyword>&</keyword> inside) {
<comment>                    // not sure about this</comment>
                    jump <keyword>-</keyword><keyword>=</keyword> next(optimizer-&gt;code-&gt;instructions[destination]);
                    UPDATE_JUMP(instructions, i, <constant>3</constant>, <constant>4</constant>, jump)
                }
            }
            <keyword>break</keyword>;
        }
        <keyword>default</keyword>: <keyword>break</keyword>;
        }
        <keyword>if</keyword> (i <keyword>&gt;</keyword><keyword>=</keyword> start) {
            view-&gt;index = i - shift;
        }
        view <keyword>=</keyword> view-&gt;next;
    }

    <constant>int</constant> <keyword>*</keyword>lines <keyword>=</keyword> optimizer-&gt;code-&gt;lines;
    <constant>int</constant> count <keyword>=</keyword> optimizer-&gt;code-&gt;count - shift;
    <keyword>for</keyword> (<constant>int</constant> c <keyword>=</keyword> start; c <keyword>&lt;</keyword> count; c++) {
        <constant>int</constant> n <keyword>=</keyword> c <keyword>+</keyword> shift;
        instructions[c] <keyword>=</keyword> instructions[n];
        lines[c] <keyword>=</keyword> lines[n];
    }
    optimizer-&gt;code-&gt;count = count;

    HymnExceptList <keyword>*</keyword>except <keyword>=</keyword> optimizer-&gt;except;
    <keyword>while</keyword> (except <keyword>!=</keyword> <constant>NULL</constant>) {
        <keyword>if</keyword> (start <keyword>&lt;</keyword> except-&gt;start) {
            except-&gt;start -= shift;
            except-&gt;end -= shift;
        } <keyword>else</keyword> <keyword>if</keyword> (start <keyword>&lt;</keyword> except-&gt;end) {
            except-&gt;end -= shift;
        }
        except <keyword>=</keyword> except-&gt;next;
    }
}

<keyword>static</keyword> <constant>void</constant> rewrite(Optimizer <keyword>*</keyword>optimizer, <constant>int</constant> start, <constant>int</constant> shift) {
    rewriting(optimizer, start, shift, <constant>true</constant>);
}

<keyword>static</keyword> <constant>void</constant> update(Optimizer <keyword>*</keyword>optimizer, <constant>int</constant> index, <constant>uint8_t</constant> instruction) {
    Instruction <keyword>*</keyword>view <keyword>=</keyword> optimizer-&gt;important;
    <keyword>while</keyword> (view <keyword>!=</keyword> <constant>NULL</constant>) {
        <keyword>if</keyword> (index <keyword>==</keyword> view-&gt;index) {
            view-&gt;instruction = instruction;
            optimizer-&gt;code-&gt;instructions[index] = instruction;
            <keyword>return</keyword>;
        }
        view <keyword>=</keyword> view-&gt;next;
    }
    <constant>fprintf</constant>(stderr, <string>&quot;optimization failed to find instruction to update\n&quot;</string>);
    exit(<constant>1</constant>);
}

<keyword>static</keyword> <constant>void</constant> move(Optimizer <keyword>*</keyword>optimizer, <constant>int</constant> index, <constant>uint8_t</constant> instruction, <constant>int</constant> to) {
    Instruction <keyword>*</keyword>view <keyword>=</keyword> optimizer-&gt;important;
    <keyword>while</keyword> (view <keyword>!=</keyword> <constant>NULL</constant>) {
        <keyword>if</keyword> (index <keyword>==</keyword> view-&gt;index) {
            view-&gt;index = to;
            view-&gt;instruction = instruction;
            optimizer-&gt;code-&gt;instructions[to] = instruction;
            <keyword>return</keyword>;
        }
        view <keyword>=</keyword> view-&gt;next;
    }
    <constant>fprintf</constant>(stderr, <string>&quot;optimization failed to find instruction to move\n&quot;</string>);
    exit(<constant>1</constant>);
}

<keyword>static</keyword> <constant>void</constant> deletion(Optimizer <keyword>*</keyword>optimizer, <constant>int</constant> index) {
    Instruction <keyword>*</keyword>view <keyword>=</keyword> optimizer-&gt;important;
    Instruction <keyword>*</keyword>previous <keyword>=</keyword> <constant>NULL</constant>;
    <keyword>while</keyword> (view <keyword>!=</keyword> <constant>NULL</constant>) {
        <keyword>if</keyword> (index <keyword>==</keyword> view-&gt;index) {
            Instruction <keyword>*</keyword>next <keyword>=</keyword> view-&gt;next;
            <constant>free</constant>(view);
            <keyword>if</keyword> (previous <keyword>==</keyword> <constant>NULL</constant>) {
                optimizer-&gt;important = next;
            } <keyword>else</keyword> {
                previous-&gt;next = next;
            }
            <keyword>return</keyword>;
        }
        previous <keyword>=</keyword> view;
        view <keyword>=</keyword> view-&gt;next;
    }
    <constant>fprintf</constant>(stderr, <string>&quot;optimization failed to find instruction to delete\n&quot;</string>);
    exit(<constant>1</constant>);
}

<keyword>static</keyword> <constant>void</constant> interest(Optimizer <keyword>*</keyword>optimizer) {
    <constant>uint8_t</constant> <keyword>*</keyword>instructions <keyword>=</keyword> optimizer-&gt;code-&gt;instructions;
    <constant>int</constant> count <keyword>=</keyword> optimizer-&gt;code-&gt;count;
    Instruction <keyword>*</keyword>head <keyword>=</keyword> <constant>NULL</constant>;
    Instruction <keyword>*</keyword>tail <keyword>=</keyword> <constant>NULL</constant>;
    <constant>int</constant> i <keyword>=</keyword> <constant>0</constant>;
    <keyword>while</keyword> (i <keyword>&lt;</keyword> count) {
        <constant>uint8_t</constant> instruction <keyword>=</keyword> instructions[i];
        <keyword>switch</keyword> (instruction) {
        <keyword>case</keyword> OP_JUMP:
        <keyword>case</keyword> OP_JUMP_IF_FALSE:
        <keyword>case</keyword> OP_JUMP_IF_TRUE:
        <keyword>case</keyword> OP_JUMP_IF_EQUAL:
        <keyword>case</keyword> OP_JUMP_IF_NOT_EQUAL:
        <keyword>case</keyword> OP_JUMP_IF_LESS:
        <keyword>case</keyword> OP_JUMP_IF_GREATER:
        <keyword>case</keyword> OP_JUMP_IF_GREATER_LOCALS:
        <keyword>case</keyword> OP_JUMP_IF_LESS_EQUAL:
        <keyword>case</keyword> OP_JUMP_IF_GREATER_EQUAL:
        <keyword>case</keyword> OP_FOR:
        <keyword>case</keyword> OP_LOOP:
        <keyword>case</keyword> OP_FOR_LOOP:
        <keyword>case</keyword> OP_INCREMENT_LOOP: {
            Instruction <keyword>*</keyword>important <keyword>=</keyword> hymn_calloc(<constant>1</constant>, sizeof(Instruction));
            important-&gt;index = i;
            important-&gt;instruction = instruction;
            <keyword>if</keyword> (tail <keyword>==</keyword> <constant>NULL</constant>) {
                head <keyword>=</keyword> important;
            } <keyword>else</keyword> {
                tail-&gt;next = important;
            }
            tail <keyword>=</keyword> important;
            <keyword>break</keyword>;
        }
        <keyword>default</keyword>:
            <keyword>break</keyword>;
        }
        i <keyword>+</keyword><keyword>=</keyword> next(instruction);
    }
    optimizer-&gt;important = head;
}

<keyword>static</keyword> <constant>void</constant> optimize(Compiler <keyword>*</keyword>C) {

    Scope <keyword>*</keyword>scope <keyword>=</keyword> C-&gt;scope;
    HymnFunction <keyword>*</keyword>func <keyword>=</keyword> scope-&gt;func;

    Optimizer optimizer <keyword>=</keyword> {<constant>0</constant>};
    optimizer.code <keyword>=</keyword> <keyword>&</keyword>func-&gt;code;
    optimizer.except <keyword>=</keyword> func-&gt;except;

    <keyword>if</keyword> (optimizer.code-&gt;count &lt;= <constant>2</constant>) {
        <keyword>return</keyword>;
    }

    interest(<keyword>&</keyword>optimizer);

<constant>#define</constant> COUNT() optimizer.code-&gt;count
<constant>#define</constant> INSTRUCTION(I) optimizer.code-&gt;instructions[I]
<constant>#define</constant> CONSTANT(I) optimizer.code-&gt;constants.values[optimizer.code-&gt;instructions[I]]
<constant>#define</constant> SET(I, O) optimizer.code-&gt;instructions[I] = O
<constant>#define</constant> JUMP_IF(T, F)                        \
    <keyword>if</keyword> (second <keyword>==</keyword> OP_JUMP_IF_TRUE) {         \
        rewrite(<keyword>&</keyword>optimizer, one, <constant>1</constant>);         \
        update(<keyword>&</keyword>optimizer, one, T);          \
        <keyword>continue</keyword>;                            \
    } <keyword>else</keyword> <keyword>if</keyword> (second <keyword>==</keyword> OP_JUMP_IF_FALSE) { \
        rewrite(<keyword>&</keyword>optimizer, one, <constant>1</constant>);         \
        update(<keyword>&</keyword>optimizer, one, F);          \
        <keyword>continue</keyword>;                            \
    }

    <constant>int</constant> one <keyword>=</keyword> <constant>0</constant>;

    <keyword>while</keyword> (one <keyword>&lt;</keyword> COUNT()) {

        <constant>uint8_t</constant> first <keyword>=</keyword> INSTRUCTION(one);
        <constant>int</constant> two <keyword>=</keyword> one <keyword>+</keyword> next(first);
        <keyword>if</keyword> (two <keyword>&gt;</keyword><keyword>=</keyword> COUNT()) {
            <keyword>break</keyword>;
        }
        <constant>uint8_t</constant> second <keyword>=</keyword> INSTRUCTION(two);

        <keyword>switch</keyword> (first) {
        <keyword>case</keyword> OP_INCREMENT_LOCAL_AND_SET: {
            <keyword>if</keyword> (second <keyword>==</keyword> OP_LOOP) {
<comment>                // set to increment loop and reuse loop jump</comment>
                move(<keyword>&</keyword>optimizer, two, OP_INCREMENT_LOOP, one);
<comment>                // delete loop</comment>
                rewrite(<keyword>&</keyword>optimizer, two, <constant>1</constant>);
<comment>                // subtract 1 to account for one less byte to jump after deleting instruction</comment>
                <constant>uint8_t</constant> <keyword>*</keyword>instructions <keyword>=</keyword> optimizer.code-&gt;instructions;
                <constant>int</constant> jump <keyword>=</keyword> GET_JUMP(instructions, one, <constant>3</constant>, <constant>4</constant>) <keyword>-</keyword> <constant>1</constant>;
                UPDATE_JUMP(instructions, one, <constant>3</constant>, <constant>4</constant>, jump)
                <keyword>continue</keyword>;
            }
            <keyword>break</keyword>;
        }
        <keyword>case</keyword> OP_POP:
        <keyword>case</keyword> OP_POP_TWO: {
            <keyword>if</keyword> (second <keyword>==</keyword> OP_VOID) {
                rewriting(<keyword>&</keyword>optimizer, one, <constant>1</constant>, <constant>false</constant>);
                <keyword>continue</keyword>;
            }
            <keyword>break</keyword>;
        }
        <keyword>case</keyword> OP_POP_N: {
            <keyword>if</keyword> (second <keyword>==</keyword> OP_VOID) {
                rewriting(<keyword>&</keyword>optimizer, one, <constant>2</constant>, <constant>false</constant>);
                <keyword>continue</keyword>;
            }
            <keyword>break</keyword>;
        }
        <keyword>default</keyword>:
            <keyword>break</keyword>;
        }

        <keyword>if</keyword> (adjustable(<keyword>&</keyword>optimizer, two) <keyword>!=</keyword> <constant>NULL</constant>) {
            <keyword>goto</keyword> next;
        }

        <keyword>switch</keyword> (first) {
        <keyword>case</keyword> OP_GET_LOCAL: {
            <keyword>if</keyword> (second <keyword>==</keyword> OP_GET_LOCAL) {
                SET(one, OP_GET_LOCALS);
                rewrite(<keyword>&</keyword>optimizer, one <keyword>+</keyword> <constant>2</constant>, <constant>1</constant>);
                <keyword>continue</keyword>;
            }
            <keyword>break</keyword>;
        }
        <keyword>case</keyword> OP_GET_LOCALS: {
            <keyword>if</keyword> (second <keyword>==</keyword> OP_LESS_EQUAL) {
                <constant>int</constant> three <keyword>=</keyword> two <keyword>+</keyword> next(second);
                <constant>uint8_t</constant> third <keyword>=</keyword> three <keyword>&lt;</keyword> COUNT() ? INSTRUCTION(three) : UINT8_MAX;
                <keyword>if</keyword> (third <keyword>==</keyword> OP_JUMP_IF_FALSE) {
                    move(<keyword>&</keyword>optimizer, three, OP_JUMP_IF_GREATER_LOCALS, one);
                    rewrite(<keyword>&</keyword>optimizer, two, <constant>2</constant>);
                    <keyword>continue</keyword>;
                }
            }
            <keyword>break</keyword>;
        }
        <keyword>case</keyword> OP_POP: {
            <keyword>if</keyword> (second <keyword>==</keyword> OP_POP) {
                rewriting(<keyword>&</keyword>optimizer, one, <constant>1</constant>, <constant>false</constant>);
                SET(one, OP_POP_TWO);
                <keyword>continue</keyword>;
            }
            <keyword>break</keyword>;
        }
        <keyword>case</keyword> OP_POP_TWO: {
            <keyword>if</keyword> (second <keyword>==</keyword> OP_POP) {
                SET(one, OP_POP_N);
                SET(one <keyword>+</keyword> <constant>1</constant>, <constant>3</constant>);
                <keyword>continue</keyword>;
            }
            <keyword>break</keyword>;
        }
        <keyword>case</keyword> OP_POP_N: {
            <keyword>if</keyword> (second <keyword>==</keyword> OP_POP) {
                <constant>uint8_t</constant> pop <keyword>=</keyword> INSTRUCTION(one <keyword>+</keyword> <constant>1</constant>);
                <keyword>if</keyword> (pop <keyword>&lt;</keyword> UINT8_MAX <keyword>-</keyword> <constant>1</constant>) {
                    rewriting(<keyword>&</keyword>optimizer, one <keyword>+</keyword> <constant>1</constant>, <constant>1</constant>, <constant>false</constant>);
                    SET(one <keyword>+</keyword> <constant>1</constant>, (<constant>uint8_t</constant>)(pop <keyword>+</keyword> <constant>1</constant>));
                    <keyword>continue</keyword>;
                }
            }
            <keyword>break</keyword>;
        }
        <keyword>default</keyword>:
            <keyword>break</keyword>;
        }

        <keyword>if</keyword> (adjustable(<keyword>&</keyword>optimizer, one) <keyword>!=</keyword> <constant>NULL</constant>) {
            <keyword>goto</keyword> next;
        }

        <keyword>switch</keyword> (first) {
        <keyword>case</keyword> OP_RETURN: {
            <keyword>if</keyword> (second <keyword>==</keyword> OP_VOID) {
                rewrite(<keyword>&</keyword>optimizer, two, <constant>1</constant>);
                <keyword>continue</keyword>;
            }
            <keyword>break</keyword>;
        }
        <keyword>case</keyword> OP_CALL: {
            <keyword>if</keyword> (second <keyword>==</keyword> OP_RETURN) {
                SET(one, OP_TAIL_CALL);
                <keyword>continue</keyword>;
            }
            <keyword>break</keyword>;
        }
        <keyword>case</keyword> OP_GET_GLOBAL: {
            <keyword>if</keyword> (second <keyword>==</keyword> OP_GET_PROPERTY) {
                SET(one, OP_GET_GLOBAL_PROPERTY);
                rewrite(<keyword>&</keyword>optimizer, one <keyword>+</keyword> <constant>2</constant>, <constant>1</constant>);
                <keyword>continue</keyword>;
            }
            <keyword>break</keyword>;
        }
        <keyword>case</keyword> OP_GET_LOCAL: {
            <keyword>if</keyword> (second <keyword>==</keyword> OP_CONSTANT) {
                <constant>int</constant> three <keyword>=</keyword> two <keyword>+</keyword> next(second);
                <constant>uint8_t</constant> third <keyword>=</keyword> three <keyword>&lt;</keyword> COUNT() ? INSTRUCTION(three) : UINT8_MAX;
                <keyword>if</keyword> (third <keyword>==</keyword> OP_ADD) {
                    HymnValue value <keyword>=</keyword> CONSTANT(two <keyword>+</keyword> <constant>1</constant>);
                    <keyword>if</keyword> (hymn_is_<constant>int</constant>(value)) {
                        HymnInt add <keyword>=</keyword> hymn_as_<constant>int</constant>(value);
                        <keyword>if</keyword> (add <keyword>&gt;</keyword><keyword>=</keyword> <constant>0</constant> <keyword>&</keyword><keyword>&</keyword> add <keyword>&lt;</keyword><keyword>=</keyword> UINT8_MAX) {
                            <constant>uint8_t</constant> local <keyword>=</keyword> INSTRUCTION(one <keyword>+</keyword> <constant>1</constant>);
                            rewrite(<keyword>&</keyword>optimizer, one, <constant>2</constant>);
                            SET(one, OP_INCREMENT_LOCAL);
                            SET(one <keyword>+</keyword> <constant>1</constant>, local);
                            SET(one <keyword>+</keyword> <constant>2</constant>, (<constant>uint8_t</constant>)add);
                            <keyword>continue</keyword>;
                        }
                    }
                }
            }
            <keyword>break</keyword>;
        }
        <keyword>case</keyword> OP_GET_LOCALS: {
            <keyword>if</keyword> (second <keyword>==</keyword> OP_ADD) {
                SET(one, OP_ADD_LOCALS);
                rewrite(<keyword>&</keyword>optimizer, one <keyword>+</keyword> <constant>3</constant>, <constant>1</constant>);
                <keyword>continue</keyword>;
            } <keyword>else</keyword> <keyword>if</keyword> (second <keyword>==</keyword> OP_MODULO) {
                SET(one, OP_MODULO_LOCALS);
                rewrite(<keyword>&</keyword>optimizer, one <keyword>+</keyword> <constant>3</constant>, <constant>1</constant>);
                <keyword>continue</keyword>;
            } <keyword>else</keyword> <keyword>if</keyword> (second <keyword>==</keyword> OP_ARRAY_PUSH) {
                SET(one, OP_ARRAY_PUSH_LOCALS);
                rewrite(<keyword>&</keyword>optimizer, one <keyword>+</keyword> <constant>3</constant>, <constant>1</constant>);
                <keyword>continue</keyword>;
            }
            <keyword>break</keyword>;
        }
        <keyword>case</keyword> OP_INCREMENT_LOCAL: {
            <keyword>if</keyword> (second <keyword>==</keyword> OP_SET_LOCAL) {
                <keyword>if</keyword> (INSTRUCTION(one <keyword>+</keyword> <constant>1</constant>) <keyword>==</keyword> INSTRUCTION(one <keyword>+</keyword> <constant>4</constant>)) {
                    <constant>int</constant> three <keyword>=</keyword> two <keyword>+</keyword> next(second);
                    <constant>uint8_t</constant> third <keyword>=</keyword> three <keyword>&lt;</keyword> COUNT() ? INSTRUCTION(three) : UINT8_MAX;
                    <keyword>if</keyword> (third <keyword>==</keyword> OP_POP) {
                        SET(one, OP_INCREMENT_LOCAL_AND_SET);
                        rewrite(<keyword>&</keyword>optimizer, one <keyword>+</keyword> <constant>3</constant>, <constant>3</constant>);
                        <keyword>continue</keyword>;
                    }
                }
            }
            <keyword>break</keyword>;
        }
        <keyword>case</keyword> OP_CONSTANT: {
            <keyword>if</keyword> (second <keyword>==</keyword> OP_NEGATE) {
                HymnValue value <keyword>=</keyword> CONSTANT(one <keyword>+</keyword> <constant>1</constant>);
                <keyword>if</keyword> (hymn_is_<constant>int</constant>(value)) {
                    value.as.i <keyword>=</keyword> <keyword>-</keyword>value.as.i;
                } <keyword>else</keyword> <keyword>if</keyword> (hymn_is_<constant>float</constant>(value)) {
                    value.as.f <keyword>=</keyword> <keyword>-</keyword>value.as.f;
                }
                <constant>uint8_t</constant> constant <keyword>=</keyword> byte_code_new_constant(C, value);
                SET(one <keyword>+</keyword> <constant>1</constant>, constant);
                rewrite(<keyword>&</keyword>optimizer, one <keyword>+</keyword> <constant>2</constant>, <constant>1</constant>);
                <keyword>continue</keyword>;
            } <keyword>else</keyword> <keyword>if</keyword> (second <keyword>==</keyword> OP_ADD) {
                HymnValue value <keyword>=</keyword> CONSTANT(one <keyword>+</keyword> <constant>1</constant>);
                <keyword>if</keyword> (hymn_is_<constant>int</constant>(value)) {
                    HymnInt add <keyword>=</keyword> hymn_as_<constant>int</constant>(value);
                    <keyword>if</keyword> (add <keyword>&gt;</keyword><keyword>=</keyword> <constant>0</constant> <keyword>&</keyword><keyword>&</keyword> add <keyword>&lt;</keyword><keyword>=</keyword> UINT8_MAX) {
                        SET(one, OP_INCREMENT);
                        SET(one <keyword>+</keyword> <constant>1</constant>, (<constant>uint8_t</constant>)add);
                        rewrite(<keyword>&</keyword>optimizer, one <keyword>+</keyword> <constant>2</constant>, <constant>1</constant>);
                        <keyword>continue</keyword>;
                    }
                }
            }
            <keyword>break</keyword>;
        }
        <keyword>case</keyword> OP_EQUAL: {
            JUMP_IF(OP_JUMP_IF_EQUAL, OP_JUMP_IF_NOT_EQUAL)
            <keyword>break</keyword>;
        }
        <keyword>case</keyword> OP_NOT_EQUAL: {
            JUMP_IF(OP_JUMP_IF_NOT_EQUAL, OP_JUMP_IF_EQUAL)
            <keyword>break</keyword>;
        }
        <keyword>case</keyword> OP_LESS: {
            JUMP_IF(OP_JUMP_IF_LESS, OP_JUMP_IF_GREATER_EQUAL)
            <keyword>break</keyword>;
        }
        <keyword>case</keyword> OP_GREATER: {
            JUMP_IF(OP_JUMP_IF_GREATER, OP_JUMP_IF_LESS_EQUAL)
            <keyword>break</keyword>;
        }
        <keyword>case</keyword> OP_LESS_EQUAL: {
            JUMP_IF(OP_JUMP_IF_LESS_EQUAL, OP_JUMP_IF_GREATER)
            <keyword>break</keyword>;
        }
        <keyword>case</keyword> OP_GREATER_EQUAL: {
            JUMP_IF(OP_JUMP_IF_GREATER_EQUAL, OP_JUMP_IF_LESS)
            <keyword>break</keyword>;
        }
        <keyword>case</keyword> OP_TRUE: {
            <keyword>if</keyword> (second <keyword>==</keyword> OP_JUMP_IF_TRUE) {
                rewrite(<keyword>&</keyword>optimizer, one, <constant>1</constant>);
                update(<keyword>&</keyword>optimizer, one, OP_JUMP);
                <keyword>continue</keyword>;
            } <keyword>else</keyword> <keyword>if</keyword> (second <keyword>==</keyword> OP_JUMP_IF_FALSE) {
                deletion(<keyword>&</keyword>optimizer, two);
                rewrite(<keyword>&</keyword>optimizer, one, <constant>4</constant>);
                <keyword>continue</keyword>;
            }
            <keyword>break</keyword>;
        }
        <keyword>case</keyword> OP_FALSE: {
            <keyword>if</keyword> (second <keyword>==</keyword> OP_JUMP_IF_TRUE) {
                deletion(<keyword>&</keyword>optimizer, two);
                rewrite(<keyword>&</keyword>optimizer, one, <constant>4</constant>);
                <keyword>continue</keyword>;
            } <keyword>else</keyword> <keyword>if</keyword> (second <keyword>==</keyword> OP_JUMP_IF_FALSE) {
                rewrite(<keyword>&</keyword>optimizer, one, <constant>1</constant>);
                update(<keyword>&</keyword>optimizer, one, OP_JUMP);
                <keyword>continue</keyword>;
            }
            <keyword>break</keyword>;
        }
        <keyword>case</keyword> OP_NOT: {
            <keyword>if</keyword> (second <keyword>==</keyword> OP_JUMP_IF_TRUE) {
                rewrite(<keyword>&</keyword>optimizer, one, <constant>1</constant>);
                update(<keyword>&</keyword>optimizer, one, OP_JUMP_IF_FALSE);
                <keyword>continue</keyword>;
            } <keyword>else</keyword> <keyword>if</keyword> (second <keyword>==</keyword> OP_JUMP_IF_FALSE) {
                rewrite(<keyword>&</keyword>optimizer, one, <constant>1</constant>);
                update(<keyword>&</keyword>optimizer, one, OP_JUMP_IF_TRUE);
                <keyword>continue</keyword>;
            }
            <keyword>break</keyword>;
        }
        <keyword>default</keyword>:
            <keyword>break</keyword>;
        }

    next:
        one <keyword>=</keyword> two;
    }

    Instruction <keyword>*</keyword>important <keyword>=</keyword> optimizer.important;
    <keyword>while</keyword> (important <keyword>!=</keyword> <constant>NULL</constant>) {
        Instruction <keyword>*</keyword>next <keyword>=</keyword> important-&gt;next;
        <constant>free</constant>(important);
        important <keyword>=</keyword> next;
    }
}

<keyword>static</keyword> <constant>void</constant> echo_<keyword>if</keyword>_none(Compiler <keyword>*</keyword>C) {
    HymnByteCode <keyword>*</keyword>code <keyword>=</keyword> <keyword>&</keyword>C-&gt;scope-&gt;func-&gt;code;
    <constant>int</constant> count <keyword>=</keyword> code-&gt;count;
    <keyword>if</keyword> (C-&gt;barrier <keyword>==</keyword> count) <keyword>return</keyword>;
    <keyword>if</keyword> (C-&gt;pop <keyword>==</keyword> count) code-&gt;instructions[count - <constant>1</constant>] <keyword>=</keyword> OP_ECHO;
}

<keyword>static</keyword> HymnFunction <keyword>*</keyword>end_function(Compiler <keyword>*</keyword>C) {
    Scope <keyword>*</keyword>scope <keyword>=</keyword> C-&gt;scope;
    HymnFunction <keyword>*</keyword>func <keyword>=</keyword> scope-&gt;func;
    <keyword>if</keyword> (scope-&gt;type <keyword>==</keyword> TYPE_SCRIPT || scope-&gt;type <keyword>==</keyword> TYPE_REPL) echo_<keyword>if</keyword>_none(C);
    emit(C, OP_VOID);
<constant>#ifndef</constant> HYMN_NO_OPTIMIZE
    optimize(C);
<constant>#endif</constant>
    <keyword>if</keyword> (scope-&gt;type <keyword>==</keyword> TYPE_FUNCTION) func-&gt;source = hymn_substring(C-&gt;source, scope-&gt;begin, C-&gt;previous.start + C-&gt;previous.length);
    C-&gt;scope = scope-&gt;enclosing;
    <keyword>return</keyword> func;
}

<keyword>static</keyword> <constant>void</constant> compile_function(Compiler <keyword>*</keyword>C, <keyword>enum</keyword> FunctionType type, <constant>size_t</constant> begin) {
    Scope scope <keyword>=</keyword> {<constant>0</constant>};
    scope_init(C, <keyword>&</keyword>scope, type, begin);

    begin_scope(C);

    consume(C, TOKEN_LEFT_PAREN, <string>&quot;expected '(' after function name&quot;</string>);

    HymnFunction <keyword>*</keyword>func <keyword>=</keyword> C-&gt;scope-&gt;func;

    <keyword>if</keyword> (<keyword>!</keyword>check(C, TOKEN_RIGHT_PAREN)) {
        do {
            func-&gt;arity++;
            <keyword>if</keyword> (func-&gt;arity &gt; UINT8_MAX) {
                compile_error(C, <keyword>&</keyword>C-&gt;previous, <string>&quot;too many function parameters&quot;</string>);
            }
            <constant>uint8_t</constant> parameter <keyword>=</keyword> variable(C, <string>&quot;expected parameter name&quot;</string>);
            finalize_variable(C, parameter);
            type_declaration(C);
        } <keyword>while</keyword> (match(C, TOKEN_COMMA));
    }

    consume(C, TOKEN_RIGHT_PAREN, <string>&quot;expected ')' after function parameters&quot;</string>);
    type_declaration(C);
    consume(C, TOKEN_LEFT_CURLY, <string>&quot;expected '{' after function parameters&quot;</string>);

    <keyword>while</keyword> (<keyword>!</keyword>check(C, TOKEN_RIGHT_CURLY) <keyword>&</keyword><keyword>&</keyword> <keyword>!</keyword>check(C, TOKEN_EOF)) {
        declaration(C);
    }

    consume(C, TOKEN_RIGHT_CURLY, <string>&quot;expected '}' at end of function body&quot;</string>);

    end_function(C);
    emit_constant(C, hymn_new_func_value(func));
}

<keyword>static</keyword> <constant>void</constant> function_expression(Compiler <keyword>*</keyword>C, <constant>bool</constant> assign) {
    (<constant>void</constant>)assign;
    compile_function(C, TYPE_FUNCTION, C-&gt;previous.start);
}

<keyword>static</keyword> <constant>void</constant> declare_function(Compiler <keyword>*</keyword>C) {
    <constant>size_t</constant> begin <keyword>=</keyword> C-&gt;previous.start;
    <constant>uint8_t</constant> global <keyword>=</keyword> variable(C, <string>&quot;expected function name&quot;</string>);
    local_initialize(C);
    compile_function(C, TYPE_FUNCTION, begin);
    finalize_variable(C, global);
}

<keyword>static</keyword> <constant>void</constant> declaration(Compiler <keyword>*</keyword>C) {
    <keyword>if</keyword> (match(C, TOKEN_LET)) {
        define_new_variable(C);
    } <keyword>else</keyword> <keyword>if</keyword> (match(C, TOKEN_FUNCTION)) {
        declare_function(C);
    } <keyword>else</keyword> {
        statement(C);
    }
}

<keyword>static</keyword> <constant>void</constant> block(Compiler <keyword>*</keyword>C) {
    begin_scope(C);
    <keyword>while</keyword> (<keyword>!</keyword>check(C, TOKEN_RIGHT_CURLY) <keyword>&</keyword><keyword>&</keyword> <keyword>!</keyword>check(C, TOKEN_EOF)) {
        declaration(C);
    }
    end_scope(C);
}

<keyword>static</keyword> <constant>void</constant> <keyword>if</keyword>_statement(Compiler <keyword>*</keyword>C) {
    expression(C);
    <constant>int</constant> jump <keyword>=</keyword> emit_jump(C, OP_JUMP_IF_FALSE);

    <constant>free</constant>_jump_or_list(C);

    consume(C, TOKEN_LEFT_CURLY, <string>&quot;expected '{' after if statement&quot;</string>);
    begin_scope(C);
    <keyword>while</keyword> (<keyword>!</keyword>check(C, TOKEN_RIGHT_CURLY) <keyword>&</keyword><keyword>&</keyword> <keyword>!</keyword>check(C, TOKEN_EOF)) {
        declaration(C);
    }
    end_scope(C);

    consume(C, TOKEN_RIGHT_CURLY, <string>&quot;expected '}' at end of if statement body&quot;</string>);

    <keyword>if</keyword> (check(C, TOKEN_ELIF) || check(C, TOKEN_ELSE)) {
        JumpList jump_end <keyword>=</keyword> {<constant>0</constant>};
        jump_end.jump <keyword>=</keyword> emit_jump(C, OP_JUMP);
        JumpList <keyword>*</keyword>tail <keyword>=</keyword> <keyword>&</keyword>jump_end;

        <keyword>while</keyword> (match(C, TOKEN_ELIF)) {
            patch_jump(C, jump);
            <constant>free</constant>_jump_and_list(C);

            expression(C);
            jump <keyword>=</keyword> emit_jump(C, OP_JUMP_IF_FALSE);

            <constant>free</constant>_jump_or_list(C);

            consume(C, TOKEN_LEFT_CURLY, <string>&quot;expected '{' after elif statement&quot;</string>);
            begin_scope(C);
            <keyword>while</keyword> (<keyword>!</keyword>check(C, TOKEN_RIGHT_CURLY) <keyword>&</keyword><keyword>&</keyword> <keyword>!</keyword>check(C, TOKEN_EOF)) {
                declaration(C);
            }
            end_scope(C);
            consume(C, TOKEN_RIGHT_CURLY, <string>&quot;expected '}' at end of elif statement body&quot;</string>);

            JumpList <keyword>*</keyword>next <keyword>=</keyword> hymn_calloc(<constant>1</constant>, sizeof(JumpList));
            next-&gt;jump = emit_jump(C, OP_JUMP);

            tail-&gt;next = next;
            tail <keyword>=</keyword> next;
        }

        patch_jump(C, jump);
        <constant>free</constant>_jump_and_list(C);

        <keyword>if</keyword> (match(C, TOKEN_ELSE)) {
            consume(C, TOKEN_LEFT_CURLY, <string>&quot;expected '{' after else statement&quot;</string>);
            block(C);
            consume(C, TOKEN_RIGHT_CURLY, <string>&quot;expected '}' at end of else statement body&quot;</string>);
        }

        patch_jump(C, jump_end.jump);
        <constant>free</constant>_jumps(C, jump_end.next);
    } <keyword>else</keyword> {
        patch_jump(C, jump);
        <constant>free</constant>_jump_and_list(C);
    }
}

<keyword>static</keyword> <constant>void</constant> emit_loop(Compiler <keyword>*</keyword>C, <constant>int</constant> start) {
    emit(C, OP_LOOP);
    <constant>int</constant> offset <keyword>=</keyword> current(C)<keyword>-&gt;</keyword>count <keyword>-</keyword> start <keyword>+</keyword> <constant>2</constant>;
    <keyword>if</keyword> (offset <keyword>&gt;</keyword> UINT16_MAX) {
        compile_error(C, <keyword>&</keyword>C-&gt;previous, <string>&quot;loop is too large&quot;</string>);
    }
    emit_short(C, (<constant>uint8_t</constant>)((offset <keyword>&gt;&gt;</keyword> <constant>8</constant>) <keyword>&</keyword> UINT8_MAX), (<constant>uint8_t</constant>)(offset <keyword>&</keyword> UINT8_MAX));
}

<keyword>static</keyword> <constant>void</constant> patch_jump_list(Compiler <keyword>*</keyword>C) {
    <keyword>while</keyword> (C-&gt;jump <keyword>!=</keyword> <constant>NULL</constant>) {
        <constant>int</constant> depth;
        <keyword>if</keyword> (C-&gt;loop <keyword>==</keyword> <constant>NULL</constant>) {
            depth <keyword>=</keyword> <constant>1</constant>;
        } <keyword>else</keyword> {
            depth <keyword>=</keyword> C-&gt;loop-&gt;depth + <constant>1</constant>;
        }
        <keyword>if</keyword> (C-&gt;jump-&gt;depth &lt; depth) {
            <keyword>break</keyword>;
        }
        patch_jump(C, C-&gt;jump-&gt;jump);
        JumpList <keyword>*</keyword>next <keyword>=</keyword> C-&gt;jump-&gt;next;
        <constant>free</constant>(C-&gt;jump);
        C-&gt;jump = next;
    }
}

<keyword>static</keyword> <constant>void</constant> patch_jump_<keyword>for</keyword>_list(Compiler <keyword>*</keyword>C) {
    <keyword>while</keyword> (C-&gt;jump_<keyword>for</keyword> <keyword>!=</keyword> <constant>NULL</constant>) {
        <constant>int</constant> depth;
        <keyword>if</keyword> (C-&gt;loop <keyword>==</keyword> <constant>NULL</constant>) {
            depth <keyword>=</keyword> <constant>1</constant>;
        } <keyword>else</keyword> {
            depth <keyword>=</keyword> C-&gt;loop-&gt;depth;
        }
        <keyword>if</keyword> (C-&gt;jump_<keyword>for</keyword><keyword>-&gt;</keyword>depth <keyword>&lt;</keyword> depth) {
            <keyword>break</keyword>;
        }
        patch_jump(C, C-&gt;jump_<keyword>for</keyword><keyword>-&gt;</keyword>jump);
        JumpList <keyword>*</keyword>next <keyword>=</keyword> C-&gt;jump_<keyword>for</keyword><keyword>-&gt;</keyword>next;
        <constant>free</constant>(C-&gt;jump_<keyword>for</keyword>);
        C-&gt;jump_<keyword>for</keyword> <keyword>=</keyword> next;
    }
}

<keyword>static</keyword> <constant>void</constant> iterator_statement(Compiler <keyword>*</keyword>C, <constant>bool</constant> pair) {
    local_initialize(C);

    <constant>int</constant> index <keyword>=</keyword> C-&gt;scope-&gt;local_count;

    <keyword>if</keyword> (index <keyword>&lt;</keyword><keyword>=</keyword> <constant>0</constant> || index <keyword>&gt;</keyword><keyword>=</keyword> UINT8_MAX) {
        compile_error(C, <keyword>&</keyword>C-&gt;current, <string>&quot;too many local variables in iterator&quot;</string>);
        <keyword>return</keyword>;
    }

    <constant>uint8_t</constant> value <keyword>=</keyword> (<constant>uint8_t</constant>)(index <keyword>+</keyword> <constant>1</constant>);
    <constant>uint8_t</constant> object <keyword>=</keyword> (<constant>uint8_t</constant>)(index <keyword>-</keyword> <constant>1</constant>);

    push_hidden_local(C);

    <keyword>if</keyword> (pair) {
        variable(C, <string>&quot;expected variable name in for loop&quot;</string>);
        local_initialize(C);
        consume(C, TOKEN_IN, <string>&quot;expected 'in' after variable name in for loop&quot;</string>);
        C-&gt;scope-&gt;locals[index].name = C-&gt;scope-&gt;locals[object].name;
    } <keyword>else</keyword> {
        push_hidden_local(C);
        C-&gt;scope-&gt;locals[value].name = C-&gt;scope-&gt;locals[object].name;
    }

    C-&gt;scope-&gt;locals[object].name = (Token){<constant>0</constant>};

<comment>    // IN</comment>

    expression(C);

    emit_short(C, OP_FOR, object);
    emit_short(C, UINT8_MAX, UINT8_MAX);

    <constant>int</constant> start <keyword>=</keyword> current(C)<keyword>-&gt;</keyword>count;
    <constant>int</constant> jump <keyword>=</keyword> start <keyword>-</keyword> <constant>2</constant>;

    LoopList loop <keyword>=</keyword> {.start <keyword>=</keyword> start, .depth <keyword>=</keyword> C-&gt;scope-&gt;depth + <constant>1</constant>, .next <keyword>=</keyword> C-&gt;loop, .is_<keyword>for</keyword> <keyword>=</keyword> <constant>true</constant>};
    C-&gt;loop = &loop;

<comment>    // BODY</comment>

    consume(C, TOKEN_LEFT_CURLY, <string>&quot;expected '{' after for loop declaration&quot;</string>);
    block(C);

<comment>    // LOOP</comment>

    patch_jump_<keyword>for</keyword>_list(C);

    emit_short(C, OP_FOR_LOOP, object);
    <constant>int</constant> offset <keyword>=</keyword> current(C)<keyword>-&gt;</keyword>count <keyword>-</keyword> start <keyword>+</keyword> <constant>2</constant>;
    <keyword>if</keyword> (offset <keyword>&gt;</keyword> UINT16_MAX) {
        compile_error(C, <keyword>&</keyword>C-&gt;previous, <string>&quot;loop is too large&quot;</string>);
    }
    emit_short(C, (<constant>uint8_t</constant>)((offset <keyword>&gt;&gt;</keyword> <constant>8</constant>) <keyword>&</keyword> UINT8_MAX), (<constant>uint8_t</constant>)(offset <keyword>&</keyword> UINT8_MAX));

<comment>    // END</comment>

    C-&gt;loop = loop.next;

    patch_jump(C, jump);
    patch_jump_list(C);

    end_scope(C);

    consume(C, TOKEN_RIGHT_CURLY, <string>&quot;expected '}' at end of for loop&quot;</string>);
}

<keyword>static</keyword> <constant>void</constant> <keyword>for</keyword>_statement(Compiler <keyword>*</keyword>C) {
    begin_scope(C);

<comment>    // ASSIGN</comment>

    <constant>uint8_t</constant> index <keyword>=</keyword> (<constant>uint8_t</constant>)C-&gt;scope-&gt;local_count;

    variable(C, <string>&quot;expected variable name in for loop&quot;</string>);

    <keyword>if</keyword> (match(C, TOKEN_ASSIGN)) {
        expression(C);
        local_initialize(C);
        consume(C, TOKEN_COMMA, <string>&quot;expected ',' in for loop after variable assignment&quot;</string>);
    } <keyword>else</keyword> <keyword>if</keyword> (match(C, TOKEN_COMMA)) {
        iterator_statement(C, <constant>true</constant>);
        <keyword>return</keyword>;
    } <keyword>else</keyword> <keyword>if</keyword> (match(C, TOKEN_IN)) {
        iterator_statement(C, <constant>false</constant>);
        <keyword>return</keyword>;
    } <keyword>else</keyword> {
        compile_error(C, <keyword>&</keyword>C-&gt;previous, <string>&quot;incomplete for loop declaration&quot;</string>);
        <keyword>return</keyword>;
    }

<comment>    // COMPARE</comment>

    <constant>int</constant> compare <keyword>=</keyword> current(C)<keyword>-&gt;</keyword>count;

    expression(C);

    <constant>int</constant> jump <keyword>=</keyword> emit_jump(C, OP_JUMP_IF_FALSE);

<comment>    // INCREMENT</comment>

    <constant>int</constant> increment <keyword>=</keyword> current(C)<keyword>-&gt;</keyword>count;

    LoopList loop <keyword>=</keyword> {.start <keyword>=</keyword> increment, .depth <keyword>=</keyword> C-&gt;scope-&gt;depth + <constant>1</constant>, .next <keyword>=</keyword> C-&gt;loop, .is_<keyword>for</keyword> <keyword>=</keyword> <constant>true</constant>};
    C-&gt;loop = &loop;

    <keyword>if</keyword> (match(C, TOKEN_COMMA)) {
        expression_statement(C);
    } <keyword>else</keyword> {
        emit_word(C, OP_INCREMENT_LOCAL_AND_SET, index, <constant>1</constant>);
    }

    HymnByteCode <keyword>*</keyword>code <keyword>=</keyword> current(C);

    <constant>int</constant> count <keyword>=</keyword> code-&gt;count - increment;
    <constant>uint8_t</constant> <keyword>*</keyword>instructions <keyword>=</keyword> hymn_malloc_<constant>int</constant>(count, sizeof(<constant>uint8_t</constant>));
    <constant>int</constant> <keyword>*</keyword>lines <keyword>=</keyword> hymn_malloc_<constant>int</constant>(count, sizeof(<constant>int</constant>));
    hymn_mem_copy(instructions, <keyword>&</keyword>code-&gt;instructions[increment], count, sizeof(<constant>uint8_t</constant>));
    hymn_mem_copy(lines, <keyword>&</keyword>code-&gt;lines[increment], count, sizeof(<constant>int</constant>));
    code-&gt;count = increment;

<comment>    // BODY</comment>

    consume(C, TOKEN_LEFT_CURLY, <string>&quot;expected '{' after for loop declaration&quot;</string>);
    block(C);

<comment>    // INCREMENT</comment>

    patch_jump_<keyword>for</keyword>_list(C);

    <keyword>while</keyword> (code-&gt;count + count &gt; code-&gt;capacity) {
        code-&gt;capacity *= <constant>2</constant>;
        code-&gt;instructions = hymn_realloc_<constant>int</constant>(code-&gt;instructions, code-&gt;capacity, sizeof(<constant>uint8_t</constant>));
        code-&gt;lines = hymn_realloc_<constant>int</constant>(code-&gt;lines, code-&gt;capacity, sizeof(<constant>int</constant>));
    }
    hymn_mem_copy(<keyword>&</keyword>code-&gt;instructions[code-&gt;count], instructions, count, sizeof(<constant>uint8_t</constant>));
    hymn_mem_copy(<keyword>&</keyword>code-&gt;lines[code-&gt;count], lines, count, sizeof(<constant>int</constant>));
    code-&gt;count += count;
    <constant>free</constant>(instructions);
    <constant>free</constant>(lines);

    emit_loop(C, compare);

<comment>    // END</comment>

    C-&gt;loop = loop.next;

    patch_jump(C, jump);
    patch_jump_list(C);

    end_scope(C);

    consume(C, TOKEN_RIGHT_CURLY, <string>&quot;expected '}' at end of for loop&quot;</string>);
}

<keyword>static</keyword> <constant>void</constant> <keyword>while</keyword>_statement(Compiler <keyword>*</keyword>C) {
    <constant>int</constant> start <keyword>=</keyword> current(C)<keyword>-&gt;</keyword>count;

    LoopList loop <keyword>=</keyword> {.start <keyword>=</keyword> start, .depth <keyword>=</keyword> C-&gt;scope-&gt;depth + <constant>1</constant>, .next <keyword>=</keyword> C-&gt;loop, .is_<keyword>for</keyword> <keyword>=</keyword> <constant>false</constant>};
    C-&gt;loop = &loop;

    expression(C);

    <constant>int</constant> jump <keyword>=</keyword> emit_jump(C, OP_JUMP_IF_FALSE);

    consume(C, TOKEN_LEFT_CURLY, <string>&quot;expected '{' after while loop declaration&quot;</string>);
    block(C);
    emit_loop(C, start);

    C-&gt;loop = loop.next;

    patch_jump(C, jump);
    patch_jump_list(C);

    consume(C, TOKEN_RIGHT_CURLY, <string>&quot;expected '}' at end of while loop&quot;</string>);
}

<keyword>static</keyword> <constant>void</constant> <keyword>return</keyword>_statement(Compiler <keyword>*</keyword>C) {
    <keyword>if</keyword> (C-&gt;scope-&gt;type <keyword>!=</keyword> TYPE_FUNCTION) {
        compile_error(C, <keyword>&</keyword>C-&gt;previous, <string>&quot;return statement outside of function&quot;</string>);
    }
    <keyword>if</keyword> (check(C, TOKEN_RIGHT_CURLY)) {
        emit(C, OP_VOID);
    } <keyword>else</keyword> {
        expression(C);
        emit(C, OP_RETURN);
    }
}

<keyword>static</keyword> <constant>void</constant> pop_stack_loop(Compiler <keyword>*</keyword>C) {
    <constant>int</constant> depth <keyword>=</keyword> C-&gt;loop-&gt;depth;
    Scope <keyword>*</keyword>scope <keyword>=</keyword> C-&gt;scope;
    <keyword>for</keyword> (<constant>int</constant> i <keyword>=</keyword> scope-&gt;local_count; i &gt; <constant>0</constant>; i--) {
        <keyword>if</keyword> (scope-&gt;locals[i - <constant>1</constant>].depth <keyword>&lt;</keyword> depth) {
            <keyword>return</keyword>;
        }
        emit_pop(C);
    }
}

<keyword>static</keyword> <constant>void</constant> <keyword>break</keyword>_statement(Compiler <keyword>*</keyword>C) {
    <keyword>if</keyword> (C-&gt;loop <keyword>==</keyword> <constant>NULL</constant>) {
        compile_error(C, <keyword>&</keyword>C-&gt;previous, <string>&quot;break statement outside of loop&quot;</string>);
    }
    pop_stack_loop(C);
    JumpList <keyword>*</keyword>jump_next <keyword>=</keyword> C-&gt;jump;
    JumpList <keyword>*</keyword>jump <keyword>=</keyword> hymn_malloc(sizeof(JumpList));
    jump-&gt;jump = emit_jump(C, OP_JUMP);
    jump-&gt;depth = C-&gt;loop-&gt;depth;
    jump-&gt;next = jump_next;
    C-&gt;jump = jump;
}

<keyword>static</keyword> <constant>void</constant> <keyword>continue</keyword>_statement(Compiler <keyword>*</keyword>C) {
    <keyword>if</keyword> (C-&gt;loop <keyword>==</keyword> <constant>NULL</constant>) {
        compile_error(C, <keyword>&</keyword>C-&gt;previous, <string>&quot;continue statement outside of loop&quot;</string>);
    }
    pop_stack_loop(C);
    <keyword>if</keyword> (C-&gt;loop-&gt;is_<keyword>for</keyword>) {
        JumpList <keyword>*</keyword>jump_next <keyword>=</keyword> C-&gt;jump_<keyword>for</keyword>;
        JumpList <keyword>*</keyword>jump <keyword>=</keyword> hymn_malloc(sizeof(JumpList));
        jump-&gt;jump = emit_jump(C, OP_JUMP);
        jump-&gt;depth = C-&gt;loop-&gt;depth;
        jump-&gt;next = jump_next;
        C-&gt;jump_<keyword>for</keyword> <keyword>=</keyword> jump;
    } <keyword>else</keyword> {
        emit_loop(C, C-&gt;loop-&gt;start);
    }
}

<keyword>static</keyword> <constant>void</constant> try_statement(Compiler <keyword>*</keyword>C) {
    HymnByteCode <keyword>*</keyword>code <keyword>=</keyword> current(C);

    HymnExceptList <keyword>*</keyword>except <keyword>=</keyword> hymn_calloc(<constant>1</constant>, sizeof(HymnExceptList));
    except-&gt;locals = C-&gt;scope-&gt;local_count;
    except-&gt;start = code-&gt;count;

    HymnFunction <keyword>*</keyword>func <keyword>=</keyword> C-&gt;scope-&gt;func;
    except-&gt;next = func-&gt;except;
    func-&gt;except = except;

    consume(C, TOKEN_LEFT_CURLY, <string>&quot;expected '{' after try declaration&quot;</string>);
    begin_scope(C);
    <keyword>while</keyword> (<keyword>!</keyword>check(C, TOKEN_RIGHT_CURLY) <keyword>&</keyword><keyword>&</keyword> <keyword>!</keyword>check(C, TOKEN_EOF)) {
        declaration(C);
    }
    end_scope(C);

    <constant>int</constant> jump <keyword>=</keyword> emit_jump(C, OP_JUMP);

    consume(C, TOKEN_RIGHT_CURLY, <string>&quot;expected '}' at end of try statement&quot;</string>);
    consume(C, TOKEN_EXCEPT, <string>&quot;expected 'except' at end of try statement&quot;</string>);

    except-&gt;end = code-&gt;count;

    begin_scope(C);
    <constant>uint8_t</constant> message <keyword>=</keyword> variable(C, <string>&quot;expected variable name in exception declaration&quot;</string>);
    finalize_variable(C, message);
    consume(C, TOKEN_LEFT_CURLY, <string>&quot;expected '{' after exception declaration&quot;</string>);
    <keyword>while</keyword> (<keyword>!</keyword>check(C, TOKEN_RIGHT_CURLY) <keyword>&</keyword><keyword>&</keyword> <keyword>!</keyword>check(C, TOKEN_EOF)) {
        declaration(C);
    }
    end_scope(C);

    consume(C, TOKEN_RIGHT_CURLY, <string>&quot;expected '}' at end of exception statement&quot;</string>);

    patch_jump(C, jump);
}

<keyword>static</keyword> <constant>void</constant> echo_statement(Compiler <keyword>*</keyword>C) {
    expression(C);
    emit(C, OP_ECHO);
}

<keyword>static</keyword> <constant>void</constant> print_statement(Compiler <keyword>*</keyword>C) {
    consume(C, TOKEN_LEFT_PAREN, <string>&quot;expected opening '(' in call to 'print'&quot;</string>);
    expression(C);
    consume(C, TOKEN_COMMA, <string>&quot;not enough arguments in call to 'print' (expected 2)&quot;</string>);
    expression(C);
    consume(C, TOKEN_RIGHT_PAREN, <string>&quot;expected closing ')' in call to 'print'&quot;</string>);
    emit(C, OP_PRINT);
}

<keyword>static</keyword> <constant>void</constant> push_statement(Compiler <keyword>*</keyword>C) {
    consume(C, TOKEN_LEFT_PAREN, <string>&quot;expected opening '(' in call to 'push'&quot;</string>);
    expression(C);
    consume(C, TOKEN_COMMA, <string>&quot;not enough arguments in call to 'push' (expected 2)&quot;</string>);
    expression(C);
    consume(C, TOKEN_RIGHT_PAREN, <string>&quot;expected closing ')' in call to 'push'&quot;</string>);
    emit(C, OP_ARRAY_PUSH);
}

<keyword>static</keyword> <constant>void</constant> insert_statement(Compiler <keyword>*</keyword>C) {
    consume(C, TOKEN_LEFT_PAREN, <string>&quot;expected opening '(' in call to 'insert'&quot;</string>);
    expression(C);
    consume(C, TOKEN_COMMA, <string>&quot;not enough arguments in call to 'insert' (expected 3)&quot;</string>);
    expression(C);
    consume(C, TOKEN_COMMA, <string>&quot;not enough arguments in call to 'insert' (expected 3)&quot;</string>);
    expression(C);
    consume(C, TOKEN_RIGHT_PAREN, <string>&quot;expected closing ')' in call to 'insert'&quot;</string>);
    emit(C, OP_INSERT);
}

<keyword>static</keyword> <constant>void</constant> use_statement(Compiler <keyword>*</keyword>C) {
    expression(C);
    emit(C, OP_USE);
}

<keyword>static</keyword> <constant>void</constant> throw_statement(Compiler <keyword>*</keyword>C) {
    expression(C);
    emit(C, OP_THROW);
}

<keyword>static</keyword> <constant>void</constant> statement(Compiler <keyword>*</keyword>C) {
    <keyword>if</keyword> (match(C, TOKEN_ECHO)) {
        echo_statement(C);
    } <keyword>else</keyword> <keyword>if</keyword> (match(C, TOKEN_PRINT)) {
        print_statement(C);
    } <keyword>else</keyword> <keyword>if</keyword> (match(C, TOKEN_PUSH)) {
        push_statement(C);
    } <keyword>else</keyword> <keyword>if</keyword> (match(C, TOKEN_INSERT)) {
        insert_statement(C);
    } <keyword>else</keyword> <keyword>if</keyword> (match(C, TOKEN_USE)) {
        use_statement(C);
    } <keyword>else</keyword> <keyword>if</keyword> (match(C, TOKEN_IF)) {
        <keyword>if</keyword>_statement(C);
    } <keyword>else</keyword> <keyword>if</keyword> (match(C, TOKEN_FOR)) {
        <keyword>for</keyword>_statement(C);
    } <keyword>else</keyword> <keyword>if</keyword> (match(C, TOKEN_WHILE)) {
        <keyword>while</keyword>_statement(C);
    } <keyword>else</keyword> <keyword>if</keyword> (match(C, TOKEN_RETURN)) {
        <keyword>return</keyword>_statement(C);
    } <keyword>else</keyword> <keyword>if</keyword> (match(C, TOKEN_BREAK)) {
        <keyword>break</keyword>_statement(C);
    } <keyword>else</keyword> <keyword>if</keyword> (match(C, TOKEN_CONTINUE)) {
        <keyword>continue</keyword>_statement(C);
    } <keyword>else</keyword> <keyword>if</keyword> (match(C, TOKEN_TRY)) {
        try_statement(C);
    } <keyword>else</keyword> <keyword>if</keyword> (match(C, TOKEN_THROW)) {
        throw_statement(C);
    } <keyword>else</keyword> <keyword>if</keyword> (match(C, TOKEN_LEFT_CURLY)) {
        block(C);
        consume(C, TOKEN_RIGHT_CURLY, <string>&quot;expected '}' at end of block statement&quot;</string>);
    } <keyword>else</keyword> {
        expression_statement(C);
    }
}

<keyword>static</keyword> <constant>void</constant> array_pop_expression(Compiler <keyword>*</keyword>C, <constant>bool</constant> assign) {
    (<constant>void</constant>)assign;
    consume(C, TOKEN_LEFT_PAREN, <string>&quot;expected opening '(' in call to 'pop'&quot;</string>);
    expression(C);
    consume(C, TOKEN_RIGHT_PAREN, <string>&quot;expected closing ')' in call to 'pop'&quot;</string>);
    emit(C, OP_ARRAY_POP);
}

<keyword>static</keyword> <constant>void</constant> delete_expression(Compiler <keyword>*</keyword>C, <constant>bool</constant> assign) {
    (<constant>void</constant>)assign;
    consume(C, TOKEN_LEFT_PAREN, <string>&quot;expected opening '(' in call to 'delete'&quot;</string>);
    expression(C);
    consume(C, TOKEN_COMMA, <string>&quot;not enough arguments in call to 'delete' (expected 2)&quot;</string>);
    expression(C);
    consume(C, TOKEN_RIGHT_PAREN, <string>&quot;expected closing ')' in call to 'delete'&quot;</string>);
    emit(C, OP_DELETE);
}

<keyword>static</keyword> <constant>void</constant> len_expression(Compiler <keyword>*</keyword>C, <constant>bool</constant> assign) {
    (<constant>void</constant>)assign;
    consume(C, TOKEN_LEFT_PAREN, <string>&quot;expected opening '(' in call to 'len'&quot;</string>);
    expression(C);
    consume(C, TOKEN_RIGHT_PAREN, <string>&quot;expected closing ')' in call to 'len'&quot;</string>);
    emit(C, OP_LEN);
}

<keyword>static</keyword> <constant>void</constant> cast_integer_expression(Compiler <keyword>*</keyword>C, <constant>bool</constant> assign) {
    (<constant>void</constant>)assign;
    consume(C, TOKEN_LEFT_PAREN, <string>&quot;expected opening '(' in call to 'int'&quot;</string>);
    expression(C);
    consume(C, TOKEN_RIGHT_PAREN, <string>&quot;expected closing ')' in call to 'int'&quot;</string>);
    emit(C, OP_INT);
}

<keyword>static</keyword> <constant>void</constant> cast_<constant>float</constant>_expression(Compiler <keyword>*</keyword>C, <constant>bool</constant> assign) {
    (<constant>void</constant>)assign;
    consume(C, TOKEN_LEFT_PAREN, <string>&quot;expected opening '(' in call to 'float'&quot;</string>);
    expression(C);
    consume(C, TOKEN_RIGHT_PAREN, <string>&quot;expected closing ')' in call to 'float'&quot;</string>);
    emit(C, OP_FLOAT);
}

<keyword>static</keyword> <constant>void</constant> cast_string_expression(Compiler <keyword>*</keyword>C, <constant>bool</constant> assign) {
    (<constant>void</constant>)assign;
    consume(C, TOKEN_LEFT_PAREN, <string>&quot;expected opening '(' in call to 'str'&quot;</string>);
    expression(C);
    consume(C, TOKEN_RIGHT_PAREN, <string>&quot;expected closing ')' in call to 'str'&quot;</string>);
    emit(C, OP_STRING);
}

<keyword>static</keyword> <constant>void</constant> type_expression(Compiler <keyword>*</keyword>C, <constant>bool</constant> assign) {
    (<constant>void</constant>)assign;
    consume(C, TOKEN_LEFT_PAREN, <string>&quot;expected opening '(' in call to 'type'&quot;</string>);
    expression(C);
    consume(C, TOKEN_RIGHT_PAREN, <string>&quot;expected closing ')' in call to 'type'&quot;</string>);
    emit(C, OP_TYPE);
}

<keyword>static</keyword> <constant>void</constant> clear_expression(Compiler <keyword>*</keyword>C, <constant>bool</constant> assign) {
    (<constant>void</constant>)assign;
    consume(C, TOKEN_LEFT_PAREN, <string>&quot;expected opening '(' in call to 'clear'&quot;</string>);
    expression(C);
    consume(C, TOKEN_RIGHT_PAREN, <string>&quot;expected closing ')' in call to 'clear'&quot;</string>);
    emit(C, OP_CLEAR);
}

<keyword>static</keyword> <constant>void</constant> copy_expression(Compiler <keyword>*</keyword>C, <constant>bool</constant> assign) {
    (<constant>void</constant>)assign;
    consume(C, TOKEN_LEFT_PAREN, <string>&quot;expected opening '(' in call to 'copy'&quot;</string>);
    expression(C);
    consume(C, TOKEN_RIGHT_PAREN, <string>&quot;expected closing ')' in call to 'copy'&quot;</string>);
    emit(C, OP_COPY);
}

<keyword>static</keyword> <constant>void</constant> keys_expression(Compiler <keyword>*</keyword>C, <constant>bool</constant> assign) {
    (<constant>void</constant>)assign;
    consume(C, TOKEN_LEFT_PAREN, <string>&quot;expected opening '(' in call to 'keys'&quot;</string>);
    expression(C);
    consume(C, TOKEN_RIGHT_PAREN, <string>&quot;expected closing ')' in call to 'keys'&quot;</string>);
    emit(C, OP_KEYS);
}

<keyword>static</keyword> <constant>void</constant> index_expression(Compiler <keyword>*</keyword>C, <constant>bool</constant> assign) {
    (<constant>void</constant>)assign;
    consume(C, TOKEN_LEFT_PAREN, <string>&quot;expected opening '(' in call to 'index'&quot;</string>);
    expression(C);
    consume(C, TOKEN_COMMA, <string>&quot;not enough arguments in call to 'index' (expected 2)&quot;</string>);
    expression(C);
    consume(C, TOKEN_RIGHT_PAREN, <string>&quot;expected closing ')' in call to 'index'&quot;</string>);
    emit(C, OP_INDEX);
}

<keyword>static</keyword> <constant>void</constant> exists_expression(Compiler <keyword>*</keyword>C, <constant>bool</constant> assign) {
    (<constant>void</constant>)assign;
    consume(C, TOKEN_LEFT_PAREN, <string>&quot;expected opening '(' in call to 'exists'&quot;</string>);
    expression(C);
    consume(C, TOKEN_COMMA, <string>&quot;not enough arguments in call to 'exists' (expected 2)&quot;</string>);
    expression(C);
    consume(C, TOKEN_RIGHT_PAREN, <string>&quot;expected closing ')' in call to 'exists'&quot;</string>);
    emit(C, OP_EXISTS);
}

<keyword>static</keyword> <constant>void</constant> inspect_expression(Compiler <keyword>*</keyword>C, <constant>bool</constant> assign) {
    (<constant>void</constant>)assign;
    consume(C, TOKEN_LEFT_PAREN, <string>&quot;expected opening '(' in call to 'inspect'&quot;</string>);
    expression(C);
    consume(C, TOKEN_RIGHT_PAREN, <string>&quot;expected closing ')' in call to 'inspect'&quot;</string>);
    emit(C, OP_INSPECT);
}

<keyword>static</keyword> <constant>void</constant> debug_expression(Compiler <keyword>*</keyword>C, <constant>bool</constant> assign) {
    (<constant>void</constant>)assign;
    consume(C, TOKEN_LEFT_PAREN, <string>&quot;expected opening '(' in call to 'debug'&quot;</string>);
    expression(C);
    consume(C, TOKEN_RIGHT_PAREN, <string>&quot;expected closing ')' in call to 'debug'&quot;</string>);
    emit(C, OP_DEBUG);
}

<keyword>static</keyword> <constant>void</constant> expression_statement(Compiler <keyword>*</keyword>C) {
    expression(C);
    emit_pop(C);
}

<keyword>static</keyword> <constant>void</constant> expression(Compiler <keyword>*</keyword>C) {
    compile_with_precedence(C, PRECEDENCE_ASSIGN);
}

<keyword>static</keyword> HymnFrame <keyword>*</keyword>parent_frame(Hymn <keyword>*</keyword>H, <constant>int</constant> offset) {
    <constant>int</constant> frame_count <keyword>=</keyword> H-&gt;frame_count;
    <keyword>if</keyword> (offset <keyword>&gt;</keyword> frame_count) <keyword>return</keyword> <constant>NULL</constant>;
    <keyword>return</keyword> <keyword>&</keyword>H-&gt;frames[frame_count - offset];
}

<keyword>static</keyword> HymnFrame <keyword>*</keyword>current_frame(Hymn <keyword>*</keyword>H) {
    <keyword>return</keyword> <keyword>&</keyword>H-&gt;frames[H-&gt;frame_count - <constant>1</constant>];
}

<keyword>static</keyword> CompileResult compile(Hymn <keyword>*</keyword>H, <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>script, <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>source, <keyword>enum</keyword> FunctionType type) {
    Scope scope <keyword>=</keyword> {<constant>0</constant>};
    Compiler C <keyword>=</keyword> {<constant>0</constant>};
    C.row <keyword>=</keyword> <constant>1</constant>;
    C.column <keyword>=</keyword> <constant>1</constant>;
    C.script <keyword>=</keyword> script;
    C.source <keyword>=</keyword> source;
    C.interactive <keyword>=</keyword> type <keyword>==</keyword> TYPE_REPL;
    C.size <keyword>=</keyword> strlen(source);
    C.previous.type <keyword>=</keyword> TOKEN_UNDEFINED;
    C.current.type <keyword>=</keyword> TOKEN_UNDEFINED;
    C.string_status <keyword>=</keyword> STRING_STATUS_NONE;
    C.H <keyword>=</keyword> H;
    C.pop <keyword>=</keyword> <keyword>-</keyword><constant>1</constant>;
    C.barrier <keyword>=</keyword> <keyword>-</keyword><constant>1</constant>;
    scope_init(<keyword>&</keyword>C, <keyword>&</keyword>scope, type, <constant>0</constant>);

    advance(<keyword>&</keyword>C);
    <keyword>while</keyword> (<keyword>!</keyword>match(<keyword>&</keyword>C, TOKEN_EOF)) {
        declaration(<keyword>&</keyword>C);
    }

    HymnFunction <keyword>*</keyword>func <keyword>=</keyword> end_function(<keyword>&</keyword>C);

    <keyword>if</keyword> (C.error <keyword>!=</keyword> <constant>NULL</constant>) {
        <constant>char</constant> <keyword>*</keyword>error <keyword>=</keyword> string_to_chars(C.error);
        hymn_string_delete(C.error);

        HymnValuePool <keyword>*</keyword>constants <keyword>=</keyword> <keyword>&</keyword>func-&gt;code.constants;
        <constant>int</constant> count <keyword>=</keyword> constants-&gt;count;
        HymnValue <keyword>*</keyword>values <keyword>=</keyword> constants-&gt;values;

        <keyword>for</keyword> (<constant>int</constant> i <keyword>=</keyword> <constant>0</constant>; i <keyword>&lt;</keyword> count; i++) {
            HymnValue value <keyword>=</keyword> values[i];
            <keyword>if</keyword> (hymn_is_func(value)) {
                function_delete(hymn_as_func(value));
            }
        }

        function_delete(func);
        <keyword>return</keyword> (CompileResult){.func <keyword>=</keyword> <constant>NULL</constant>, .error <keyword>=</keyword> error};
    }

    <keyword>return</keyword> (CompileResult){.func <keyword>=</keyword> func, .error <keyword>=</keyword> <constant>NULL</constant>};
}

HymnString <keyword>*</keyword>hymn_quote_string(HymnString <keyword>*</keyword>string) {
    <constant>size_t</constant> len <keyword>=</keyword> hymn_string_len(string);
    <constant>size_t</constant> extra <keyword>=</keyword> <constant>2</constant>;
    <keyword>for</keyword> (<constant>size_t</constant> s <keyword>=</keyword> <constant>0</constant>; s <keyword>&lt;</keyword> len; s++) {
        <constant>char</constant> c <keyword>=</keyword> string[s];
        <keyword>if</keyword> (c <keyword>==</keyword> <string>'\\'</string> || c <keyword>==</keyword> <string>'\&quot;'</string>) {
            extra++;
        }
    }
    HymnString <keyword>*</keyword>quoted <keyword>=</keyword> hymn_new_string_with_capacity(len <keyword>+</keyword> extra);
    quoted[<constant>0</constant>] <keyword>=</keyword> <string>'&quot;'</string>;
    <constant>size_t</constant> q <keyword>=</keyword> <constant>1</constant>;
    <keyword>for</keyword> (<constant>size_t</constant> s <keyword>=</keyword> <constant>0</constant>; s <keyword>&lt;</keyword> len; s++) {
        <constant>char</constant> c <keyword>=</keyword> string[s];
        <keyword>if</keyword> (c <keyword>==</keyword> <string>'\\'</string>) {
            quoted[q++] = <string>'\\'</string>;
            quoted[q++] = <string>'\\'</string>;
        } <keyword>else</keyword> <keyword>if</keyword> (c <keyword>==</keyword> <string>'&quot;'</string>) {
            quoted[q++] = <string>'\\'</string>;
            quoted[q++] = <string>'&quot;'</string>;
        } <keyword>else</keyword> {
            quoted[q++] = c;
        }
    }
    HymnStringHead <keyword>*</keyword>head <keyword>=</keyword> hymn_string_head(quoted);
    head-&gt;length = head-&gt;capacity;
    quoted[len <keyword>+</keyword> extra <keyword>-</keyword> <constant>1</constant>] <keyword>=</keyword> <string>'&quot;'</string>;
    quoted[len <keyword>+</keyword> extra] <keyword>=</keyword> <string>'\0'</string>;
    <keyword>return</keyword> quoted;
}

<keyword>struct</keyword> PointerSet {
    <constant>int</constant> count;
    <constant>int</constant> capacity;
    <constant>void</constant> <keyword>*</keyword><keyword>*</keyword>items;
};

<keyword>static</keyword> <constant>bool</constant> pointer_set_has(<keyword>struct</keyword> PointerSet <keyword>*</keyword>set, <constant>void</constant> <keyword>*</keyword>pointer) {
    <constant>void</constant> <keyword>*</keyword><keyword>*</keyword>items <keyword>=</keyword> set-&gt;items;
    <keyword>if</keyword> (items) {
        <constant>int</constant> count <keyword>=</keyword> set-&gt;count;
        <keyword>for</keyword> (<constant>int</constant> i <keyword>=</keyword> <constant>0</constant>; i <keyword>&lt;</keyword> count; i++) {
            <keyword>if</keyword> (pointer <keyword>==</keyword> items[i]) {
                <keyword>return</keyword> <constant>true</constant>;
            }
        }
    }
    <keyword>return</keyword> <constant>false</constant>;
}

<keyword>static</keyword> <constant>void</constant> pointer_set_add(<keyword>struct</keyword> PointerSet <keyword>*</keyword>set, <constant>void</constant> <keyword>*</keyword>pointer) {
    <keyword>if</keyword> (set-&gt;items) {
        <constant>int</constant> count <keyword>=</keyword> set-&gt;count;
        <keyword>if</keyword> (count <keyword>&gt;</keyword><keyword>=</keyword> set-&gt;capacity) {
            set-&gt;capacity *= <constant>2</constant>;
            set-&gt;items = hymn_realloc_<constant>int</constant>(set-&gt;items, set-&gt;capacity, sizeof(<constant>void</constant> <keyword>*</keyword>));
        }
        set-&gt;items[count] = pointer;
        set-&gt;count = count + <constant>1</constant>;
    } <keyword>else</keyword> {
        set-&gt;count = <constant>1</constant>;
        set-&gt;capacity = <constant>1</constant>;
        set-&gt;items = hymn_calloc(<constant>1</constant>, sizeof(<constant>void</constant> <keyword>*</keyword>));
        set-&gt;items[<constant>0</constant>] <keyword>=</keyword> pointer;
    }
}

<keyword>static</keyword> HymnString <keyword>*</keyword>value_to_string_recusive(HymnValue value, <keyword>struct</keyword> PointerSet <keyword>*</keyword>set, <constant>bool</constant> quote) {
    <keyword>switch</keyword> (value.is) {
    <keyword>case</keyword> HYMN_VALUE_UNDEFINED: <keyword>return</keyword> hymn_new_string(<string>&quot;undefined&quot;</string>);
    <keyword>case</keyword> HYMN_VALUE_NONE: <keyword>return</keyword> hymn_new_string(<string>&quot;none&quot;</string>);
    <keyword>case</keyword> HYMN_VALUE_BOOL: <keyword>return</keyword> hymn_as_<constant>bool</constant>(value) ? hymn_new_string(<string>&quot;true&quot;</string>) : hymn_new_string(<string>&quot;false&quot;</string>);
    <keyword>case</keyword> HYMN_VALUE_INTEGER: <keyword>return</keyword> hymn_<constant>int</constant>_to_string(hymn_as_<constant>int</constant>(value));
    <keyword>case</keyword> HYMN_VALUE_FLOAT: <keyword>return</keyword> hymn_<constant>float</constant>_to_string(hymn_as_<constant>float</constant>(value));
    <keyword>case</keyword> HYMN_VALUE_STRING: {
        <keyword>if</keyword> (quote) <keyword>return</keyword> hymn_quote_string(hymn_as_string(value));
        <keyword>return</keyword> hymn_string_copy(hymn_as_string(value));
    }
    <keyword>case</keyword> HYMN_VALUE_ARRAY: {
        HymnArray <keyword>*</keyword>array <keyword>=</keyword> hymn_as_array(value);
        <keyword>if</keyword> (array <keyword>==</keyword> <constant>NULL</constant> || array-&gt;length <keyword>==</keyword> <constant>0</constant>) {
            <keyword>return</keyword> hymn_new_string(<string>&quot;[]&quot;</string>);
        }
        <keyword>if</keyword> (pointer_set_has(set, array)) {
            <keyword>return</keyword> hymn_new_string(<string>&quot;[..]&quot;</string>);
        } <keyword>else</keyword> {
            pointer_set_add(set, array);
        }
        HymnString <keyword>*</keyword>string <keyword>=</keyword> hymn_new_string(<string>&quot;[&quot;</string>);
        <keyword>for</keyword> (HymnInt i <keyword>=</keyword> <constant>0</constant>; i <keyword>&lt;</keyword> array-&gt;length; i++) {
            <keyword>if</keyword> (i <keyword>!=</keyword> <constant>0</constant>) {
                string <keyword>=</keyword> hymn_string_append(string, <string>&quot;, &quot;</string>);
            }
            HymnString <keyword>*</keyword>add <keyword>=</keyword> value_to_string_recusive(array-&gt;items[i], set, <constant>true</constant>);
            string <keyword>=</keyword> hymn_string_append(string, add);
            hymn_string_delete(add);
        }
        string <keyword>=</keyword> hymn_string_append_<constant>char</constant>(string, <string>']'</string>);
        <keyword>return</keyword> string;
    }
    <keyword>case</keyword> HYMN_VALUE_TABLE: {
        HymnTable <keyword>*</keyword>table <keyword>=</keyword> hymn_as_table(value);
        <keyword>if</keyword> (table <keyword>==</keyword> <constant>NULL</constant> || table-&gt;size <keyword>==</keyword> <constant>0</constant>) {
            <keyword>return</keyword> hymn_new_string(<string>&quot;{}&quot;</string>);
        } <keyword>else</keyword> <keyword>if</keyword> (pointer_set_has(set, table)) {
            <keyword>return</keyword> hymn_new_string(<string>&quot;{ .. }&quot;</string>);
        } <keyword>else</keyword> {
            pointer_set_add(set, table);
        }
        <constant>int</constant> size <keyword>=</keyword> table-&gt;size;
        HymnObjectString <keyword>*</keyword><keyword>*</keyword>keys <keyword>=</keyword> hymn_malloc_<constant>int</constant>(size, sizeof(HymnObjectString <keyword>*</keyword>));
        <keyword>unsigned</keyword> <constant>int</constant> total <keyword>=</keyword> <constant>0</constant>;
        <keyword>unsigned</keyword> <constant>int</constant> bins <keyword>=</keyword> table-&gt;bins;
        <keyword>for</keyword> (<keyword>unsigned</keyword> <constant>int</constant> i <keyword>=</keyword> <constant>0</constant>; i <keyword>&lt;</keyword> bins; i++) {
            HymnTableItem <keyword>*</keyword>item <keyword>=</keyword> table-&gt;items[i];
            <keyword>while</keyword> (item <keyword>!=</keyword> <constant>NULL</constant>) {
                HymnString <keyword>*</keyword>string <keyword>=</keyword> item-&gt;key-&gt;string;
                <keyword>unsigned</keyword> <constant>int</constant> insert <keyword>=</keyword> <constant>0</constant>;
                <keyword>while</keyword> (insert <keyword>!=</keyword> total) {
                    <keyword>if</keyword> (strcmp(string, keys[insert]<keyword>-&gt;</keyword>string) <keyword>&lt;</keyword> <constant>0</constant>) {
                        <keyword>for</keyword> (<keyword>unsigned</keyword> <constant>int</constant> swap <keyword>=</keyword> total; swap <keyword>&gt;</keyword> insert; swap--) {
                            keys[swap] <keyword>=</keyword> keys[swap <keyword>-</keyword> <constant>1</constant>];
                        }
                        <keyword>break</keyword>;
                    }
                    insert++;
                }
                keys[insert] <keyword>=</keyword> item-&gt;key;
                total++;
                item <keyword>=</keyword> item-&gt;next;
            }
        }
        HymnString <keyword>*</keyword>string <keyword>=</keyword> hymn_new_string(<string>&quot;{ &quot;</string>);
        <keyword>for</keyword> (<constant>int</constant> i <keyword>=</keyword> <constant>0</constant>; i <keyword>&lt;</keyword> size; i++) {
            <keyword>if</keyword> (i <keyword>!=</keyword> <constant>0</constant>) {
                string <keyword>=</keyword> hymn_string_append(string, <string>&quot;, &quot;</string>);
            }
            HymnObjectString <keyword>*</keyword>key <keyword>=</keyword> keys[i];
            HymnValue item <keyword>=</keyword> table_get(table, key);
            HymnString <keyword>*</keyword>add <keyword>=</keyword> value_to_string_recusive(item, set, <constant>true</constant>);
            HymnString <keyword>*</keyword>quoting <keyword>=</keyword> hymn_quote_string(key-&gt;string);
            string <keyword>=</keyword> hymn_string_append(string, quoting);
            string <keyword>=</keyword> hymn_string_append(string, <string>&quot;: &quot;</string>);
            string <keyword>=</keyword> hymn_string_append(string, add);
            hymn_string_delete(quoting);
            hymn_string_delete(add);
        }
        string <keyword>=</keyword> hymn_string_append(string, <string>&quot; }&quot;</string>);
        <constant>free</constant>(keys);
        <keyword>return</keyword> string;
    }
    <keyword>case</keyword> HYMN_VALUE_FUNC: {
        HymnFunction <keyword>*</keyword>func <keyword>=</keyword> hymn_as_func(value);
        <keyword>if</keyword> (func-&gt;name) <keyword>return</keyword> hymn_string_copy(func-&gt;name);
        <keyword>if</keyword> (func-&gt;script) <keyword>return</keyword> hymn_string_copy(func-&gt;script);
        <keyword>return</keyword> hymn_new_string(<string>&quot;script&quot;</string>);
    }
    <keyword>case</keyword> HYMN_VALUE_FUNC_NATIVE: <keyword>return</keyword> hymn_string_copy(hymn_as_native(value)<keyword>-&gt;</keyword>name-&gt;string);
    <keyword>case</keyword> HYMN_VALUE_POINTER: <keyword>return</keyword> hymn_string_format(<string>&quot;%p&quot;</string>, hymn_as_pointer(value));
    <keyword>default</keyword>:
        <keyword>break</keyword>;
    }
    <keyword>return</keyword> hymn_new_string(<string>&quot;?&quot;</string>);
}

HymnString <keyword>*</keyword>hymn_value_to_string(HymnValue value) {
    <keyword>struct</keyword> PointerSet set <keyword>=</keyword> {.count <keyword>=</keyword> <constant>0</constant>, .capacity <keyword>=</keyword> <constant>0</constant>, .items <keyword>=</keyword> <constant>NULL</constant>};
    HymnString <keyword>*</keyword>string <keyword>=</keyword> value_to_string_recusive(value, <keyword>&</keyword>set, <constant>false</constant>);
    <constant>free</constant>(set.items);
    <keyword>return</keyword> string;
}

<keyword>static</keyword> HymnString <keyword>*</keyword>value_concat(HymnValue a, HymnValue b) {
    HymnString <keyword>*</keyword>string <keyword>=</keyword> hymn_value_to_string(a);
    HymnString <keyword>*</keyword>second <keyword>=</keyword> hymn_value_to_string(b);
    string <keyword>=</keyword> hymn_string_append(string, second);
    hymn_string_delete(second);
    <keyword>return</keyword> string;
}

<keyword>static</keyword> HymnString <keyword>*</keyword>debug_value_to_string(HymnValue value) {
    HymnString <keyword>*</keyword>string <keyword>=</keyword> hymn_value_to_string(value);
    HymnString <keyword>*</keyword>format <keyword>=</keyword> hymn_string_format(<string>&quot;%s: %s&quot;</string>, hymn_value_type(value.is), string);
    hymn_string_delete(string);
    <keyword>return</keyword> format;
}

<keyword>static</keyword> <constant>void</constant> reset_stack(Hymn <keyword>*</keyword>H) {
    H-&gt;stack_top = H-&gt;stack;
    H-&gt;frame_count = <constant>0</constant>;
}

<constant>#ifdef</constant> HYMN_DEBUG_MEMORY
<keyword>static</keyword> <constant>void</constant> debug_value(HymnValue value) {
    HymnString <keyword>*</keyword>string <keyword>=</keyword> debug_value_to_string(value);
    <constant>printf</constant>(<string>&quot;%s&quot;</string>, string);
    hymn_string_delete(string);
}

<keyword>static</keyword> <constant>void</constant> debug_reference(HymnValue value) {
    <constant>int</constant> count;
    <keyword>switch</keyword> (value.is) {
    <keyword>case</keyword> HYMN_VALUE_STRING:
        count <keyword>=</keyword> hymn_as_hymn_string(value)<keyword>-&gt;</keyword>count;
        <keyword>break</keyword>;
    <keyword>case</keyword> HYMN_VALUE_ARRAY:
        count <keyword>=</keyword> hymn_as_array(value)<keyword>-&gt;</keyword>count;
        <keyword>break</keyword>;
    <keyword>case</keyword> HYMN_VALUE_TABLE:
        count <keyword>=</keyword> hymn_as_table(value)<keyword>-&gt;</keyword>count;
        <keyword>break</keyword>;
    <keyword>case</keyword> HYMN_VALUE_FUNC:
        count <keyword>=</keyword> hymn_as_func(value)<keyword>-&gt;</keyword>count;
        <keyword>break</keyword>;
    <keyword>case</keyword> HYMN_VALUE_FUNC_NATIVE:
        count <keyword>=</keyword> hymn_as_native(value)<keyword>-&gt;</keyword>count;
        <keyword>break</keyword>;
    <keyword>default</keyword>:
        <keyword>return</keyword>;
    }
    <constant>printf</constant>(<string>&quot;REF     | [%p] [&quot;</string>, (<constant>void</constant> <keyword>*</keyword>)value.as.o);
    debug_value(value);
    <constant>printf</constant>(<string>&quot;] [%d]\n&quot;</string>, count);
    assert(count <keyword>&gt;</keyword><keyword>=</keyword> <constant>0</constant>);
}

<keyword>static</keyword> <constant>void</constant> debug_dereference(HymnValue value) {
    <constant>int</constant> count;
    <keyword>switch</keyword> (value.is) {
    <keyword>case</keyword> HYMN_VALUE_STRING:
        count <keyword>=</keyword> hymn_as_hymn_string(value)<keyword>-&gt;</keyword>count;
        <keyword>break</keyword>;
    <keyword>case</keyword> HYMN_VALUE_ARRAY:
        count <keyword>=</keyword> hymn_as_array(value)<keyword>-&gt;</keyword>count;
        <keyword>break</keyword>;
    <keyword>case</keyword> HYMN_VALUE_TABLE:
        count <keyword>=</keyword> hymn_as_table(value)<keyword>-&gt;</keyword>count;
        <keyword>break</keyword>;
    <keyword>case</keyword> HYMN_VALUE_FUNC:
        count <keyword>=</keyword> hymn_as_func(value)<keyword>-&gt;</keyword>count;
        <keyword>break</keyword>;
    <keyword>case</keyword> HYMN_VALUE_FUNC_NATIVE:
        count <keyword>=</keyword> hymn_as_native(value)<keyword>-&gt;</keyword>count;
        <keyword>break</keyword>;
    <keyword>default</keyword>:
        <keyword>return</keyword>;
    }
    count--;
    <keyword>if</keyword> (count <keyword>==</keyword> <constant>0</constant>) {
        <constant>printf</constant>(<string>&quot;FREE    | [%p] [&quot;</string>, (<constant>void</constant> <keyword>*</keyword>)object);
        debug_value(value);
        <constant>printf</constant>(<string>&quot;]\n&quot;</string>);
    } <keyword>else</keyword> <keyword>if</keyword> (count <keyword>&lt;</keyword> <constant>0</constant>) {
        <constant>printf</constant>(<string>&quot;BAD     | [%p] [&quot;</string>, (<constant>void</constant> <keyword>*</keyword>)object);
        debug_value(value);
        <constant>printf</constant>(<string>&quot;]\n&quot;</string>);
    } <keyword>else</keyword> {
        <constant>printf</constant>(<string>&quot;DEREF   | [%p] [&quot;</string>, (<constant>void</constant> <keyword>*</keyword>)object);
        debug_value(value);
        <constant>printf</constant>(<string>&quot;] [%d]\n&quot;</string>, count);
    }
    assert(count <keyword>&gt;</keyword><keyword>=</keyword> <constant>0</constant>);
}
<constant>#endif</constant>

<constant>#ifdef</constant> HYMN_NO_MEMORY_MANAGE
<constant>void</constant> hymn_reference_string(HymnObjectString <keyword>*</keyword>string) {
    (<constant>void</constant>)string;
}
<constant>#else</constant>
<constant>void</constant> hymn_reference_string(HymnObjectString <keyword>*</keyword>string) {
    string-&gt;count++;
<constant>#ifdef</constant> HYMN_DEBUG_MEMORY
    debug_reference(hymn_new_string_value(string));
<constant>#endif</constant>
}
<constant>#endif</constant>

<constant>#ifdef</constant> HYMN_NO_MEMORY_MANAGE
<constant>void</constant> hymn_reference(HymnValue value) {
    (<constant>void</constant>)value;
}
<constant>#else</constant>
<constant>void</constant> hymn_reference(HymnValue value) {
    <keyword>switch</keyword> (value.is) {
    <keyword>case</keyword> HYMN_VALUE_STRING:
        ((HymnObjectString <keyword>*</keyword>)value.as.o)<keyword>-&gt;</keyword>count++;
<constant>#ifdef</constant> HYMN_DEBUG_MEMORY
        debug_reference(value);
<constant>#endif</constant>
        <keyword>return</keyword>;
    <keyword>case</keyword> HYMN_VALUE_ARRAY:
        ((HymnArray <keyword>*</keyword>)value.as.o)<keyword>-&gt;</keyword>count++;
<constant>#ifdef</constant> HYMN_DEBUG_MEMORY
        debug_reference(value);
<constant>#endif</constant>
        <keyword>return</keyword>;
    <keyword>case</keyword> HYMN_VALUE_TABLE:
        ((HymnTable <keyword>*</keyword>)value.as.o)<keyword>-&gt;</keyword>count++;
<constant>#ifdef</constant> HYMN_DEBUG_MEMORY
        debug_reference(value);
<constant>#endif</constant>
        <keyword>return</keyword>;
    <keyword>case</keyword> HYMN_VALUE_FUNC:
        ((HymnFunction <keyword>*</keyword>)value.as.o)<keyword>-&gt;</keyword>count++;
<constant>#ifdef</constant> HYMN_DEBUG_MEMORY
        debug_reference(value);
<constant>#endif</constant>
        <keyword>return</keyword>;
    <keyword>case</keyword> HYMN_VALUE_FUNC_NATIVE:
        ((HymnNativeFunction <keyword>*</keyword>)value.as.o)<keyword>-&gt;</keyword>count++;
<constant>#ifdef</constant> HYMN_DEBUG_MEMORY
        debug_reference(value);
<constant>#endif</constant>
        <keyword>return</keyword>;
    <keyword>default</keyword>:
        <keyword>return</keyword>;
    }
}
<constant>#endif</constant>

<constant>#ifdef</constant> HYMN_NO_MEMORY_MANAGE
<constant>void</constant> hymn_dereference_string(Hymn <keyword>*</keyword>H, HymnObjectString <keyword>*</keyword>string) {
    (<constant>void</constant>)H;
    (<constant>void</constant>)string;
}
<constant>#else</constant>
<constant>void</constant> hymn_dereference_string(Hymn <keyword>*</keyword>H, HymnObjectString <keyword>*</keyword>string) {
<constant>#ifdef</constant> HYMN_DEBUG_MEMORY
    debug_dereference(hymn_new_string_value(string));
<constant>#endif</constant>
    <constant>int</constant> count <keyword>=</keyword> <keyword>-</keyword><keyword>-</keyword>string-&gt;count;
    assert(count <keyword>&gt;</keyword><keyword>=</keyword> <constant>0</constant>);
    <keyword>if</keyword> (count <keyword>==</keyword> <constant>0</constant>) {
        set_remove(<keyword>&</keyword>H-&gt;strings, string-&gt;string);
        hymn_string_delete(string-&gt;string);
        <constant>free</constant>(string);
    }
}
<constant>#endif</constant>

<constant>#ifdef</constant> HYMN_NO_MEMORY_MANAGE
<constant>void</constant> hymn_dereference(Hymn <keyword>*</keyword>H, HymnValue value) {
    (<constant>void</constant>)H;
    (<constant>void</constant>)value;
}
<constant>#else</constant>
<constant>void</constant> hymn_dereference(Hymn <keyword>*</keyword>H, HymnValue value) {
    <keyword>switch</keyword> (value.is) {
    <keyword>case</keyword> HYMN_VALUE_STRING: {
        HymnObjectString <keyword>*</keyword>string <keyword>=</keyword> (HymnObjectString <keyword>*</keyword>)value.as.o;
        hymn_dereference_string(H, string);
        <keyword>return</keyword>;
    }
    <keyword>case</keyword> HYMN_VALUE_ARRAY: {
<constant>#ifdef</constant> HYMN_DEBUG_MEMORY
        debug_dereference(value);
<constant>#endif</constant>
        HymnArray <keyword>*</keyword>array <keyword>=</keyword> (HymnArray <keyword>*</keyword>)value.as.o;
        <constant>int</constant> count <keyword>=</keyword> <keyword>-</keyword><keyword>-</keyword>array-&gt;count;
        assert(count <keyword>&gt;</keyword><keyword>=</keyword> <constant>0</constant>);
        <keyword>if</keyword> (count <keyword>==</keyword> <constant>0</constant>) {
            hymn_array_delete(H, array);
        }
        <keyword>return</keyword>;
    }
    <keyword>case</keyword> HYMN_VALUE_TABLE: {
<constant>#ifdef</constant> HYMN_DEBUG_MEMORY
        debug_dereference(value);
<constant>#endif</constant>
        HymnTable <keyword>*</keyword>table <keyword>=</keyword> (HymnTable <keyword>*</keyword>)value.as.o;
        <constant>int</constant> count <keyword>=</keyword> <keyword>-</keyword><keyword>-</keyword>table-&gt;count;
        assert(count <keyword>&gt;</keyword><keyword>=</keyword> <constant>0</constant>);
        <keyword>if</keyword> (count <keyword>==</keyword> <constant>0</constant>) {
            table_delete(H, table);
        }
        <keyword>return</keyword>;
    }
    <keyword>case</keyword> HYMN_VALUE_FUNC: {
<constant>#ifdef</constant> HYMN_DEBUG_MEMORY
        debug_dereference(value);
<constant>#endif</constant>
        HymnFunction <keyword>*</keyword>func <keyword>=</keyword> (HymnFunction <keyword>*</keyword>)value.as.o;
        <constant>int</constant> count <keyword>=</keyword> <keyword>-</keyword><keyword>-</keyword>func-&gt;count;
        assert(count <keyword>&gt;</keyword><keyword>=</keyword> <constant>0</constant>);
        <keyword>if</keyword> (count <keyword>==</keyword> <constant>0</constant>) {
            function_delete(func);
        }
        <keyword>return</keyword>;
    }
    <keyword>case</keyword> HYMN_VALUE_FUNC_NATIVE: {
<constant>#ifdef</constant> HYMN_DEBUG_MEMORY
        debug_dereference(value);
<constant>#endif</constant>
        HymnNativeFunction <keyword>*</keyword>func <keyword>=</keyword> (HymnNativeFunction <keyword>*</keyword>)value.as.o;
        <constant>int</constant> count <keyword>=</keyword> <keyword>-</keyword><keyword>-</keyword>func-&gt;count;
        assert(count <keyword>&gt;</keyword><keyword>=</keyword> <constant>0</constant>);
        <keyword>if</keyword> (count <keyword>==</keyword> <constant>0</constant>) {
            native_function_delete(H, func);
        }
        <keyword>return</keyword>;
    }
    <keyword>default</keyword>:
        <keyword>return</keyword>;
    }
}
<constant>#endif</constant>

<keyword>static</keyword> <constant>void</constant> push(Hymn <keyword>*</keyword>H, HymnValue value) {
    <keyword>*</keyword>H-&gt;stack_top = value;
    H-&gt;stack_top++;
}

<keyword>static</keyword> HymnValue peek(Hymn <keyword>*</keyword>H, <constant>int</constant> dist) {
    assert(<keyword>&</keyword>H-&gt;stack_top[-dist] &gt;= H-&gt;stack);
    <keyword>return</keyword> H-&gt;stack_top[-dist];
}

<keyword>static</keyword> HymnValue pop(Hymn <keyword>*</keyword>H) {
    assert(<keyword>&</keyword>H-&gt;stack_top[-<constant>1</constant>] <keyword>&gt;</keyword><keyword>=</keyword> H-&gt;stack);
    H-&gt;stack_top--;
    <keyword>return</keyword> <keyword>*</keyword>H-&gt;stack_top;
}

<keyword>static</keyword> <constant>void</constant> push_string(Hymn <keyword>*</keyword>H, HymnString <keyword>*</keyword>string) {
    HymnObjectString <keyword>*</keyword>intern <keyword>=</keyword> hymn_intern_string(H, string);
    hymn_reference_string(intern);
    push(H, hymn_new_string_value(intern));
}

<keyword>static</keyword> HymnFrame <keyword>*</keyword>exception(Hymn <keyword>*</keyword>H) {
    HymnFrame <keyword>*</keyword>frame <keyword>=</keyword> current_frame(H);
    <keyword>while</keyword> (<constant>true</constant>) {
        HymnFunction <keyword>*</keyword>func <keyword>=</keyword> frame-&gt;func;
        <constant>uint8_t</constant> <keyword>*</keyword>instructions <keyword>=</keyword> func-&gt;code.instructions;
        HymnExceptList <keyword>*</keyword>except <keyword>=</keyword> <constant>NULL</constant>;
        HymnExceptList <keyword>*</keyword>range <keyword>=</keyword> func-&gt;except;
        <keyword>while</keyword> (range <keyword>!=</keyword> <constant>NULL</constant>) {
            <keyword>if</keyword> (frame-&gt;ip &gt;= &instructions[range-&gt;start] && frame-&gt;ip &lt;= &instructions[range-&gt;end]) {
                except <keyword>=</keyword> range;
                <keyword>break</keyword>;
            }
            range <keyword>=</keyword> range-&gt;next;
        }
        HymnValue message <keyword>=</keyword> pop(H);
        <keyword>if</keyword> (except <keyword>!=</keyword> <constant>NULL</constant>) {
            <keyword>while</keyword> (H-&gt;stack_top <keyword>!=</keyword> <keyword>&</keyword>frame-&gt;stack[except-&gt;locals]) {
                hymn_dereference(H, pop(H));
            }
            frame-&gt;ip = &instructions[except-&gt;end];
            push(H, message);
            <keyword>return</keyword> frame;
        }
        <keyword>while</keyword> (H-&gt;stack_top <keyword>!=</keyword> frame-&gt;stack) {
            hymn_dereference(H, pop(H));
        }
        H-&gt;frame_count--;
        <keyword>if</keyword> (H-&gt;frame_count <keyword>==</keyword> <constant>0</constant> || func-&gt;name <keyword>==</keyword> <constant>NULL</constant>) {
            assert(H-&gt;error <keyword>==</keyword> <constant>NULL</constant>);
            H-&gt;error = hymn_value_to_string(message);
            hymn_dereference(H, message);
            <keyword>return</keyword> <constant>NULL</constant>;
        }
        push(H, message);
        frame <keyword>=</keyword> current_frame(H);
    }
}

<keyword>static</keyword> HymnString <keyword>*</keyword>stacktrace(Hymn <keyword>*</keyword>H) {
    HymnString <keyword>*</keyword>trace <keyword>=</keyword> hymn_new_string(<string>&quot;&quot;</string>);
    <keyword>for</keyword> (<constant>int</constant> i <keyword>=</keyword> H-&gt;frame_count - <constant>1</constant>; i <keyword>&gt;</keyword><keyword>=</keyword> <constant>0</constant>; i--) {
        HymnFrame <keyword>*</keyword>frame <keyword>=</keyword> <keyword>&</keyword>H-&gt;frames[i];
        HymnFunction <keyword>*</keyword>func <keyword>=</keyword> frame-&gt;func;
        <constant>int</constant> row <keyword>=</keyword> func-&gt;code.lines[frame-&gt;ip - func-&gt;code.instructions - <constant>1</constant>];
        <keyword>if</keyword> (func-&gt;name <keyword>==</keyword> <constant>NULL</constant>) {
            <keyword>if</keyword> (func-&gt;script <keyword>==</keyword> <constant>NULL</constant>) {
                trace <keyword>=</keyword> string_append_format(trace, <string>&quot;  at script:%d&quot;</string>, row);
            } <keyword>else</keyword> {
                trace <keyword>=</keyword> string_append_format(trace, <string>&quot;  at %s:%d&quot;</string>, func-&gt;script, row);
            }
        } <keyword>else</keyword> <keyword>if</keyword> (func-&gt;script <keyword>==</keyword> <constant>NULL</constant>) {
            trace <keyword>=</keyword> string_append_format(trace, <string>&quot;  at %s script:%d&quot;</string>, func-&gt;name, row);
        } <keyword>else</keyword> {
            trace <keyword>=</keyword> string_append_format(trace, <string>&quot;  at %s %s:%d&quot;</string>, func-&gt;name, func-&gt;script, row);
        }
        <keyword>if</keyword> (i <keyword>&gt;</keyword> <constant>0</constant>) trace <keyword>=</keyword> hymn_string_append_<constant>char</constant>(trace, <string>'\n'</string>);
    }
    <keyword>return</keyword> trace;
}

<keyword>static</keyword> HymnFrame <keyword>*</keyword>push_error(Hymn <keyword>*</keyword>H, HymnString <keyword>*</keyword>error) {
    HymnObjectString <keyword>*</keyword>message <keyword>=</keyword> hymn_intern_string(H, error);
    hymn_reference_string(message);
    push(H, hymn_new_string_value(message));
    <keyword>return</keyword> exception(H);
}

<keyword>static</keyword> HymnFrame <keyword>*</keyword>throw_existing_error(Hymn <keyword>*</keyword>H, <constant>char</constant> <keyword>*</keyword>error) {
    HymnString <keyword>*</keyword>message <keyword>=</keyword> hymn_new_string(error);
    <constant>free</constant>(error);
    <keyword>return</keyword> push_error(H, message);
}

<keyword>static</keyword> HymnFrame <keyword>*</keyword>throw_error(Hymn <keyword>*</keyword>H, <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>format, ...) {
    va_list ap;
    va_start(ap, format);
    <constant>size_t</constant> len <keyword>=</keyword> (<constant>size_t</constant>)vsnprintf(<constant>NULL</constant>, <constant>0</constant>, format, ap);
    va_end(ap);
    <constant>char</constant> <keyword>*</keyword>chars <keyword>=</keyword> hymn_malloc((len <keyword>+</keyword> <constant>1</constant>) <keyword>*</keyword> sizeof(<constant>char</constant>));
    va_start(ap, format);
    len <keyword>=</keyword> (<constant>size_t</constant>)vsnprintf(chars, len <keyword>+</keyword> <constant>1</constant>, format, ap);
    va_end(ap);

    HymnString <keyword>*</keyword>error <keyword>=</keyword> hymn_new_string_with_capacity(len <keyword>+</keyword> <constant>128</constant>);
    error <keyword>=</keyword> hymn_string_append(error, chars);

    <constant>free</constant>(chars);

    HymnString <keyword>*</keyword>trace <keyword>=</keyword> stacktrace(H);
    error <keyword>=</keyword> hymn_string_append(error, <string>&quot;\n&quot;</string>);
    error <keyword>=</keyword> hymn_string_append(error, trace);
    hymn_string_delete(trace);

    <keyword>return</keyword> push_error(H, error);
}

<keyword>static</keyword> HymnFrame <keyword>*</keyword>throw_exception(Hymn <keyword>*</keyword>H, <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>name) {

    HymnString <keyword>*</keyword>trace <keyword>=</keyword> stacktrace(H);
    HymnString <keyword>*</keyword>error <keyword>=</keyword> hymn_new_string_with_capacity(hymn_string_len(H-&gt;exception) + hymn_string_len(trace) + <constant>128</constant>);
    error <keyword>=</keyword> hymn_string_append(error, H-&gt;exception);

    hymn_string_delete(H-&gt;exception);
    H-&gt;exception = <constant>NULL</constant>;

    error <keyword>=</keyword> hymn_string_append(error, <string>&quot;\n  in &quot;</string>);
    error <keyword>=</keyword> hymn_string_append(error, name);
    HymnFrame <keyword>*</keyword>frame <keyword>=</keyword> <keyword>&</keyword>H-&gt;frames[H-&gt;frame_count - <constant>1</constant>];
    HymnFunction <keyword>*</keyword>func <keyword>=</keyword> frame-&gt;func;
    <constant>int</constant> row <keyword>=</keyword> func-&gt;code.lines[frame-&gt;ip - func-&gt;code.instructions - <constant>1</constant>];
    <keyword>if</keyword> (func-&gt;script <keyword>==</keyword> <constant>NULL</constant>) {
        error <keyword>=</keyword> string_append_format(error, <string>&quot; script:%d\n&quot;</string>, row);
    } <keyword>else</keyword> {
        error <keyword>=</keyword> string_append_format(error, <string>&quot; %s:%d\n&quot;</string>, func-&gt;script, row);
    }
    error <keyword>=</keyword> hymn_string_append(error, trace);
    hymn_string_delete(trace);

    <keyword>return</keyword> push_error(H, error);
}

<keyword>static</keyword> HymnFrame <keyword>*</keyword>throw_error_string(Hymn <keyword>*</keyword>H, HymnString <keyword>*</keyword>string) {
    HymnFrame <keyword>*</keyword>frame <keyword>=</keyword> throw_error(H, string);
    hymn_string_delete(string);
    <keyword>return</keyword> frame;
}

HymnValue hymn_new_exception(Hymn <keyword>*</keyword>H, <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>error) {
    H-&gt;exception = hymn_new_string(error);
    <keyword>return</keyword> hymn_new_none();
}

HymnValue hymn_arity_exception(Hymn <keyword>*</keyword>H, <constant>int</constant> expected, <constant>int</constant> actual) {
    H-&gt;exception = hymn_string_format(<string>&quot;expected: %d function argument(s) but was: %d&quot;</string>, expected, actual);
    <keyword>return</keyword> hymn_new_none();
}

HymnValue hymn_type_exception(Hymn <keyword>*</keyword>H, <keyword>enum</keyword> HymnValueType expected, <keyword>enum</keyword> HymnValueType actual) {
    H-&gt;exception = hymn_string_format(<string>&quot;expected type: %s but was: %s&quot;</string>, hymn_value_type(expected), hymn_value_type(actual));
    <keyword>return</keyword> hymn_new_none();
}

<keyword>static</keyword> HymnFrame <keyword>*</keyword>call(Hymn <keyword>*</keyword>H, HymnFunction <keyword>*</keyword>func, <constant>int</constant> count) {
    <keyword>if</keyword> (count <keyword>!=</keyword> func-&gt;arity) {
        <keyword>if</keyword> (count <keyword>&lt;</keyword> func-&gt;arity) <keyword>return</keyword> throw_error(H, <string>&quot;not enough arguments in call to '%s' (expected %d)&quot;</string>, func-&gt;name, func-&gt;arity);
        <keyword>return</keyword> throw_error(H, <string>&quot;too many arguments in call to '%s' (expected %d)&quot;</string>, func-&gt;name, func-&gt;arity);
    } <keyword>else</keyword> <keyword>if</keyword> (H-&gt;frame_count <keyword>==</keyword> HYMN_FRAMES_MAX) {
        <keyword>return</keyword> throw_error(H, <string>&quot;stack overflow&quot;</string>);
    }

    HymnFrame <keyword>*</keyword>frame <keyword>=</keyword> <keyword>&</keyword>H-&gt;frames[H-&gt;frame_count++];
    frame-&gt;func = func;
    frame-&gt;ip = func-&gt;code.instructions;
    frame-&gt;stack = H-&gt;stack_top - count - <constant>1</constant>;

    <keyword>return</keyword> frame;
}

<keyword>static</keyword> HymnFrame <keyword>*</keyword>call_value(Hymn <keyword>*</keyword>H, HymnValue value, <constant>int</constant> count) {
    <keyword>switch</keyword> (value.is) {
    <keyword>case</keyword> HYMN_VALUE_FUNC:
        <keyword>return</keyword> call(H, hymn_as_func(value), count);
    <keyword>case</keyword> HYMN_VALUE_FUNC_NATIVE: {
        HymnNativeFunction <keyword>*</keyword>native <keyword>=</keyword> hymn_as_native(value);
        HymnNativeCall func <keyword>=</keyword> native-&gt;func;
        HymnValue result <keyword>=</keyword> func(H, count, H-&gt;stack_top - count);
        HymnValue <keyword>*</keyword>top <keyword>=</keyword> H-&gt;stack_top - count - <constant>1</constant>;
        <keyword>while</keyword> (H-&gt;stack_top <keyword>!=</keyword> top) {
            hymn_dereference(H, pop(H));
        }
        <keyword>if</keyword> (H-&gt;exception <keyword>!=</keyword> <constant>NULL</constant>) {
            <keyword>return</keyword> throw_exception(H, native-&gt;name-&gt;string);
        } <keyword>else</keyword> {
            hymn_reference(result);
            push(H, result);
            <keyword>return</keyword> current_frame(H);
        }
    }
    <keyword>default</keyword>: {
        <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>is <keyword>=</keyword> hymn_value_type(value.is);
        <keyword>return</keyword> throw_error(H, <string>&quot;can't call %s (expected function)&quot;</string>, is);
    }
    }
}

<keyword>static</keyword> HymnFrame <keyword>*</keyword>import(Hymn <keyword>*</keyword>H, HymnObjectString <keyword>*</keyword>file) {
    HymnTable <keyword>*</keyword>imports <keyword>=</keyword> H-&gt;imports;

    HymnString <keyword>*</keyword>script <keyword>=</keyword> <constant>NULL</constant>;
    <constant>int</constant> p <keyword>=</keyword> <constant>1</constant>;
    <keyword>while</keyword> (<constant>true</constant>) {
        HymnFrame <keyword>*</keyword>frame <keyword>=</keyword> parent_frame(H, p);
        <keyword>if</keyword> (frame <keyword>==</keyword> <constant>NULL</constant>) <keyword>break</keyword>;
        script <keyword>=</keyword> frame-&gt;func-&gt;script;
        <keyword>if</keyword> (script) <keyword>break</keyword>;
        p++;
    }

    HymnString <keyword>*</keyword>look <keyword>=</keyword> hymn_path_convert(file-&gt;string);
    HymnString <keyword>*</keyword>parent <keyword>=</keyword> script ? hymn_path_parent(script) : <constant>NULL</constant>;

    HymnObjectString <keyword>*</keyword>module <keyword>=</keyword> <constant>NULL</constant>;

    HymnArray <keyword>*</keyword>paths <keyword>=</keyword> H-&gt;paths;
    HymnInt size <keyword>=</keyword> paths-&gt;length;
    <keyword>for</keyword> (HymnInt i <keyword>=</keyword> <constant>0</constant>; i <keyword>&lt;</keyword> size; i++) {
        HymnValue value <keyword>=</keyword> paths-&gt;items[i];
        <keyword>if</keyword> (<keyword>!</keyword>hymn_is_string(value)) {
            <keyword>continue</keyword>;
        }
        HymnString <keyword>*</keyword>question <keyword>=</keyword> hymn_as_string(value);

        HymnString <keyword>*</keyword>replace <keyword>=</keyword> hymn_string_replace(question, <string>&quot;&lt;path&gt;&quot;</string>, look);
        HymnString <keyword>*</keyword>path <keyword>=</keyword> parent ? hymn_string_replace(replace, <string>&quot;&lt;parent&gt;&quot;</string>, parent) : hymn_string_copy(replace);

        HymnObjectString <keyword>*</keyword>use <keyword>=</keyword> hymn_intern_string(H, hymn_path_absolute(path));
        hymn_reference_string(use);

        hymn_string_delete(path);
        hymn_string_delete(replace);

        <keyword>if</keyword> (<keyword>!</keyword>hymn_is_undefined(table_get(imports, use))) {
            hymn_dereference_string(H, use);
            hymn_string_delete(look);
            <keyword>if</keyword> (parent) hymn_string_delete(parent);
            <keyword>return</keyword> current_frame(H);
        }

        <keyword>if</keyword> (hymn_file_exists(use-&gt;string)) {
            module <keyword>=</keyword> use;
            <keyword>break</keyword>;
        }

        hymn_dereference_string(H, use);
    }

    <keyword>if</keyword> (module <keyword>==</keyword> <constant>NULL</constant>) {
        HymnString <keyword>*</keyword>missing <keyword>=</keyword> hymn_string_format(<string>&quot;import not found: %s&quot;</string>, look);

        <keyword>for</keyword> (HymnInt i <keyword>=</keyword> <constant>0</constant>; i <keyword>&lt;</keyword> size; i++) {
            HymnValue value <keyword>=</keyword> paths-&gt;items[i];
            <keyword>if</keyword> (<keyword>!</keyword>hymn_is_string(value)) {
                <keyword>continue</keyword>;
            }
            HymnString <keyword>*</keyword>question <keyword>=</keyword> hymn_as_string(value);

            HymnString <keyword>*</keyword>replace <keyword>=</keyword> hymn_string_replace(question, <string>&quot;&lt;path&gt;&quot;</string>, look);
            HymnString <keyword>*</keyword>path <keyword>=</keyword> parent ? hymn_string_replace(replace, <string>&quot;&lt;parent&gt;&quot;</string>, parent) : hymn_string_copy(replace);
            HymnString <keyword>*</keyword>use <keyword>=</keyword> hymn_path_absolute(path);

            missing <keyword>=</keyword> string_append_format(missing, <string>&quot;\n  no file: %s&quot;</string>, use);

            hymn_string_delete(path);
            hymn_string_delete(replace);
            hymn_string_delete(use);
        }

        hymn_string_delete(look);
        <keyword>if</keyword> (parent) hymn_string_delete(parent);

        <keyword>return</keyword> throw_error_string(H, missing);
    }

    hymn_string_delete(look);
    <keyword>if</keyword> (parent <keyword>!=</keyword> <constant>NULL</constant>) {
        hymn_string_delete(parent);
    }

    table_put(imports, module, hymn_new_<constant>bool</constant>(<constant>true</constant>));

    HymnString <keyword>*</keyword>source <keyword>=</keyword> hymn_read_file(module-&gt;string);
    <keyword>if</keyword> (source <keyword>==</keyword> <constant>NULL</constant>) {
        HymnString <keyword>*</keyword>failed <keyword>=</keyword> hymn_string_format(<string>&quot;error reading file: %s\n&quot;</string>, module-&gt;string);
        <keyword>return</keyword> throw_error_string(H, failed);
    }

    CompileResult result <keyword>=</keyword> compile(H, module-&gt;string, source, TYPE_SCRIPT);

    hymn_string_delete(source);

    <constant>char</constant> <keyword>*</keyword>error <keyword>=</keyword> result.error;
    <keyword>if</keyword> (error <keyword>!=</keyword> <constant>NULL</constant>) {
        <keyword>return</keyword> throw_existing_error(H, error);
    }

    HymnFunction <keyword>*</keyword>func <keyword>=</keyword> result.func;
    HymnValue function <keyword>=</keyword> hymn_new_func_value(func);
    hymn_reference(function);

    push(H, function);
    call(H, func, <constant>0</constant>);

    error <keyword>=</keyword> interpret(H);
    <keyword>if</keyword> (error <keyword>!=</keyword> <constant>NULL</constant>) {
        <keyword>return</keyword> throw_existing_error(H, error);
    }

    <keyword>return</keyword> current_frame(H);
}

<keyword>static</keyword> <constant>int</constant> debug_constant_instruction(HymnString <keyword>*</keyword><keyword>*</keyword>debug, <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>name, HymnByteCode <keyword>*</keyword>code, <constant>int</constant> index) {
    <constant>uint8_t</constant> constant <keyword>=</keyword> code-&gt;instructions[index + <constant>1</constant>];
    HymnString <keyword>*</keyword>value <keyword>=</keyword> debug_value_to_string(code-&gt;constants.values[constant]);
    <keyword>*</keyword>debug <keyword>=</keyword> string_append_format(<keyword>*</keyword>debug, <string>&quot;%s: [%d] [%s]&quot;</string>, name, constant, value);
    hymn_string_delete(value);
    <keyword>return</keyword> index <keyword>+</keyword> <constant>2</constant>;
}

<keyword>static</keyword> <constant>int</constant> debug_two_constant_instruction(HymnString <keyword>*</keyword><keyword>*</keyword>debug, <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>name, HymnByteCode <keyword>*</keyword>code, <constant>int</constant> index) {
    <constant>uint8_t</constant> constant <keyword>=</keyword> code-&gt;instructions[index + <constant>1</constant>];
    HymnString <keyword>*</keyword>value <keyword>=</keyword> debug_value_to_string(code-&gt;constants.values[constant]);
    <constant>uint8_t</constant> constant2 <keyword>=</keyword> code-&gt;instructions[index + <constant>2</constant>];
    HymnString <keyword>*</keyword>value2 <keyword>=</keyword> debug_value_to_string(code-&gt;constants.values[constant2]);
    <keyword>*</keyword>debug <keyword>=</keyword> string_append_format(<keyword>*</keyword>debug, <string>&quot;%s: [%d] [%s] & [%d] [%s]&quot;</string>, name, constant, value, constant2, value2);
    hymn_string_delete(value);
    hymn_string_delete(value2);
    <keyword>return</keyword> index <keyword>+</keyword> <constant>3</constant>;
}

<keyword>static</keyword> <constant>int</constant> debug_byte_instruction(HymnString <keyword>*</keyword><keyword>*</keyword>debug, <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>name, HymnByteCode <keyword>*</keyword>code, <constant>int</constant> index) {
    <constant>uint8_t</constant> byte <keyword>=</keyword> code-&gt;instructions[index + <constant>1</constant>];
    <keyword>*</keyword>debug <keyword>=</keyword> string_append_format(<keyword>*</keyword>debug, <string>&quot;%s: [%d]&quot;</string>, name, byte);
    <keyword>return</keyword> index <keyword>+</keyword> <constant>2</constant>;
}

<keyword>static</keyword> <constant>int</constant> debug_jump_instruction(HymnString <keyword>*</keyword><keyword>*</keyword>debug, <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>name, <constant>int</constant> sign, HymnByteCode <keyword>*</keyword>code, <constant>int</constant> index) {
    <constant>int</constant> jump <keyword>=</keyword> ((<constant>int</constant>)code-&gt;instructions[index + <constant>1</constant>] <keyword>&lt;&lt;</keyword> <constant>8</constant>) | (<constant>int</constant>)code-&gt;instructions[index + <constant>2</constant>];
    <keyword>*</keyword>debug <keyword>=</keyword> string_append_format(<keyword>*</keyword>debug, <string>&quot;%s: [%zu] -&gt; [%zu]&quot;</string>, name, index, sign <keyword>&lt;</keyword> <constant>0</constant> ? index <keyword>+</keyword> <constant>3</constant> <keyword>-</keyword> jump : index <keyword>+</keyword> <constant>3</constant> <keyword>+</keyword> jump);
    <keyword>return</keyword> index <keyword>+</keyword> <constant>3</constant>;
}

<keyword>static</keyword> <constant>int</constant> debug_register_jump_instruction(HymnString <keyword>*</keyword><keyword>*</keyword>debug, <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>name, HymnByteCode <keyword>*</keyword>code, <constant>int</constant> index) {
    <constant>uint8_t</constant> slot_a <keyword>=</keyword> code-&gt;instructions[index + <constant>1</constant>];
    <constant>uint8_t</constant> slot_b <keyword>=</keyword> code-&gt;instructions[index + <constant>2</constant>];
    <constant>int</constant> jump <keyword>=</keyword> ((<constant>int</constant>)code-&gt;instructions[index + <constant>3</constant>] <keyword>&lt;&lt;</keyword> <constant>8</constant>) | (<constant>int</constant>)code-&gt;instructions[index + <constant>4</constant>];
    <keyword>*</keyword>debug <keyword>=</keyword> string_append_format(<keyword>*</keyword>debug, <string>&quot;%s: [%d] [%d] ? [%zu] -&gt; [%zu]&quot;</string>, name, slot_a, slot_b, index, index <keyword>+</keyword> <constant>5</constant> <keyword>+</keyword> jump);
    <keyword>return</keyword> index <keyword>+</keyword> <constant>5</constant>;
}

<keyword>static</keyword> <constant>int</constant> debug_three_byte_instruction(HymnString <keyword>*</keyword><keyword>*</keyword>debug, <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>name, HymnByteCode <keyword>*</keyword>code, <constant>int</constant> index) {
    <constant>uint8_t</constant> byte <keyword>=</keyword> code-&gt;instructions[index + <constant>1</constant>];
    <constant>uint8_t</constant> next <keyword>=</keyword> code-&gt;instructions[index + <constant>2</constant>];
    <keyword>*</keyword>debug <keyword>=</keyword> string_append_format(<keyword>*</keyword>debug, <string>&quot;%s: [%d] [%d]&quot;</string>, name, byte, next);
    <keyword>return</keyword> index <keyword>+</keyword> <constant>3</constant>;
}

<keyword>static</keyword> <constant>int</constant> debug_<keyword>for</keyword>_loop_instruction(HymnString <keyword>*</keyword><keyword>*</keyword>debug, <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>name, <constant>int</constant> sign, HymnByteCode <keyword>*</keyword>code, <constant>int</constant> index) {
    <constant>uint8_t</constant> slot <keyword>=</keyword> code-&gt;instructions[index + <constant>1</constant>];
    <constant>int</constant> jump <keyword>=</keyword> ((<constant>int</constant>)code-&gt;instructions[index + <constant>2</constant>] <keyword>&lt;&lt;</keyword> <constant>8</constant>) | (<constant>int</constant>)code-&gt;instructions[index + <constant>3</constant>];
    <keyword>*</keyword>debug <keyword>=</keyword> string_append_format(<keyword>*</keyword>debug, <string>&quot;%s: [%d] [%zu] -&gt; [%zu]&quot;</string>, name, slot, index, sign <keyword>&lt;</keyword> <constant>0</constant> ? index <keyword>+</keyword> <constant>4</constant> <keyword>-</keyword> jump : index <keyword>+</keyword> <constant>4</constant> <keyword>+</keyword> jump);
    <keyword>return</keyword> index <keyword>+</keyword> <constant>4</constant>;
}

<keyword>static</keyword> <constant>int</constant> debug_increment_loop_instruction(HymnString <keyword>*</keyword><keyword>*</keyword>debug, <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>name, HymnByteCode <keyword>*</keyword>code, <constant>int</constant> index) {
    <constant>uint8_t</constant> slot <keyword>=</keyword> code-&gt;instructions[index + <constant>1</constant>];
    <constant>uint8_t</constant> increment <keyword>=</keyword> code-&gt;instructions[index + <constant>2</constant>];
    <constant>int</constant> jump <keyword>=</keyword> ((<constant>int</constant>)code-&gt;instructions[index + <constant>3</constant>] <keyword>&lt;&lt;</keyword> <constant>8</constant>) | (<constant>int</constant>)code-&gt;instructions[index + <constant>4</constant>];
    <keyword>*</keyword>debug <keyword>=</keyword> string_append_format(<keyword>*</keyword>debug, <string>&quot;%s: [%d] [%d] & [%zu] -&gt; [%zu]&quot;</string>, name, slot, increment, index, index <keyword>+</keyword> <constant>5</constant> <keyword>-</keyword> jump);
    <keyword>return</keyword> index <keyword>+</keyword> <constant>5</constant>;
}

<keyword>static</keyword> <constant>int</constant> debug_instruction(HymnString <keyword>*</keyword><keyword>*</keyword>debug, <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>name, <constant>int</constant> index) {
    <keyword>*</keyword>debug <keyword>=</keyword> string_append_format(<keyword>*</keyword>debug, <string>&quot;%s&quot;</string>, name);
    <keyword>return</keyword> index <keyword>+</keyword> <constant>1</constant>;
}

<keyword>static</keyword> <constant>int</constant> disassemble_instruction(HymnString <keyword>*</keyword><keyword>*</keyword>debug, HymnByteCode <keyword>*</keyword>code, <constant>int</constant> index) {
    <keyword>*</keyword>debug <keyword>=</keyword> string_append_format(<keyword>*</keyword>debug, <string>&quot;%04zu &quot;</string>, index);
    <keyword>if</keyword> (index <keyword>&gt;</keyword> <constant>0</constant> <keyword>&</keyword><keyword>&</keyword> code-&gt;lines[index] <keyword>==</keyword> code-&gt;lines[index - <constant>1</constant>]) {
        <keyword>*</keyword>debug <keyword>=</keyword> hymn_string_append(<keyword>*</keyword>debug, <string>&quot;   | &quot;</string>);
    } <keyword>else</keyword> {
        <keyword>*</keyword>debug <keyword>=</keyword> string_append_format(<keyword>*</keyword>debug, <string>&quot;%4d &quot;</string>, code-&gt;lines[index]);
    }
    <constant>uint8_t</constant> instruction <keyword>=</keyword> code-&gt;instructions[index];
    <keyword>switch</keyword> (instruction) {
    <keyword>case</keyword> OP_ADD: <keyword>return</keyword> debug_instruction(debug, <string>&quot;OP_ADD&quot;</string>, index);
    <keyword>case</keyword> OP_ADD_LOCALS: <keyword>return</keyword> debug_three_byte_instruction(debug, <string>&quot;OP_ADD_LOCALS&quot;</string>, code, index);
    <keyword>case</keyword> OP_INSERT: <keyword>return</keyword> debug_instruction(debug, <string>&quot;OP_INSERT&quot;</string>, index);
    <keyword>case</keyword> OP_ARRAY_POP: <keyword>return</keyword> debug_instruction(debug, <string>&quot;OP_ARRAY_POP&quot;</string>, index);
    <keyword>case</keyword> OP_ARRAY_PUSH: <keyword>return</keyword> debug_instruction(debug, <string>&quot;OP_ARRAY_PUSH&quot;</string>, index);
    <keyword>case</keyword> OP_ARRAY_PUSH_LOCALS: <keyword>return</keyword> debug_three_byte_instruction(debug, <string>&quot;OP_ARRAY_PUSH_LOCALS&quot;</string>, code, index);
    <keyword>case</keyword> OP_BIT_AND: <keyword>return</keyword> debug_instruction(debug, <string>&quot;OP_BIT_AND&quot;</string>, index);
    <keyword>case</keyword> OP_BIT_LEFT_SHIFT: <keyword>return</keyword> debug_instruction(debug, <string>&quot;OP_BIT_LEFT_SHIFT&quot;</string>, index);
    <keyword>case</keyword> OP_BIT_NOT: <keyword>return</keyword> debug_instruction(debug, <string>&quot;OP_BIT_NOT&quot;</string>, index);
    <keyword>case</keyword> OP_BIT_OR: <keyword>return</keyword> debug_instruction(debug, <string>&quot;OP_BIT_OR&quot;</string>, index);
    <keyword>case</keyword> OP_BIT_RIGHT_SHIFT: <keyword>return</keyword> debug_instruction(debug, <string>&quot;OP_BIT_RIGHT_SHIFT&quot;</string>, index);
    <keyword>case</keyword> OP_BIT_XOR: <keyword>return</keyword> debug_instruction(debug, <string>&quot;OP_BIT_XOR&quot;</string>, index);
    <keyword>case</keyword> OP_CALL: <keyword>return</keyword> debug_byte_instruction(debug, <string>&quot;OP_CALL&quot;</string>, code, index);
    <keyword>case</keyword> OP_SELF: <keyword>return</keyword> debug_constant_instruction(debug, <string>&quot;OP_SELF&quot;</string>, code, index);
    <keyword>case</keyword> OP_CLEAR: <keyword>return</keyword> debug_instruction(debug, <string>&quot;OP_CLEAR&quot;</string>, index);
    <keyword>case</keyword> OP_CONSTANT: <keyword>return</keyword> debug_constant_instruction(debug, <string>&quot;OP_CONSTANT&quot;</string>, code, index);
    <keyword>case</keyword> OP_NEW_ARRAY: <keyword>return</keyword> debug_instruction(debug, <string>&quot;OP_NEW_ARRAY&quot;</string>, index);
    <keyword>case</keyword> OP_NEW_TABLE: <keyword>return</keyword> debug_instruction(debug, <string>&quot;OP_NEW_TABLE&quot;</string>, index);
    <keyword>case</keyword> OP_COPY: <keyword>return</keyword> debug_instruction(debug, <string>&quot;OP_COPY&quot;</string>, index);
    <keyword>case</keyword> OP_DEFINE_GLOBAL: <keyword>return</keyword> debug_constant_instruction(debug, <string>&quot;OP_DEFINE_GLOBAL&quot;</string>, code, index);
    <keyword>case</keyword> OP_DEBUG: <keyword>return</keyword> debug_instruction(debug, <string>&quot;OP_DEBUG&quot;</string>, index);
    <keyword>case</keyword> OP_DELETE: <keyword>return</keyword> debug_instruction(debug, <string>&quot;OP_DELETE&quot;</string>, index);
    <keyword>case</keyword> OP_DIVIDE: <keyword>return</keyword> debug_instruction(debug, <string>&quot;OP_DIVIDE&quot;</string>, index);
    <keyword>case</keyword> OP_DUPLICATE: <keyword>return</keyword> debug_instruction(debug, <string>&quot;OP_DUPLICATE&quot;</string>, index);
    <keyword>case</keyword> OP_EQUAL: <keyword>return</keyword> debug_instruction(debug, <string>&quot;OP_EQUAL&quot;</string>, index);
    <keyword>case</keyword> OP_ECHO: <keyword>return</keyword> debug_instruction(debug, <string>&quot;OP_ECHO&quot;</string>, index);
    <keyword>case</keyword> OP_EXISTS: <keyword>return</keyword> debug_instruction(debug, <string>&quot;OP_EXISTS&quot;</string>, index);
    <keyword>case</keyword> OP_FALSE: <keyword>return</keyword> debug_instruction(debug, <string>&quot;OP_FALSE&quot;</string>, index);
    <keyword>case</keyword> OP_FOR: <keyword>return</keyword> debug_<keyword>for</keyword>_loop_instruction(debug, <string>&quot;OP_FOR&quot;</string>, <constant>1</constant>, code, index);
    <keyword>case</keyword> OP_FOR_LOOP: <keyword>return</keyword> debug_<keyword>for</keyword>_loop_instruction(debug, <string>&quot;OP_FOR_LOOP&quot;</string>, <keyword>-</keyword><constant>1</constant>, code, index);
    <keyword>case</keyword> OP_GET_DYNAMIC: <keyword>return</keyword> debug_instruction(debug, <string>&quot;OP_GET_DYNAMIC&quot;</string>, index);
    <keyword>case</keyword> OP_GET_GLOBAL: <keyword>return</keyword> debug_constant_instruction(debug, <string>&quot;OP_GET_GLOBAL&quot;</string>, code, index);
    <keyword>case</keyword> OP_GET_GLOBAL_PROPERTY: <keyword>return</keyword> debug_two_constant_instruction(debug, <string>&quot;OP_GET_GLOBAL_PROPERTY&quot;</string>, code, index);
    <keyword>case</keyword> OP_GET_LOCAL: <keyword>return</keyword> debug_byte_instruction(debug, <string>&quot;OP_GET_LOCAL&quot;</string>, code, index);
    <keyword>case</keyword> OP_GET_PROPERTY: <keyword>return</keyword> debug_constant_instruction(debug, <string>&quot;OP_GET_PROPERTY&quot;</string>, code, index);
    <keyword>case</keyword> OP_GET_LOCALS: <keyword>return</keyword> debug_three_byte_instruction(debug, <string>&quot;OP_GET_LOCALS&quot;</string>, code, index);
    <keyword>case</keyword> OP_GREATER: <keyword>return</keyword> debug_instruction(debug, <string>&quot;OP_GREATER&quot;</string>, index);
    <keyword>case</keyword> OP_GREATER_EQUAL: <keyword>return</keyword> debug_instruction(debug, <string>&quot;OP_GREATER_EQUAL&quot;</string>, index);
    <keyword>case</keyword> OP_INCREMENT: <keyword>return</keyword> debug_byte_instruction(debug, <string>&quot;OP_INCREMENT&quot;</string>, code, index);
    <keyword>case</keyword> OP_INCREMENT_LOCAL: <keyword>return</keyword> debug_three_byte_instruction(debug, <string>&quot;OP_INCREMENT_LOCAL&quot;</string>, code, index);
    <keyword>case</keyword> OP_INCREMENT_LOCAL_AND_SET: <keyword>return</keyword> debug_three_byte_instruction(debug, <string>&quot;OP_INCREMENT_LOCAL_AND_SET&quot;</string>, code, index);
    <keyword>case</keyword> OP_INCREMENT_LOOP: <keyword>return</keyword> debug_increment_loop_instruction(debug, <string>&quot;OP_INCREMENT_LOOP&quot;</string>, code, index);
    <keyword>case</keyword> OP_INDEX: <keyword>return</keyword> debug_instruction(debug, <string>&quot;OP_INDEX&quot;</string>, index);
    <keyword>case</keyword> OP_INSPECT: <keyword>return</keyword> debug_instruction(debug, <string>&quot;OP_INSPECT&quot;</string>, index);
    <keyword>case</keyword> OP_JUMP: <keyword>return</keyword> debug_jump_instruction(debug, <string>&quot;OP_JUMP&quot;</string>, <constant>1</constant>, code, index);
    <keyword>case</keyword> OP_JUMP_IF_EQUAL: <keyword>return</keyword> debug_jump_instruction(debug, <string>&quot;OP_JUMP_IF_EQUAL&quot;</string>, <constant>1</constant>, code, index);
    <keyword>case</keyword> OP_JUMP_IF_FALSE: <keyword>return</keyword> debug_jump_instruction(debug, <string>&quot;OP_JUMP_IF_FALSE&quot;</string>, <constant>1</constant>, code, index);
    <keyword>case</keyword> OP_JUMP_IF_GREATER: <keyword>return</keyword> debug_jump_instruction(debug, <string>&quot;OP_JUMP_IF_GREATER&quot;</string>, <constant>1</constant>, code, index);
    <keyword>case</keyword> OP_JUMP_IF_GREATER_LOCALS: <keyword>return</keyword> debug_register_jump_instruction(debug, <string>&quot;OP_JUMP_IF_GREATER_LOCALS&quot;</string>, code, index);
    <keyword>case</keyword> OP_JUMP_IF_GREATER_EQUAL: <keyword>return</keyword> debug_jump_instruction(debug, <string>&quot;OP_JUMP_IF_GREATER_EQUAL&quot;</string>, <constant>1</constant>, code, index);
    <keyword>case</keyword> OP_JUMP_IF_LESS: <keyword>return</keyword> debug_jump_instruction(debug, <string>&quot;OP_JUMP_IF_LESS&quot;</string>, <constant>1</constant>, code, index);
    <keyword>case</keyword> OP_JUMP_IF_LESS_EQUAL: <keyword>return</keyword> debug_jump_instruction(debug, <string>&quot;OP_JUMP_IF_LESS_EQUAL&quot;</string>, <constant>1</constant>, code, index);
    <keyword>case</keyword> OP_JUMP_IF_NOT_EQUAL: <keyword>return</keyword> debug_jump_instruction(debug, <string>&quot;OP_JUMP_IF_NOT_EQUAL&quot;</string>, <constant>1</constant>, code, index);
    <keyword>case</keyword> OP_JUMP_IF_TRUE: <keyword>return</keyword> debug_jump_instruction(debug, <string>&quot;OP_JUMP_IF_TRUE&quot;</string>, <constant>1</constant>, code, index);
    <keyword>case</keyword> OP_KEYS: <keyword>return</keyword> debug_instruction(debug, <string>&quot;OP_KEYS&quot;</string>, index);
    <keyword>case</keyword> OP_LEN: <keyword>return</keyword> debug_instruction(debug, <string>&quot;OP_LEN&quot;</string>, index);
    <keyword>case</keyword> OP_LESS: <keyword>return</keyword> debug_instruction(debug, <string>&quot;OP_LESS&quot;</string>, index);
    <keyword>case</keyword> OP_LESS_EQUAL: <keyword>return</keyword> debug_instruction(debug, <string>&quot;OP_LESS_EQUAL&quot;</string>, index);
    <keyword>case</keyword> OP_LOOP: <keyword>return</keyword> debug_jump_instruction(debug, <string>&quot;OP_LOOP&quot;</string>, <keyword>-</keyword><constant>1</constant>, code, index);
    <keyword>case</keyword> OP_MODULO: <keyword>return</keyword> debug_instruction(debug, <string>&quot;OP_MODULO&quot;</string>, index);
    <keyword>case</keyword> OP_MODULO_LOCALS: <keyword>return</keyword> debug_three_byte_instruction(debug, <string>&quot;OP_MODULO_LOCALS&quot;</string>, code, index);
    <keyword>case</keyword> OP_MULTIPLY: <keyword>return</keyword> debug_instruction(debug, <string>&quot;OP_MULTIPLY&quot;</string>, index);
    <keyword>case</keyword> OP_NEGATE: <keyword>return</keyword> debug_instruction(debug, <string>&quot;OP_NEGATE&quot;</string>, index);
    <keyword>case</keyword> OP_NONE: <keyword>return</keyword> debug_instruction(debug, <string>&quot;OP_NONE&quot;</string>, index);
    <keyword>case</keyword> OP_NOT: <keyword>return</keyword> debug_instruction(debug, <string>&quot;OP_NOT&quot;</string>, index);
    <keyword>case</keyword> OP_NOT_EQUAL: <keyword>return</keyword> debug_instruction(debug, <string>&quot;OP_NOT_EQUAL&quot;</string>, index);
    <keyword>case</keyword> OP_POP: <keyword>return</keyword> debug_instruction(debug, <string>&quot;OP_POP&quot;</string>, index);
    <keyword>case</keyword> OP_POP_N: <keyword>return</keyword> debug_byte_instruction(debug, <string>&quot;OP_POP_N&quot;</string>, code, index);
    <keyword>case</keyword> OP_POP_TWO: <keyword>return</keyword> debug_instruction(debug, <string>&quot;OP_POP_TWO&quot;</string>, index);
    <keyword>case</keyword> OP_PRINT: <keyword>return</keyword> debug_instruction(debug, <string>&quot;OP_PRINT&quot;</string>, index);
    <keyword>case</keyword> OP_RETURN: <keyword>return</keyword> debug_instruction(debug, <string>&quot;OP_RETURN&quot;</string>, index);
    <keyword>case</keyword> OP_VOID: <keyword>return</keyword> debug_instruction(debug, <string>&quot;OP_VOID&quot;</string>, index);
    <keyword>case</keyword> OP_SET_DYNAMIC: <keyword>return</keyword> debug_instruction(debug, <string>&quot;OP_SET_DYNAMIC&quot;</string>, index);
    <keyword>case</keyword> OP_SET_GLOBAL: <keyword>return</keyword> debug_constant_instruction(debug, <string>&quot;OP_SET_GLOBAL&quot;</string>, code, index);
    <keyword>case</keyword> OP_SET_LOCAL: <keyword>return</keyword> debug_byte_instruction(debug, <string>&quot;OP_SET_LOCAL&quot;</string>, code, index);
    <keyword>case</keyword> OP_SET_PROPERTY: <keyword>return</keyword> debug_constant_instruction(debug, <string>&quot;OP_SET_PROPERTY&quot;</string>, code, index);
    <keyword>case</keyword> OP_SLICE: <keyword>return</keyword> debug_instruction(debug, <string>&quot;OP_SLICE&quot;</string>, index);
    <keyword>case</keyword> OP_SUBTRACT: <keyword>return</keyword> debug_instruction(debug, <string>&quot;OP_SUBTRACT&quot;</string>, index);
    <keyword>case</keyword> OP_TAIL_CALL: <keyword>return</keyword> debug_byte_instruction(debug, <string>&quot;OP_TAIL_CALL&quot;</string>, code, index);
    <keyword>case</keyword> OP_THROW: <keyword>return</keyword> debug_instruction(debug, <string>&quot;OP_THROW&quot;</string>, index);
    <keyword>case</keyword> OP_FLOAT: <keyword>return</keyword> debug_instruction(debug, <string>&quot;OP_FLOAT&quot;</string>, index);
    <keyword>case</keyword> OP_INT: <keyword>return</keyword> debug_instruction(debug, <string>&quot;OP_INT&quot;</string>, index);
    <keyword>case</keyword> OP_STRING: <keyword>return</keyword> debug_instruction(debug, <string>&quot;OP_STRING&quot;</string>, index);
    <keyword>case</keyword> OP_TRUE: <keyword>return</keyword> debug_instruction(debug, <string>&quot;OP_TRUE&quot;</string>, index);
    <keyword>case</keyword> OP_TYPE: <keyword>return</keyword> debug_instruction(debug, <string>&quot;OP_TYPE&quot;</string>, index);
    <keyword>case</keyword> OP_USE: <keyword>return</keyword> debug_instruction(debug, <string>&quot;OP_USE&quot;</string>, index);
    <keyword>default</keyword>: <keyword>*</keyword>debug <keyword>=</keyword> string_append_format(<keyword>*</keyword>debug, <string>&quot;UNKNOWN_OPCODE %d\n&quot;</string>, instruction); <keyword>return</keyword> index <keyword>+</keyword> <constant>1</constant>;
    }
}

<keyword>static</keyword> HymnString <keyword>*</keyword>disassemble_byte_code(HymnByteCode <keyword>*</keyword>code) {
    HymnString <keyword>*</keyword>debug <keyword>=</keyword> hymn_new_string(<string>&quot;&quot;</string>);
    <keyword>if</keyword> (code-&gt;count &gt; <constant>0</constant>) {
        <constant>int</constant> offset <keyword>=</keyword> disassemble_instruction(<keyword>&</keyword>debug, code, <constant>0</constant>);
        <keyword>while</keyword> (offset <keyword>&lt;</keyword> code-&gt;count) {
            debug <keyword>=</keyword> hymn_string_append_<constant>char</constant>(debug, <string>'\n'</string>);
            offset <keyword>=</keyword> disassemble_instruction(<keyword>&</keyword>debug, code, offset);
        }
    }
    <keyword>return</keyword> debug;
}

<constant>#define</constant> READ_BYTE(F) (<keyword>*</keyword>F-&gt;ip++)

<constant>#define</constant> READ_SHORT(F) (F-&gt;ip += <constant>2</constant>, (((<constant>int</constant>)F-&gt;ip[-<constant>2</constant>] <keyword>&lt;&lt;</keyword> <constant>8</constant>) | (<constant>int</constant>)F-&gt;ip[-<constant>1</constant>]))

<constant>#define</constant> GET_CONSTANT(F, B) (F-&gt;func-&gt;code.constants.values[B])

<constant>#define</constant> READ_CONSTANT(F) (GET_CONSTANT(F, READ_BYTE(F)))

<constant>#define</constant> THROW(...)                         \
    frame <keyword>=</keyword> throw_error(H, ##__VA_ARGS__); \
    <keyword>if</keyword> (frame <keyword>==</keyword> <constant>NULL</constant>) <keyword>return</keyword>;             \
    <keyword>goto</keyword> dispatch;

<constant>#define</constant> COMPARE_OP(compare)                                                                       \
    HymnValue b <keyword>=</keyword> pop(H);                                                                         \
    HymnValue a <keyword>=</keyword> pop(H);                                                                         \
    <keyword>if</keyword> (hymn_is_<constant>int</constant>(a)) {                                                                         \
        <keyword>if</keyword> (hymn_is_<constant>int</constant>(b)) {                                                                     \
            push(H, hymn_new_<constant>bool</constant>(hymn_as_<constant>int</constant>(a) compare hymn_as_<constant>int</constant>(b)));                        \
        } <keyword>else</keyword> <keyword>if</keyword> (hymn_is_<constant>float</constant>(b)) {                                                            \
            push(H, hymn_new_<constant>bool</constant>((HymnFloat)hymn_as_<constant>int</constant>(a) compare hymn_as_<constant>float</constant>(b)));           \
        } <keyword>else</keyword> {                                                                                  \
            <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>is_a <keyword>=</keyword> hymn_value_type(a.is);                                             \
            <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>is_b <keyword>=</keyword> hymn_value_type(b.is);                                             \
            hymn_dereference(H, a);                                                               \
            hymn_dereference(H, b);                                                               \
            THROW(<string>&quot;comparison '&quot;</string> #compare <string>&quot;' can't use %s and %s (expected numbers)&quot;</string>, is_a, is_b) \
        }                                                                                         \
    } <keyword>else</keyword> <keyword>if</keyword> (hymn_is_<constant>float</constant>(a)) {                                                                \
        <keyword>if</keyword> (hymn_is_<constant>int</constant>(b)) {                                                                     \
            push(H, hymn_new_<constant>bool</constant>(hymn_as_<constant>float</constant>(a) compare(HymnFloat) hymn_as_<constant>int</constant>(b)));           \
        } <keyword>else</keyword> <keyword>if</keyword> (hymn_is_<constant>float</constant>(b)) {                                                            \
            push(H, hymn_new_<constant>bool</constant>(hymn_as_<constant>float</constant>(a) compare hymn_as_<constant>float</constant>(b)));                    \
        } <keyword>else</keyword> {                                                                                  \
            <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>is_a <keyword>=</keyword> hymn_value_type(a.is);                                             \
            <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>is_b <keyword>=</keyword> hymn_value_type(b.is);                                             \
            hymn_dereference(H, a);                                                               \
            hymn_dereference(H, b);                                                               \
            THROW(<string>&quot;comparison '&quot;</string> #compare <string>&quot;' can't use %s and %s (expected numbers)&quot;</string>, is_a, is_b) \
        }                                                                                         \
    } <keyword>else</keyword> {                                                                                      \
        <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>is_a <keyword>=</keyword> hymn_value_type(a.is);                                                 \
        <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>is_b <keyword>=</keyword> hymn_value_type(b.is);                                                 \
        hymn_dereference(H, a);                                                                   \
        hymn_dereference(H, b);                                                                   \
        THROW(<string>&quot;comparison '&quot;</string> #compare <string>&quot;' can't use %s and %s (expected numbers)&quot;</string>, is_a, is_b)     \
    }

<constant>#define</constant> JUMP_COMPARE_OP(compare)                                         \
    HymnValue b <keyword>=</keyword> pop(H);                                                \
    HymnValue a <keyword>=</keyword> pop(H);                                                \
    <constant>bool</constant> answer;                                                         \
    <keyword>if</keyword> (hymn_is_<constant>int</constant>(a)) {                                                \
        <keyword>if</keyword> (hymn_is_<constant>int</constant>(b)) {                                            \
            answer <keyword>=</keyword> hymn_as_<constant>int</constant>(a) compare hymn_as_<constant>int</constant>(b);              \
        } <keyword>else</keyword> <keyword>if</keyword> (hymn_is_<constant>float</constant>(b)) {                                   \
            answer <keyword>=</keyword> (HymnFloat)hymn_as_<constant>int</constant>(a) compare hymn_as_<constant>float</constant>(b); \
        } <keyword>else</keyword> {                                                         \
            hymn_dereference(H, a);                                      \
            hymn_dereference(H, b);                                      \
            THROW(<string>&quot;comparison: operands must be numbers&quot;</string>)                \
        }                                                                \
    } <keyword>else</keyword> <keyword>if</keyword> (hymn_is_<constant>float</constant>(a)) {                                       \
        <keyword>if</keyword> (hymn_is_<constant>int</constant>(b)) {                                            \
            answer <keyword>=</keyword> hymn_as_<constant>float</constant>(a) compare(HymnFloat) hymn_as_<constant>int</constant>(b); \
        } <keyword>else</keyword> <keyword>if</keyword> (hymn_is_<constant>float</constant>(b)) {                                   \
            answer <keyword>=</keyword> hymn_as_<constant>float</constant>(a) compare hymn_as_<constant>float</constant>(b);          \
        } <keyword>else</keyword> {                                                         \
            hymn_dereference(H, a);                                      \
            hymn_dereference(H, b);                                      \
            THROW(<string>&quot;comparison: operands must be numbers&quot;</string>)                \
        }                                                                \
    } <keyword>else</keyword> {                                                             \
        hymn_dereference(H, a);                                          \
        hymn_dereference(H, b);                                          \
        THROW(<string>&quot;comparison: operands must be numbers&quot;</string>)                    \
    }                                                                    \
    <constant>int</constant> jump <keyword>=</keyword> READ_SHORT(frame);                                        \
    <keyword>if</keyword> (answer) {                                                        \
        frame-&gt;ip += jump;                                               \
    }

<keyword>static</keyword> <constant>void</constant> run(Hymn <keyword>*</keyword>H) {
    HymnFrame <keyword>*</keyword>frame <keyword>=</keyword> current_frame(H);

dispatch:
<constant>#ifdef</constant> HYMN_DEBUG_STACK
    <keyword>if</keyword> (H-&gt;stack_top <keyword>!=</keyword> H-&gt;stack) {
        HymnString <keyword>*</keyword>debug <keyword>=</keyword> hymn_new_string(<string>&quot;&quot;</string>);
        <keyword>for</keyword> (HymnValue <keyword>*</keyword>i <keyword>=</keyword> H-&gt;stack; i <keyword>!=</keyword> H-&gt;stack_top; i++) {
            debug <keyword>=</keyword> hymn_string_append_<constant>char</constant>(debug, <string>'['</string>);
            HymnString <keyword>*</keyword>stack_debug <keyword>=</keyword> debug_value_to_string(<keyword>*</keyword>i);
            debug <keyword>=</keyword> hymn_string_append(debug, stack_debug);
            hymn_string_delete(stack_debug);
            debug <keyword>=</keyword> hymn_string_append(debug, <string>&quot;] &quot;</string>);
        }
        <constant>printf</constant>(<string>&quot;STACK   | %s\n&quot;</string>, debug);
        hymn_string_delete(debug);
    }
<constant>#endif</constant>
<constant>#ifdef</constant> HYMN_DEBUG_TRACE
    {
        HymnString <keyword>*</keyword>debug <keyword>=</keyword> hymn_new_string(<string>&quot;&quot;</string>);
        disassemble_instruction(<keyword>&</keyword>debug, <keyword>&</keyword>frame-&gt;func-&gt;code, (<constant>int</constant>)(frame-&gt;ip - frame-&gt;func-&gt;code.instructions));
        <constant>printf</constant>(<string>&quot;%s\n&quot;</string>, debug);
        hymn_string_delete(debug);
    }
<constant>#endif</constant>
    <keyword>switch</keyword> (READ_BYTE(frame)) {
    <keyword>case</keyword> OP_VOID: {
        H-&gt;frame_count--;
        <constant>bool</constant> done <keyword>=</keyword> H-&gt;frame_count <keyword>==</keyword> <constant>0</constant> || frame-&gt;func-&gt;name <keyword>==</keyword> <constant>NULL</constant>;
        <keyword>while</keyword> (H-&gt;stack_top <keyword>!=</keyword> frame-&gt;stack) {
            hymn_dereference(H, pop(H));
        }
        <keyword>if</keyword> (done) <keyword>return</keyword>;
        push(H, hymn_new_none());
        frame <keyword>=</keyword> current_frame(H);
        <keyword>goto</keyword> dispatch;
    }
    <keyword>case</keyword> OP_RETURN: {
        HymnValue result <keyword>=</keyword> pop(H);
        H-&gt;frame_count--;
        <constant>bool</constant> done <keyword>=</keyword> H-&gt;frame_count <keyword>==</keyword> <constant>0</constant> || frame-&gt;func-&gt;name <keyword>==</keyword> <constant>NULL</constant>;
        <keyword>while</keyword> (H-&gt;stack_top <keyword>!=</keyword> frame-&gt;stack) {
            hymn_dereference(H, pop(H));
        }
        <keyword>if</keyword> (done) <keyword>return</keyword>;
        push(H, result);
        frame <keyword>=</keyword> current_frame(H);
        <keyword>goto</keyword> dispatch;
    }
    <keyword>case</keyword> OP_POP: {
        hymn_dereference(H, pop(H));
        <keyword>goto</keyword> dispatch;
    }
    <keyword>case</keyword> OP_POP_TWO: {
        hymn_dereference(H, pop(H));
        hymn_dereference(H, pop(H));
        <keyword>goto</keyword> dispatch;
    }
    <keyword>case</keyword> OP_POP_N: {
        <constant>int</constant> count <keyword>=</keyword> READ_BYTE(frame);
        <keyword>while</keyword> (count--) {
            hymn_dereference(H, pop(H));
        }
        <keyword>goto</keyword> dispatch;
    }
    <keyword>case</keyword> OP_TRUE: {
        push(H, hymn_new_<constant>bool</constant>(<constant>true</constant>));
        <keyword>goto</keyword> dispatch;
    }
    <keyword>case</keyword> OP_FALSE: {
        push(H, hymn_new_<constant>bool</constant>(<constant>false</constant>));
        <keyword>goto</keyword> dispatch;
    }
    <keyword>case</keyword> OP_NONE: {
        push(H, hymn_new_none());
        <keyword>goto</keyword> dispatch;
    }
    <keyword>case</keyword> OP_CALL: {
        <constant>int</constant> count <keyword>=</keyword> READ_BYTE(frame);
        HymnValue value <keyword>=</keyword> peek(H, count <keyword>+</keyword> <constant>1</constant>);
        frame <keyword>=</keyword> call_value(H, value, count);
        <keyword>if</keyword> (frame <keyword>==</keyword> <constant>NULL</constant>) <keyword>return</keyword>;
        <keyword>goto</keyword> dispatch;
    }
    <keyword>case</keyword> OP_TAIL_CALL: {
        <constant>int</constant> count <keyword>=</keyword> READ_BYTE(frame);
        HymnValue value <keyword>=</keyword> peek(H, count <keyword>+</keyword> <constant>1</constant>);
        <keyword>if</keyword> (<keyword>!</keyword>hymn_is_func(value)) {
            frame <keyword>=</keyword> call_value(H, value, count);
        } <keyword>else</keyword> {
            HymnFunction <keyword>*</keyword>func <keyword>=</keyword> hymn_as_func(value);
            <keyword>if</keyword> (count <keyword>!=</keyword> func-&gt;arity) {
                <keyword>if</keyword> (count <keyword>&lt;</keyword> func-&gt;arity) frame = throw_error(H, <string>&quot;not enough arguments in call to '%s' (expected %d)&quot;</string>, func-&gt;name, func-&gt;arity);
                frame <keyword>=</keyword> throw_error(H, <string>&quot;too many arguments in call to '%s' (expected %d)&quot;</string>, func-&gt;name, func-&gt;arity);
                <keyword>if</keyword> (frame <keyword>==</keyword> <constant>NULL</constant>) <keyword>return</keyword>;
            } <keyword>else</keyword> {
                HymnValue <keyword>*</keyword>top <keyword>=</keyword> H-&gt;stack_top;
                HymnValue <keyword>*</keyword>start <keyword>=</keyword> top <keyword>-</keyword> count <keyword>-</keyword> <constant>1</constant>;
                HymnValue <keyword>*</keyword>bottom <keyword>=</keyword> frame-&gt;stack;
                HymnValue <keyword>*</keyword>move <keyword>=</keyword> start;
                <keyword>while</keyword> (bottom <keyword>!=</keyword> start) {
                    hymn_dereference(H, <keyword>*</keyword>bottom);
                    <keyword>if</keyword> (move <keyword>!=</keyword> top) {
                        <keyword>*</keyword>bottom <keyword>=</keyword> <keyword>*</keyword>move;
                        move++;
                    }
                    bottom++;
                }
                <keyword>while</keyword> (move <keyword>!=</keyword> top) {
                    <keyword>*</keyword>bottom <keyword>=</keyword> <keyword>*</keyword>move;
                    move++;
                    bottom++;
                }
                H-&gt;stack_top = start;
                frame-&gt;func = func;
                frame-&gt;ip = func-&gt;code.instructions;
            }
        }
        <keyword>if</keyword> (frame <keyword>==</keyword> <constant>NULL</constant>) <keyword>return</keyword>;
        <keyword>goto</keyword> dispatch;
    }
    <keyword>case</keyword> OP_SELF: {
        HymnValue table <keyword>=</keyword> peek(H, <constant>1</constant>);
        <keyword>if</keyword> (<keyword>!</keyword>hymn_is_table(table)) {
            <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>is <keyword>=</keyword> hymn_value_type(table.is);
            THROW(<string>&quot;can't get property of %s (expected table)&quot;</string>, is)
        }
        HymnObjectString <keyword>*</keyword>name <keyword>=</keyword> hymn_as_hymn_string(READ_CONSTANT(frame));
        HymnValue fun <keyword>=</keyword> table_get(hymn_as_table(table), name);
        <keyword>*</keyword>(H-&gt;stack_top - <constant>1</constant>) <keyword>=</keyword> fun;
        hymn_reference(fun);
        <keyword>*</keyword>H-&gt;stack_top = table;
        H-&gt;stack_top++;
        <keyword>goto</keyword> dispatch;
    }
    <keyword>case</keyword> OP_JUMP: {
        <constant>int</constant> jump <keyword>=</keyword> READ_SHORT(frame);
        frame-&gt;ip += jump;
        <keyword>goto</keyword> dispatch;
    }
    <keyword>case</keyword> OP_JUMP_IF_FALSE: {
        HymnValue a <keyword>=</keyword> pop(H);
        <constant>int</constant> jump <keyword>=</keyword> READ_SHORT(frame);
        <keyword>if</keyword> (hymn_value_<constant>false</constant>(a)) {
            frame-&gt;ip += jump;
        }
        hymn_dereference(H, a);
        <keyword>goto</keyword> dispatch;
    }
    <keyword>case</keyword> OP_JUMP_IF_TRUE: {
        HymnValue a <keyword>=</keyword> pop(H);
        <constant>int</constant> jump <keyword>=</keyword> READ_SHORT(frame);
        <keyword>if</keyword> (<keyword>!</keyword>hymn_value_<constant>false</constant>(a)) {
            frame-&gt;ip += jump;
        }
        hymn_dereference(H, a);
        <keyword>goto</keyword> dispatch;
    }
    <keyword>case</keyword> OP_JUMP_IF_EQUAL: {
        HymnValue b <keyword>=</keyword> pop(H);
        HymnValue a <keyword>=</keyword> pop(H);
        <constant>int</constant> jump <keyword>=</keyword> READ_SHORT(frame);
        <keyword>if</keyword> (hymn_values_equal(a, b)) {
            frame-&gt;ip += jump;
        }
        hymn_dereference(H, a);
        hymn_dereference(H, b);
        <keyword>goto</keyword> dispatch;
    }
    <keyword>case</keyword> OP_JUMP_IF_NOT_EQUAL: {
        HymnValue b <keyword>=</keyword> pop(H);
        HymnValue a <keyword>=</keyword> pop(H);
        <constant>int</constant> jump <keyword>=</keyword> READ_SHORT(frame);
        <keyword>if</keyword> (<keyword>!</keyword>hymn_values_equal(a, b)) {
            frame-&gt;ip += jump;
        }
        hymn_dereference(H, a);
        hymn_dereference(H, b);
        <keyword>goto</keyword> dispatch;
    }
    <keyword>case</keyword> OP_JUMP_IF_LESS: {
        JUMP_COMPARE_OP(<keyword>&lt;</keyword>)
        <keyword>goto</keyword> dispatch;
    }
    <keyword>case</keyword> OP_JUMP_IF_LESS_EQUAL: {
        JUMP_COMPARE_OP(<keyword>&lt;</keyword><keyword>=</keyword>)
        <keyword>goto</keyword> dispatch;
    }
    <keyword>case</keyword> OP_JUMP_IF_GREATER: {
        JUMP_COMPARE_OP(<keyword>&gt;</keyword>)
        <keyword>goto</keyword> dispatch;
    }
    <keyword>case</keyword> OP_JUMP_IF_GREATER_LOCALS: {
        HymnValue a <keyword>=</keyword> frame-&gt;stack[READ_BYTE(frame)];
        HymnValue b <keyword>=</keyword> frame-&gt;stack[READ_BYTE(frame)];
        <constant>int</constant> jump <keyword>=</keyword> READ_SHORT(frame);
        <constant>bool</constant> answer;
        <keyword>if</keyword> (hymn_is_<constant>int</constant>(a)) {
            <keyword>if</keyword> (hymn_is_<constant>int</constant>(b)) {
                answer <keyword>=</keyword> hymn_as_<constant>int</constant>(a) <keyword>&gt;</keyword> hymn_as_<constant>int</constant>(b);
            } <keyword>else</keyword> <keyword>if</keyword> (hymn_is_<constant>float</constant>(b)) {
                answer <keyword>=</keyword> (HymnFloat)hymn_as_<constant>int</constant>(a) <keyword>&gt;</keyword> hymn_as_<constant>float</constant>(b);
            } <keyword>else</keyword> {
                THROW(<string>&quot;comparison: operands must be numbers&quot;</string>)
            }
        } <keyword>else</keyword> <keyword>if</keyword> (hymn_is_<constant>float</constant>(a)) {
            <keyword>if</keyword> (hymn_is_<constant>int</constant>(b)) {
                answer <keyword>=</keyword> hymn_as_<constant>float</constant>(a) <keyword>&gt;</keyword> (HymnFloat)hymn_as_<constant>int</constant>(b);
            } <keyword>else</keyword> <keyword>if</keyword> (hymn_is_<constant>float</constant>(b)) {
                answer <keyword>=</keyword> hymn_as_<constant>float</constant>(a) <keyword>&gt;</keyword> hymn_as_<constant>float</constant>(b);
            } <keyword>else</keyword> {
                THROW(<string>&quot;comparison: operands must be numbers&quot;</string>)
            }
        } <keyword>else</keyword> {
            THROW(<string>&quot;comparison: operands must be numbers&quot;</string>)
        }
        <keyword>if</keyword> (answer) {
            frame-&gt;ip += jump;
        }
        <keyword>goto</keyword> dispatch;
    }
    <keyword>case</keyword> OP_JUMP_IF_GREATER_EQUAL: {
        JUMP_COMPARE_OP(<keyword>&gt;</keyword><keyword>=</keyword>)
        <keyword>goto</keyword> dispatch;
    }
    <keyword>case</keyword> OP_LOOP: {
        <constant>int</constant> jump <keyword>=</keyword> READ_SHORT(frame);
        frame-&gt;ip -= jump;
        <keyword>goto</keyword> dispatch;
    }
    <keyword>case</keyword> OP_INCREMENT_LOOP: {
        <constant>int</constant> slot <keyword>=</keyword> READ_BYTE(frame);
        <constant>int</constant> increment <keyword>=</keyword> READ_BYTE(frame);
        <constant>int</constant> jump <keyword>=</keyword> READ_SHORT(frame);
        HymnValue value <keyword>=</keyword> frame-&gt;stack[slot];
        <keyword>if</keyword> (hymn_is_<constant>int</constant>(value)) {
            value.as.i <keyword>+</keyword><keyword>=</keyword> (HymnInt)increment;
        } <keyword>else</keyword> <keyword>if</keyword> (hymn_is_<constant>float</constant>(value)) {
            value.as.f <keyword>+</keyword><keyword>=</keyword> (HymnFloat)increment;
        } <keyword>else</keyword> {
            <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>is <keyword>=</keyword> hymn_value_type(value.is);
            THROW(<string>&quot;expected a number but was '%s'&quot;</string>, is)
        }
        frame-&gt;stack[slot] = value;
        frame-&gt;ip -= jump;
        <keyword>goto</keyword> dispatch;
    }
    <keyword>case</keyword> OP_FOR: {
        <constant>int</constant> slot <keyword>=</keyword> READ_BYTE(frame);
        HymnValue object <keyword>=</keyword> frame-&gt;stack[slot];
        H-&gt;stack_top += <constant>2</constant>;
        <keyword>if</keyword> (hymn_is_table(object)) {
            HymnTable <keyword>*</keyword>table <keyword>=</keyword> hymn_as_table(object);
            HymnTableItem <keyword>*</keyword>next <keyword>=</keyword> table_next(table, <constant>NULL</constant>);
            <keyword>if</keyword> (next <keyword>==</keyword> <constant>NULL</constant>) {
                frame-&gt;stack[slot + <constant>1</constant>] <keyword>=</keyword> hymn_new_none();
                frame-&gt;stack[slot + <constant>2</constant>] <keyword>=</keyword> hymn_new_none();
                <constant>int</constant> jump <keyword>=</keyword> READ_SHORT(frame);
                frame-&gt;ip += jump;
            } <keyword>else</keyword> {
                frame-&gt;stack[slot + <constant>1</constant>] <keyword>=</keyword> hymn_new_string_value(next-&gt;key);
                frame-&gt;stack[slot + <constant>2</constant>] <keyword>=</keyword> next-&gt;value;
                hymn_reference_string(next-&gt;key);
                hymn_reference(next-&gt;value);
                frame-&gt;ip += <constant>2</constant>;
            }
        } <keyword>else</keyword> <keyword>if</keyword> (hymn_is_array(object)) {
            HymnArray <keyword>*</keyword>array <keyword>=</keyword> hymn_as_array(object);
            <keyword>if</keyword> (array-&gt;length <keyword>==</keyword> <constant>0</constant>) {
                frame-&gt;stack[slot + <constant>1</constant>] <keyword>=</keyword> hymn_new_none();
                frame-&gt;stack[slot + <constant>2</constant>] <keyword>=</keyword> hymn_new_none();
                <constant>int</constant> jump <keyword>=</keyword> READ_SHORT(frame);
                frame-&gt;ip += jump;
            } <keyword>else</keyword> {
                HymnValue item <keyword>=</keyword> array-&gt;items[<constant>0</constant>];
                frame-&gt;stack[slot + <constant>1</constant>] <keyword>=</keyword> hymn_new_<constant>int</constant>(<constant>0</constant>);
                frame-&gt;stack[slot + <constant>2</constant>] <keyword>=</keyword> item;
                hymn_reference(item);
                frame-&gt;ip += <constant>2</constant>;
            }
        } <keyword>else</keyword> {
            frame-&gt;stack[slot + <constant>1</constant>] <keyword>=</keyword> hymn_new_none();
            frame-&gt;stack[slot + <constant>2</constant>] <keyword>=</keyword> hymn_new_none();
            <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>is <keyword>=</keyword> hymn_value_type(object.is);
            THROW(<string>&quot;can't iterate over %s (expected array or table)&quot;</string>, is)
        }
        <keyword>goto</keyword> dispatch;
    }
    <keyword>case</keyword> OP_FOR_LOOP: {
        <constant>int</constant> slot <keyword>=</keyword> READ_BYTE(frame);
        HymnValue object <keyword>=</keyword> frame-&gt;stack[slot];
        <constant>int</constant> index <keyword>=</keyword> slot <keyword>+</keyword> <constant>1</constant>;
        <constant>int</constant> value <keyword>=</keyword> slot <keyword>+</keyword> <constant>2</constant>;
        <keyword>if</keyword> (hymn_is_table(object)) {
            HymnTable <keyword>*</keyword>table <keyword>=</keyword> hymn_as_table(object);
            HymnObjectString <keyword>*</keyword>key <keyword>=</keyword> hymn_as_hymn_string(frame-&gt;stack[index]);
            HymnTableItem <keyword>*</keyword>next <keyword>=</keyword> table_next(table, key);
            <keyword>if</keyword> (next <keyword>==</keyword> <constant>NULL</constant>) {
                frame-&gt;ip += <constant>2</constant>;
            } <keyword>else</keyword> {
                hymn_dereference(H, frame-&gt;stack[index]);
                hymn_dereference(H, frame-&gt;stack[value]);
                frame-&gt;stack[index] = hymn_new_string_value(next-&gt;key);
                frame-&gt;stack[value] = next-&gt;value;
                hymn_reference_string(next-&gt;key);
                hymn_reference(next-&gt;value);
                <constant>int</constant> jump <keyword>=</keyword> READ_SHORT(frame);
                frame-&gt;ip -= jump;
            }
        } <keyword>else</keyword> {
            HymnArray <keyword>*</keyword>array <keyword>=</keyword> hymn_as_array(object);
            HymnInt key <keyword>=</keyword> hymn_as_<constant>int</constant>(frame-&gt;stack[index]) + <constant>1</constant>;
            <keyword>if</keyword> (key <keyword>&gt;</keyword><keyword>=</keyword> array-&gt;length) {
                frame-&gt;ip += <constant>2</constant>;
            } <keyword>else</keyword> {
                hymn_dereference(H, frame-&gt;stack[value]);
                HymnValue item <keyword>=</keyword> array-&gt;items[key];
                frame-&gt;stack[index].as.i++;
                frame-&gt;stack[value] = item;
                hymn_reference(item);
                <constant>int</constant> jump <keyword>=</keyword> READ_SHORT(frame);
                frame-&gt;ip -= jump;
            }
        }
        <keyword>goto</keyword> dispatch;
    }
    <keyword>case</keyword> OP_EQUAL: {
        HymnValue b <keyword>=</keyword> pop(H);
        HymnValue a <keyword>=</keyword> pop(H);
        push(H, hymn_new_<constant>bool</constant>(hymn_values_equal(a, b)));
        hymn_dereference(H, a);
        hymn_dereference(H, b);
        <keyword>goto</keyword> dispatch;
    }
    <keyword>case</keyword> OP_NOT_EQUAL: {
        HymnValue b <keyword>=</keyword> pop(H);
        HymnValue a <keyword>=</keyword> pop(H);
        push(H, hymn_new_<constant>bool</constant>(<keyword>!</keyword>hymn_values_equal(a, b)));
        hymn_dereference(H, a);
        hymn_dereference(H, b);
        <keyword>goto</keyword> dispatch;
    }
    <keyword>case</keyword> OP_LESS: {
        COMPARE_OP(<keyword>&lt;</keyword>)
        <keyword>goto</keyword> dispatch;
    }
    <keyword>case</keyword> OP_LESS_EQUAL: {
        COMPARE_OP(<keyword>&lt;</keyword><keyword>=</keyword>)
        <keyword>goto</keyword> dispatch;
    }
    <keyword>case</keyword> OP_GREATER: {
        COMPARE_OP(<keyword>&gt;</keyword>)
        <keyword>goto</keyword> dispatch;
    }
    <keyword>case</keyword> OP_GREATER_EQUAL: {
        COMPARE_OP(<keyword>&gt;</keyword><keyword>=</keyword>)
        <keyword>goto</keyword> dispatch;
    }
    <keyword>case</keyword> OP_ADD: {
        HymnValue b <keyword>=</keyword> pop(H);
        HymnValue a <keyword>=</keyword> pop(H);
        <keyword>if</keyword> (hymn_is_none(a)) {
            <keyword>if</keyword> (hymn_is_string(b)) {
                push_string(H, value_concat(a, b));
            } <keyword>else</keyword> {
                <keyword>goto</keyword> bad_add;
            }
        } <keyword>else</keyword> <keyword>if</keyword> (hymn_is_<constant>bool</constant>(a)) {
            <keyword>if</keyword> (hymn_is_string(b)) {
                push_string(H, value_concat(a, b));
            } <keyword>else</keyword> {
                <keyword>goto</keyword> bad_add;
            }
        } <keyword>else</keyword> <keyword>if</keyword> (hymn_is_<constant>int</constant>(a)) {
            <keyword>if</keyword> (hymn_is_<constant>int</constant>(b)) {
                a.as.i <keyword>+</keyword><keyword>=</keyword> b.as.i;
                push(H, a);
            } <keyword>else</keyword> <keyword>if</keyword> (hymn_is_<constant>float</constant>(b)) {
                b.as.f <keyword>+</keyword><keyword>=</keyword> (HymnFloat)a.as.i;
                push(H, a);
            } <keyword>else</keyword> <keyword>if</keyword> (hymn_is_string(b)) {
                push_string(H, value_concat(a, b));
            } <keyword>else</keyword> {
                <keyword>goto</keyword> bad_add;
            }
        } <keyword>else</keyword> <keyword>if</keyword> (hymn_is_<constant>float</constant>(a)) {
            <keyword>if</keyword> (hymn_is_<constant>int</constant>(b)) {
                a.as.f <keyword>+</keyword><keyword>=</keyword> (HymnFloat)b.as.i;
                push(H, a);
            } <keyword>else</keyword> <keyword>if</keyword> (hymn_is_<constant>float</constant>(b)) {
                a.as.f <keyword>+</keyword><keyword>=</keyword> b.as.f;
                push(H, a);
            } <keyword>else</keyword> <keyword>if</keyword> (hymn_is_string(b)) {
                push_string(H, value_concat(a, b));
            } <keyword>else</keyword> {
                <keyword>goto</keyword> bad_add;
            }
        } <keyword>else</keyword> <keyword>if</keyword> (hymn_is_string(a)) {
            push_string(H, value_concat(a, b));
        } <keyword>else</keyword> {
            <keyword>goto</keyword> bad_add;
        }
        hymn_dereference(H, a);
        hymn_dereference(H, b);
        <keyword>goto</keyword> dispatch;
    bad_add:;
        <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>is_a <keyword>=</keyword> hymn_value_type(a.is);
        <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>is_b <keyword>=</keyword> hymn_value_type(b.is);
        hymn_dereference(H, a);
        hymn_dereference(H, b);
        THROW(<string>&quot;can't add %s and %s&quot;</string>, is_a, is_b)
    }
    <keyword>case</keyword> OP_ADD_LOCALS: {
        HymnValue a <keyword>=</keyword> frame-&gt;stack[READ_BYTE(frame)];
        HymnValue b <keyword>=</keyword> frame-&gt;stack[READ_BYTE(frame)];
        <keyword>if</keyword> (hymn_is_none(a)) {
            <keyword>if</keyword> (hymn_is_string(b)) {
                push_string(H, value_concat(a, b));
            } <keyword>else</keyword> {
                <keyword>goto</keyword> bad_add_two;
            }
        } <keyword>else</keyword> <keyword>if</keyword> (hymn_is_<constant>bool</constant>(a)) {
            <keyword>if</keyword> (hymn_is_string(b)) {
                push_string(H, value_concat(a, b));
            } <keyword>else</keyword> {
                <keyword>goto</keyword> bad_add_two;
            }
        } <keyword>else</keyword> <keyword>if</keyword> (hymn_is_<constant>int</constant>(a)) {
            <keyword>if</keyword> (hymn_is_<constant>int</constant>(b)) {
                a.as.i <keyword>+</keyword><keyword>=</keyword> b.as.i;
                push(H, a);
            } <keyword>else</keyword> <keyword>if</keyword> (hymn_is_<constant>float</constant>(b)) {
                b.as.f <keyword>+</keyword><keyword>=</keyword> (HymnFloat)a.as.i;
                push(H, a);
            } <keyword>else</keyword> <keyword>if</keyword> (hymn_is_string(b)) {
                push_string(H, value_concat(a, b));
            } <keyword>else</keyword> {
                <keyword>goto</keyword> bad_add_two;
            }
        } <keyword>else</keyword> <keyword>if</keyword> (hymn_is_<constant>float</constant>(a)) {
            <keyword>if</keyword> (hymn_is_<constant>int</constant>(b)) {
                a.as.f <keyword>+</keyword><keyword>=</keyword> (HymnFloat)b.as.i;
                push(H, a);
            } <keyword>else</keyword> <keyword>if</keyword> (hymn_is_<constant>float</constant>(b)) {
                a.as.f <keyword>+</keyword><keyword>=</keyword> b.as.f;
                push(H, a);
            } <keyword>else</keyword> <keyword>if</keyword> (hymn_is_string(b)) {
                push_string(H, value_concat(a, b));
            } <keyword>else</keyword> {
                <keyword>goto</keyword> bad_add_two;
            }
        } <keyword>else</keyword> <keyword>if</keyword> (hymn_is_string(a)) {
            push_string(H, value_concat(a, b));
        } <keyword>else</keyword> {
            <keyword>goto</keyword> bad_add_two;
        }
        <keyword>goto</keyword> dispatch;
    bad_add_two:;
        <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>is_a <keyword>=</keyword> hymn_value_type(a.is);
        <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>is_b <keyword>=</keyword> hymn_value_type(b.is);
        hymn_dereference(H, a);
        hymn_dereference(H, b);
        THROW(<string>&quot;can't add %s and %s&quot;</string>, is_a, is_b)
    }
    <keyword>case</keyword> OP_INCREMENT: {
        HymnValue a <keyword>=</keyword> pop(H);
        HymnInt increment <keyword>=</keyword> READ_BYTE(frame);
        <keyword>if</keyword> (hymn_is_none(a)) {
            <keyword>goto</keyword> bad_increment;
        } <keyword>else</keyword> <keyword>if</keyword> (hymn_is_<constant>bool</constant>(a)) {
            <keyword>goto</keyword> bad_increment;
        } <keyword>else</keyword> <keyword>if</keyword> (hymn_is_<constant>int</constant>(a)) {
            a.as.i <keyword>+</keyword><keyword>=</keyword> increment;
            push(H, a);
        } <keyword>else</keyword> <keyword>if</keyword> (hymn_is_<constant>float</constant>(a)) {
            a.as.f <keyword>+</keyword><keyword>=</keyword> (HymnFloat)increment;
            push(H, a);
        } <keyword>else</keyword> <keyword>if</keyword> (hymn_is_string(a)) {
            push_string(H, value_concat(a, hymn_new_<constant>int</constant>(increment)));
        } <keyword>else</keyword> {
            <keyword>goto</keyword> bad_increment;
        }
        hymn_dereference(H, a);
        <keyword>goto</keyword> dispatch;
    bad_increment:;
        <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>is <keyword>=</keyword> hymn_value_type(a.is);
        hymn_dereference(H, a);
        THROW(<string>&quot;can't increment %s&quot;</string>, is)
    }
    <keyword>case</keyword> OP_SUBTRACT: {
        HymnValue b <keyword>=</keyword> pop(H);
        HymnValue a <keyword>=</keyword> pop(H);
        <keyword>if</keyword> (hymn_is_<constant>int</constant>(a)) {
            <keyword>if</keyword> (hymn_is_<constant>int</constant>(b)) {
                a.as.i <keyword>-</keyword><keyword>=</keyword> b.as.i;
                push(H, a);
            } <keyword>else</keyword> <keyword>if</keyword> (hymn_is_<constant>float</constant>(b)) {
                HymnValue new <keyword>=</keyword> hymn_new_<constant>float</constant>((HymnFloat)a.as.i);
                new.as.f <keyword>-</keyword><keyword>=</keyword> b.as.f;
                push(H, new);
            } <keyword>else</keyword> {
                <keyword>goto</keyword> bad_subtract;
            }
        } <keyword>else</keyword> <keyword>if</keyword> (hymn_is_<constant>float</constant>(a)) {
            <keyword>if</keyword> (hymn_is_<constant>int</constant>(b)) {
                a.as.f <keyword>-</keyword><keyword>=</keyword> (HymnFloat)b.as.i;
                push(H, a);
            } <keyword>else</keyword> <keyword>if</keyword> (hymn_is_<constant>float</constant>(b)) {
                a.as.f <keyword>-</keyword><keyword>=</keyword> b.as.f;
                push(H, a);
            } <keyword>else</keyword> {
                <keyword>goto</keyword> bad_subtract;
            }
        } <keyword>else</keyword> {
            <keyword>goto</keyword> bad_subtract;
        }
        <keyword>goto</keyword> dispatch;
    bad_subtract:;
        <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>is_a <keyword>=</keyword> hymn_value_type(a.is);
        <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>is_b <keyword>=</keyword> hymn_value_type(b.is);
        hymn_dereference(H, a);
        hymn_dereference(H, b);
        THROW(<string>&quot;can't subtract %s and %s (expected numbers)&quot;</string>, is_a, is_b)
    }
    <keyword>case</keyword> OP_MULTIPLY: {
        HymnValue b <keyword>=</keyword> pop(H);
        HymnValue a <keyword>=</keyword> pop(H);
        <keyword>if</keyword> (hymn_is_<constant>int</constant>(a)) {
            <keyword>if</keyword> (hymn_is_<constant>int</constant>(b)) {
                a.as.i <keyword>*</keyword><keyword>=</keyword> b.as.i;
                push(H, a);
            } <keyword>else</keyword> <keyword>if</keyword> (hymn_is_<constant>float</constant>(b)) {
                HymnValue new <keyword>=</keyword> hymn_new_<constant>float</constant>((HymnFloat)a.as.i);
                new.as.f <keyword>*</keyword><keyword>=</keyword> b.as.f;
                push(H, new);
            } <keyword>else</keyword> {
                <keyword>goto</keyword> bad_multiply;
            }
        } <keyword>else</keyword> <keyword>if</keyword> (hymn_is_<constant>float</constant>(a)) {
            <keyword>if</keyword> (hymn_is_<constant>int</constant>(b)) {
                a.as.f <keyword>*</keyword><keyword>=</keyword> (HymnFloat)b.as.i;
                push(H, a);
            } <keyword>else</keyword> <keyword>if</keyword> (hymn_is_<constant>float</constant>(b)) {
                a.as.f <keyword>*</keyword><keyword>=</keyword> b.as.f;
                push(H, a);
            } <keyword>else</keyword> {
                <keyword>goto</keyword> bad_multiply;
            }
        } <keyword>else</keyword> {
            <keyword>goto</keyword> bad_multiply;
        }
        <keyword>goto</keyword> dispatch;
    bad_multiply:;
        <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>is_a <keyword>=</keyword> hymn_value_type(a.is);
        <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>is_b <keyword>=</keyword> hymn_value_type(b.is);
        hymn_dereference(H, a);
        hymn_dereference(H, b);
        THROW(<string>&quot;can't multiply %s and %s (expected numbers)&quot;</string>, is_a, is_b)
    }
    <keyword>case</keyword> OP_DIVIDE: {
        HymnValue b <keyword>=</keyword> pop(H);
        HymnValue a <keyword>=</keyword> pop(H);
        <keyword>if</keyword> (hymn_is_<constant>int</constant>(a)) {
            <keyword>if</keyword> (hymn_is_<constant>int</constant>(b)) {
                a.as.i <keyword>/</keyword><keyword>=</keyword> b.as.i;
                push(H, a);
            } <keyword>else</keyword> <keyword>if</keyword> (hymn_is_<constant>float</constant>(b)) {
                HymnValue new <keyword>=</keyword> hymn_new_<constant>float</constant>((HymnFloat)a.as.i);
                new.as.f <keyword>/</keyword><keyword>=</keyword> b.as.f;
                push(H, new);
            } <keyword>else</keyword> {
                <keyword>goto</keyword> bad_divide;
            }
        } <keyword>else</keyword> <keyword>if</keyword> (hymn_is_<constant>float</constant>(a)) {
            <keyword>if</keyword> (hymn_is_<constant>int</constant>(b)) {
                a.as.f <keyword>/</keyword><keyword>=</keyword> (HymnFloat)b.as.i;
                push(H, a);
            } <keyword>else</keyword> <keyword>if</keyword> (hymn_is_<constant>float</constant>(b)) {
                a.as.f <keyword>/</keyword><keyword>=</keyword> b.as.f;
                push(H, a);
            } <keyword>else</keyword> {
                <keyword>goto</keyword> bad_divide;
            }
        } <keyword>else</keyword> {
            <keyword>goto</keyword> bad_divide;
        }
        <keyword>goto</keyword> dispatch;
    bad_divide:;
        <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>is_a <keyword>=</keyword> hymn_value_type(a.is);
        <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>is_b <keyword>=</keyword> hymn_value_type(b.is);
        hymn_dereference(H, a);
        hymn_dereference(H, b);
        THROW(<string>&quot;can't divide %s and %s (expected numbers)&quot;</string>, is_a, is_b)
    }
    <keyword>case</keyword> OP_MODULO: {
        HymnValue b <keyword>=</keyword> pop(H);
        HymnValue a <keyword>=</keyword> pop(H);
        <keyword>if</keyword> (hymn_is_<constant>int</constant>(a)) {
            <keyword>if</keyword> (hymn_is_<constant>int</constant>(b)) {
                a.as.i %<keyword>=</keyword> b.as.i;
                push(H, a);
            } <keyword>else</keyword> {
                <keyword>goto</keyword> bad_modulo;
            }
        } <keyword>else</keyword> {
            <keyword>goto</keyword> bad_modulo;
        }
        <keyword>goto</keyword> dispatch;
    bad_modulo:;
        <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>is_a <keyword>=</keyword> hymn_value_type(a.is);
        <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>is_b <keyword>=</keyword> hymn_value_type(b.is);
        hymn_dereference(H, a);
        hymn_dereference(H, b);
        THROW(<string>&quot;can't modulo %s and %s (expected integers)&quot;</string>, is_a, is_b)
    }
    <keyword>case</keyword> OP_MODULO_LOCALS: {
        HymnValue a <keyword>=</keyword> frame-&gt;stack[READ_BYTE(frame)];
        HymnValue b <keyword>=</keyword> frame-&gt;stack[READ_BYTE(frame)];
        <keyword>if</keyword> (hymn_is_<constant>int</constant>(a)) {
            <keyword>if</keyword> (hymn_is_<constant>int</constant>(b)) {
                a.as.i %<keyword>=</keyword> b.as.i;
                push(H, a);
            } <keyword>else</keyword> {
                <keyword>goto</keyword> bad_modulo_locals;
            }
        } <keyword>else</keyword> {
            <keyword>goto</keyword> bad_modulo_locals;
        }
        <keyword>goto</keyword> dispatch;
    bad_modulo_locals:;
        <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>is_a <keyword>=</keyword> hymn_value_type(a.is);
        <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>is_b <keyword>=</keyword> hymn_value_type(b.is);
        THROW(<string>&quot;can't modulo %s and %s (expected integers)&quot;</string>, is_a, is_b)
    }
    <keyword>case</keyword> OP_BIT_NOT: {
        HymnValue value <keyword>=</keyword> pop(H);
        <keyword>if</keyword> (hymn_is_<constant>int</constant>(value)) {
            value.as.i <keyword>=</keyword> <keyword>~</keyword>value.as.i;
            push(H, value);
        } <keyword>else</keyword> {
            <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>is <keyword>=</keyword> hymn_value_type(value.is);
            hymn_dereference(H, value);
            THROW(<string>&quot;bitwise '~' can't use %s (expected integer)&quot;</string>, is)
        }
        <keyword>goto</keyword> dispatch;
    }
    <keyword>case</keyword> OP_BIT_OR: {
        HymnValue b <keyword>=</keyword> pop(H);
        HymnValue a <keyword>=</keyword> pop(H);
        <keyword>if</keyword> (hymn_is_<constant>int</constant>(a) <keyword>&</keyword><keyword>&</keyword> hymn_is_<constant>int</constant>(b)) {
            a.as.i |<keyword>=</keyword> b.as.i;
            push(H, a);
        } <keyword>else</keyword> {
            <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>is_a <keyword>=</keyword> hymn_value_type(a.is);
            <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>is_b <keyword>=</keyword> hymn_value_type(b.is);
            hymn_dereference(H, a);
            hymn_dereference(H, b);
            THROW(<string>&quot;bitwise '|' can't use %s and %s (expected integers)&quot;</string>, is_a, is_b)
        }
        <keyword>goto</keyword> dispatch;
    }
    <keyword>case</keyword> OP_BIT_AND: {
        HymnValue b <keyword>=</keyword> pop(H);
        HymnValue a <keyword>=</keyword> pop(H);
        <keyword>if</keyword> (hymn_is_<constant>int</constant>(a) <keyword>&</keyword><keyword>&</keyword> hymn_is_<constant>int</constant>(b)) {
            a.as.i <keyword>&</keyword><keyword>=</keyword> b.as.i;
            push(H, a);
        } <keyword>else</keyword> {
            <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>is_a <keyword>=</keyword> hymn_value_type(a.is);
            <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>is_b <keyword>=</keyword> hymn_value_type(b.is);
            hymn_dereference(H, a);
            hymn_dereference(H, b);
            THROW(<string>&quot;bitwise '&' can't use %s and %s (expected integers)&quot;</string>, is_a, is_b)
        }
        <keyword>goto</keyword> dispatch;
    }
    <keyword>case</keyword> OP_BIT_XOR: {
        HymnValue b <keyword>=</keyword> pop(H);
        HymnValue a <keyword>=</keyword> pop(H);
        <keyword>if</keyword> (hymn_is_<constant>int</constant>(a) <keyword>&</keyword><keyword>&</keyword> hymn_is_<constant>int</constant>(b)) {
            a.as.i <keyword>^</keyword><keyword>=</keyword> b.as.i;
            push(H, a);
        } <keyword>else</keyword> {
            <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>is_a <keyword>=</keyword> hymn_value_type(a.is);
            <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>is_b <keyword>=</keyword> hymn_value_type(b.is);
            hymn_dereference(H, a);
            hymn_dereference(H, b);
            THROW(<string>&quot;bitwise '^' can't use %s and %s (expected integers)&quot;</string>, is_a, is_b)
        }
        <keyword>goto</keyword> dispatch;
    }
    <keyword>case</keyword> OP_BIT_LEFT_SHIFT: {
        HymnValue b <keyword>=</keyword> pop(H);
        HymnValue a <keyword>=</keyword> pop(H);
        <keyword>if</keyword> (hymn_is_<constant>int</constant>(a) <keyword>&</keyword><keyword>&</keyword> hymn_is_<constant>int</constant>(b)) {
            a.as.i <keyword>&lt;&lt;</keyword><keyword>=</keyword> b.as.i;
            push(H, a);
        } <keyword>else</keyword> {
            <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>is_a <keyword>=</keyword> hymn_value_type(a.is);
            <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>is_b <keyword>=</keyword> hymn_value_type(b.is);
            hymn_dereference(H, a);
            hymn_dereference(H, b);
            THROW(<string>&quot;bitwise '&lt;&lt;' can't use %s and %s (expected integers)&quot;</string>, is_a, is_b)
        }
        <keyword>goto</keyword> dispatch;
    }
    <keyword>case</keyword> OP_BIT_RIGHT_SHIFT: {
        HymnValue b <keyword>=</keyword> pop(H);
        HymnValue a <keyword>=</keyword> pop(H);
        <keyword>if</keyword> (hymn_is_<constant>int</constant>(a) <keyword>&</keyword><keyword>&</keyword> hymn_is_<constant>int</constant>(b)) {
            a.as.i <keyword>&gt;&gt;</keyword><keyword>=</keyword> b.as.i;
            push(H, a);
        } <keyword>else</keyword> {
            <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>is_a <keyword>=</keyword> hymn_value_type(a.is);
            <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>is_b <keyword>=</keyword> hymn_value_type(b.is);
            hymn_dereference(H, a);
            hymn_dereference(H, b);
            THROW(<string>&quot;bitwise '&gt;&gt;' can't use %s and %s (expected integers)&quot;</string>, is_a, is_b)
        }
        <keyword>goto</keyword> dispatch;
    }
    <keyword>case</keyword> OP_NEGATE: {
        HymnValue value <keyword>=</keyword> pop(H);
        <keyword>if</keyword> (hymn_is_<constant>int</constant>(value)) {
            value.as.i <keyword>=</keyword> <keyword>-</keyword>value.as.i;
        } <keyword>else</keyword> <keyword>if</keyword> (hymn_is_<constant>float</constant>(value)) {
            value.as.f <keyword>=</keyword> <keyword>-</keyword>value.as.f;
        } <keyword>else</keyword> {
            <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>is <keyword>=</keyword> hymn_value_type(value.is);
            hymn_dereference(H, value);
            THROW(<string>&quot;negation '-' can't use %s (expected number)&quot;</string>, is)
        }
        push(H, value);
        <keyword>goto</keyword> dispatch;
    }
    <keyword>case</keyword> OP_NOT: {
        HymnValue value <keyword>=</keyword> pop(H);
        <keyword>if</keyword> (hymn_is_<constant>bool</constant>(value)) {
            value.as.b <keyword>=</keyword> <keyword>!</keyword>value.as.b;
        } <keyword>else</keyword> {
            <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>is <keyword>=</keyword> hymn_value_type(value.is);
            hymn_dereference(H, value);
            THROW(<string>&quot;not '!' can't use %s (expected boolean)&quot;</string>, is)
        }
        push(H, value);
        <keyword>goto</keyword> dispatch;
    }
    <keyword>case</keyword> OP_CONSTANT: {
        HymnValue constant <keyword>=</keyword> READ_CONSTANT(frame);
        hymn_reference(constant);
        push(H, constant);
        <keyword>goto</keyword> dispatch;
    }
    <keyword>case</keyword> OP_NEW_ARRAY: {
        HymnValue constant <keyword>=</keyword> hymn_new_array_value(hymn_new_array(<constant>0</constant>));
        hymn_reference(constant);
        push(H, constant);
        <keyword>goto</keyword> dispatch;
    }
    <keyword>case</keyword> OP_NEW_TABLE: {
        HymnValue constant <keyword>=</keyword> hymn_new_table_value(hymn_new_table());
        hymn_reference(constant);
        push(H, constant);
        <keyword>goto</keyword> dispatch;
    }
    <keyword>case</keyword> OP_DEFINE_GLOBAL: {
        HymnObjectString <keyword>*</keyword>name <keyword>=</keyword> hymn_as_hymn_string(READ_CONSTANT(frame));
        HymnValue value <keyword>=</keyword> pop(H);
        HymnValue previous <keyword>=</keyword> table_put(<keyword>&</keyword>H-&gt;globals, name, value);
        <keyword>if</keyword> (hymn_is_undefined(previous)) {
            hymn_reference_string(name);
        } <keyword>else</keyword> {
            table_put(<keyword>&</keyword>H-&gt;globals, name, previous);
            hymn_dereference(H, value);
            THROW(<string>&quot;multiple global definitions of '%s'&quot;</string>, name-&gt;string)
        }
        <keyword>goto</keyword> dispatch;
    }
    <keyword>case</keyword> OP_SET_GLOBAL: {
        HymnObjectString <keyword>*</keyword>name <keyword>=</keyword> hymn_as_hymn_string(READ_CONSTANT(frame));
        HymnValue value <keyword>=</keyword> peek(H, <constant>1</constant>);
        HymnValue previous <keyword>=</keyword> table_put(<keyword>&</keyword>H-&gt;globals, name, value);
        <keyword>if</keyword> (hymn_is_undefined(previous)) {
            hymn_reference_string(name);
        } <keyword>else</keyword> {
            hymn_dereference(H, previous);
        }
        hymn_reference(value);
        <keyword>goto</keyword> dispatch;
    }
    <keyword>case</keyword> OP_GET_GLOBAL: {
        HymnObjectString <keyword>*</keyword>name <keyword>=</keyword> hymn_as_hymn_string(READ_CONSTANT(frame));
        HymnValue get <keyword>=</keyword> table_get(<keyword>&</keyword>H-&gt;globals, name);
        <keyword>if</keyword> (hymn_is_undefined(get)) {
            THROW(<string>&quot;undefined global '%s'&quot;</string>, name-&gt;string)
        }
        hymn_reference(get);
        push(H, get);
        <keyword>goto</keyword> dispatch;
    }
    <keyword>case</keyword> OP_GET_GLOBAL_PROPERTY: {
        HymnObjectString <keyword>*</keyword>name <keyword>=</keyword> hymn_as_hymn_string(READ_CONSTANT(frame));
        HymnObjectString <keyword>*</keyword>property <keyword>=</keyword> hymn_as_hymn_string(READ_CONSTANT(frame));
        HymnValue global <keyword>=</keyword> table_get(<keyword>&</keyword>H-&gt;globals, name);
        <keyword>if</keyword> (hymn_is_undefined(global)) {
            THROW(<string>&quot;undefined global '%s'&quot;</string>, name-&gt;string)
        } <keyword>else</keyword> <keyword>if</keyword> (<keyword>!</keyword>hymn_is_table(global)) {
            <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>is <keyword>=</keyword> hymn_value_type(global.is);
            THROW(<string>&quot;can't get property of %s (expected table)&quot;</string>, is)
        }
        HymnTable <keyword>*</keyword>table <keyword>=</keyword> hymn_as_table(global);
        HymnValue get <keyword>=</keyword> table_get(table, property);
        <keyword>if</keyword> (hymn_is_undefined(get)) {
            get.is <keyword>=</keyword> HYMN_VALUE_NONE;
        } <keyword>else</keyword> {
            hymn_reference(get);
        }
        push(H, get);
        <keyword>goto</keyword> dispatch;
    }
    <keyword>case</keyword> OP_SET_LOCAL: {
        <constant>int</constant> slot <keyword>=</keyword> READ_BYTE(frame);
        HymnValue value <keyword>=</keyword> peek(H, <constant>1</constant>);
        hymn_dereference(H, frame-&gt;stack[slot]);
        frame-&gt;stack[slot] = value;
        hymn_reference(value);
        <keyword>goto</keyword> dispatch;
    }
    <keyword>case</keyword> OP_GET_LOCAL: {
        <constant>int</constant> slot <keyword>=</keyword> READ_BYTE(frame);
        HymnValue value <keyword>=</keyword> frame-&gt;stack[slot];
        hymn_reference(value);
        push(H, value);
        <keyword>goto</keyword> dispatch;
    }
    <keyword>case</keyword> OP_GET_LOCALS: {
        <constant>int</constant> slot_a <keyword>=</keyword> READ_BYTE(frame);
        <constant>int</constant> slot_b <keyword>=</keyword> READ_BYTE(frame);
        HymnValue value_a <keyword>=</keyword> frame-&gt;stack[slot_a];
        HymnValue value_b <keyword>=</keyword> frame-&gt;stack[slot_b];
        hymn_reference(value_a);
        hymn_reference(value_b);
        push(H, value_a);
        push(H, value_b);
        <keyword>goto</keyword> dispatch;
    }
    <keyword>case</keyword> OP_INCREMENT_LOCAL: {
        <constant>int</constant> slot <keyword>=</keyword> READ_BYTE(frame);
        <constant>int</constant> increment <keyword>=</keyword> READ_BYTE(frame);
        HymnValue value <keyword>=</keyword> frame-&gt;stack[slot];
        <keyword>if</keyword> (hymn_is_<constant>int</constant>(value)) {
            value.as.i <keyword>+</keyword><keyword>=</keyword> (HymnInt)increment;
        } <keyword>else</keyword> <keyword>if</keyword> (hymn_is_<constant>float</constant>(value)) {
            value.as.f <keyword>+</keyword><keyword>=</keyword> (HymnFloat)increment;
        } <keyword>else</keyword> {
            <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>is <keyword>=</keyword> hymn_value_type(value.is);
            THROW(<string>&quot;can't increment %s (expected number)&quot;</string>, is)
        }
        push(H, value);
        <keyword>goto</keyword> dispatch;
    }
    <keyword>case</keyword> OP_INCREMENT_LOCAL_AND_SET: {
        <constant>int</constant> slot <keyword>=</keyword> READ_BYTE(frame);
        <constant>int</constant> increment <keyword>=</keyword> READ_BYTE(frame);
        HymnValue value <keyword>=</keyword> frame-&gt;stack[slot];
        <keyword>if</keyword> (hymn_is_<constant>int</constant>(value)) {
            value.as.i <keyword>+</keyword><keyword>=</keyword> (HymnInt)increment;
        } <keyword>else</keyword> <keyword>if</keyword> (hymn_is_<constant>float</constant>(value)) {
            value.as.f <keyword>+</keyword><keyword>=</keyword> (HymnFloat)increment;
        } <keyword>else</keyword> {
            <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>is <keyword>=</keyword> hymn_value_type(value.is);
            THROW(<string>&quot;can't increment %s (expected number)&quot;</string>, is)
        }
        frame-&gt;stack[slot] = value;
        <keyword>goto</keyword> dispatch;
    }
    <keyword>case</keyword> OP_SET_PROPERTY: {
        HymnValue value <keyword>=</keyword> pop(H);
        HymnValue table_value <keyword>=</keyword> pop(H);
        <keyword>if</keyword> (<keyword>!</keyword>hymn_is_table(table_value)) {
            <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>is <keyword>=</keyword> hymn_value_type(table_value.is);
            hymn_dereference(H, value);
            hymn_dereference(H, table_value);
            THROW(<string>&quot;can't set property of %s (expected table)&quot;</string>, is)
        }
        HymnTable <keyword>*</keyword>table <keyword>=</keyword> hymn_as_table(table_value);
        HymnObjectString <keyword>*</keyword>name <keyword>=</keyword> hymn_as_hymn_string(READ_CONSTANT(frame));
        hymn_set_property(H, table, name, value);
        push(H, value);
        hymn_dereference(H, table_value);
        <keyword>goto</keyword> dispatch;
    }
    <keyword>case</keyword> OP_GET_PROPERTY: {
        HymnValue value <keyword>=</keyword> pop(H);
        <keyword>if</keyword> (<keyword>!</keyword>hymn_is_table(value)) {
            <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>is <keyword>=</keyword> hymn_value_type(value.is);
            hymn_dereference(H, value);
            THROW(<string>&quot;can't get property of %s (expected table)&quot;</string>, is)
        }
        HymnTable <keyword>*</keyword>table <keyword>=</keyword> hymn_as_table(value);
        HymnObjectString <keyword>*</keyword>name <keyword>=</keyword> hymn_as_hymn_string(READ_CONSTANT(frame));
        HymnValue get <keyword>=</keyword> table_get(table, name);
        <keyword>if</keyword> (hymn_is_undefined(get)) {
            get.is <keyword>=</keyword> HYMN_VALUE_NONE;
        } <keyword>else</keyword> {
            hymn_reference(get);
        }
        hymn_dereference(H, value);
        push(H, get);
        <keyword>goto</keyword> dispatch;
    }
    <keyword>case</keyword> OP_EXISTS: {
        HymnValue value <keyword>=</keyword> pop(H);
        HymnValue object <keyword>=</keyword> pop(H);
        <keyword>if</keyword> (<keyword>!</keyword>hymn_is_table(object)) {
            <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>is <keyword>=</keyword> hymn_value_type(object.is);
            hymn_dereference(H, value);
            hymn_dereference(H, object);
            THROW(<string>&quot;call to 'exists' can't use %s for 1st argument (expected table)&quot;</string>, is)
        }
        <keyword>if</keyword> (<keyword>!</keyword>hymn_is_string(value)) {
            <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>is <keyword>=</keyword> hymn_value_type(value.is);
            hymn_dereference(H, value);
            hymn_dereference(H, object);
            THROW(<string>&quot;call to 'exists' can't use %s for 2nd argument (expected string)&quot;</string>, is)
        }
        HymnTable <keyword>*</keyword>table <keyword>=</keyword> hymn_as_table(object);
        HymnObjectString <keyword>*</keyword>name <keyword>=</keyword> hymn_as_hymn_string(value);
        HymnValue g <keyword>=</keyword> table_get(table, name);
        <keyword>if</keyword> (hymn_is_undefined(g)) {
            push(H, hymn_new_<constant>bool</constant>(<constant>false</constant>));
        } <keyword>else</keyword> {
            push(H, hymn_new_<constant>bool</constant>(<constant>true</constant>));
        }
        hymn_dereference(H, value);
        hymn_dereference(H, object);
        <keyword>goto</keyword> dispatch;
    }
    <keyword>case</keyword> OP_SET_DYNAMIC: {
        HymnValue value <keyword>=</keyword> pop(H);
        HymnValue property <keyword>=</keyword> pop(H);
        HymnValue object <keyword>=</keyword> pop(H);
        <keyword>if</keyword> (hymn_is_array(object)) {
            <keyword>if</keyword> (<keyword>!</keyword>hymn_is_<constant>int</constant>(property)) {
                <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>is <keyword>=</keyword> hymn_value_type(property.is);
                hymn_dereference(H, value);
                hymn_dereference(H, property);
                hymn_dereference(H, object);
                THROW(<string>&quot;array assignment index can't be %s (expected integer)&quot;</string>, is)
            }
            HymnArray <keyword>*</keyword>array <keyword>=</keyword> hymn_as_array(object);
            HymnInt size <keyword>=</keyword> array-&gt;length;
            HymnInt index <keyword>=</keyword> hymn_as_<constant>int</constant>(property);
            <keyword>if</keyword> (index <keyword>&gt;</keyword> size) {
                hymn_dereference(H, value);
                hymn_dereference(H, property);
                hymn_dereference(H, object);
                THROW(<string>&quot;array assignment index out of bounds: %d &gt; %d&quot;</string>, index, size)
            }
            <keyword>if</keyword> (index <keyword>&lt;</keyword> <constant>0</constant>) {
                index <keyword>=</keyword> size <keyword>+</keyword> index;
                <keyword>if</keyword> (index <keyword>&lt;</keyword> <constant>0</constant>) {
                    hymn_dereference(H, value);
                    hymn_dereference(H, property);
                    hymn_dereference(H, object);
                    THROW(<string>&quot;negative array assignment index: %d&quot;</string>, index)
                }
            }
            <keyword>if</keyword> (index <keyword>==</keyword> size) {
                hymn_array_push(array, value);
            } <keyword>else</keyword> {
                hymn_dereference(H, array-&gt;items[index]);
                array-&gt;items[index] = value;
            }
        } <keyword>else</keyword> <keyword>if</keyword> (hymn_is_table(object)) {
            <keyword>if</keyword> (<keyword>!</keyword>hymn_is_string(property)) {
                <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>is <keyword>=</keyword> hymn_value_type(property.is);
                hymn_dereference(H, value);
                hymn_dereference(H, property);
                hymn_dereference(H, object);
                THROW(<string>&quot;table assignment key can't be %s (expected string)&quot;</string>, is)
            }
            HymnTable <keyword>*</keyword>table <keyword>=</keyword> hymn_as_table(object);
            HymnObjectString <keyword>*</keyword>name <keyword>=</keyword> hymn_as_hymn_string(property);
            HymnValue previous <keyword>=</keyword> table_put(table, name, value);
            <keyword>if</keyword> (hymn_is_undefined(previous)) {
                hymn_reference_string(name);
            } <keyword>else</keyword> {
                hymn_dereference(H, previous);
            }
        } <keyword>else</keyword> {
            <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>is <keyword>=</keyword> hymn_value_type(object.is);
            hymn_dereference(H, value);
            hymn_dereference(H, property);
            hymn_dereference(H, object);
            THROW(<string>&quot;can't assign value to %s (expected array or table)&quot;</string>, is)
        }
        push(H, value);
        hymn_dereference(H, object);
        hymn_reference(value);
        <keyword>goto</keyword> dispatch;
    }
    <keyword>case</keyword> OP_GET_DYNAMIC: {
        HymnValue i <keyword>=</keyword> pop(H);
        HymnValue v <keyword>=</keyword> pop(H);
        <keyword>switch</keyword> (v.is) {
        <keyword>case</keyword> HYMN_VALUE_STRING: {
            <keyword>if</keyword> (<keyword>!</keyword>hymn_is_<constant>int</constant>(i)) {
                <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>is <keyword>=</keyword> hymn_value_type(i.is);
                hymn_dereference(H, i);
                hymn_dereference(H, v);
                THROW(<string>&quot;string index can't be %s (expected integer)&quot;</string>, is)
            }
            HymnString <keyword>*</keyword>string <keyword>=</keyword> hymn_as_string(v);
            HymnInt size <keyword>=</keyword> (HymnInt)hymn_string_len(string);
            HymnInt index <keyword>=</keyword> hymn_as_<constant>int</constant>(i);
            <keyword>if</keyword> (index <keyword>&gt;</keyword><keyword>=</keyword> size) {
                hymn_dereference(H, i);
                hymn_dereference(H, v);
                THROW(<string>&quot;string index out of bounds: %d &gt;= %d&quot;</string>, index, size)
            }
            <keyword>if</keyword> (index <keyword>&lt;</keyword> <constant>0</constant>) {
                index <keyword>=</keyword> size <keyword>+</keyword> index;
                <keyword>if</keyword> (index <keyword>&lt;</keyword> <constant>0</constant>) {
                    hymn_dereference(H, i);
                    hymn_dereference(H, v);
                    THROW(<string>&quot;negative string index: %d&quot;</string>, index)
                }
            }
            <constant>char</constant> c <keyword>=</keyword> string[index];
            push_string(H, <constant>char</constant>_to_string(c));
            hymn_dereference(H, v);
            <keyword>break</keyword>;
        }
        <keyword>case</keyword> HYMN_VALUE_ARRAY: {
            <keyword>if</keyword> (<keyword>!</keyword>hymn_is_<constant>int</constant>(i)) {
                <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>is <keyword>=</keyword> hymn_value_type(i.is);
                hymn_dereference(H, i);
                hymn_dereference(H, v);
                THROW(<string>&quot;array index can't be %s (expected integer)&quot;</string>, is)
            }
            HymnArray <keyword>*</keyword>array <keyword>=</keyword> hymn_as_array(v);
            HymnInt size <keyword>=</keyword> array-&gt;length;
            HymnInt index <keyword>=</keyword> hymn_as_<constant>int</constant>(i);
            <keyword>if</keyword> (index <keyword>&gt;</keyword><keyword>=</keyword> size) {
                hymn_dereference(H, i);
                hymn_dereference(H, v);
                THROW(<string>&quot;array index out of bounds: %d &gt;= %d&quot;</string>, index, size)
            }
            <keyword>if</keyword> (index <keyword>&lt;</keyword> <constant>0</constant>) {
                index <keyword>=</keyword> size <keyword>+</keyword> index;
                <keyword>if</keyword> (index <keyword>&lt;</keyword> <constant>0</constant>) {
                    hymn_dereference(H, i);
                    hymn_dereference(H, v);
                    THROW(<string>&quot;negative array index: %d&quot;</string>, index)
                }
            }
            HymnValue g <keyword>=</keyword> hymn_array_get(array, index);
            hymn_reference(g);
            push(H, g);
            hymn_dereference(H, v);
            <keyword>break</keyword>;
        }
        <keyword>case</keyword> HYMN_VALUE_TABLE: {
            <keyword>if</keyword> (<keyword>!</keyword>hymn_is_string(i)) {
                <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>is <keyword>=</keyword> hymn_value_type(i.is);
                hymn_dereference(H, i);
                hymn_dereference(H, v);
                THROW(<string>&quot;table key can't be %s (expected string)&quot;</string>, is)
            }
            HymnTable <keyword>*</keyword>table <keyword>=</keyword> hymn_as_table(v);
            HymnObjectString <keyword>*</keyword>name <keyword>=</keyword> hymn_as_hymn_string(i);
            HymnValue g <keyword>=</keyword> table_get(table, name);
            <keyword>if</keyword> (hymn_is_undefined(g)) {
                g.is <keyword>=</keyword> HYMN_VALUE_NONE;
            } <keyword>else</keyword> {
                hymn_reference(g);
            }
            push(H, g);
            hymn_dereference(H, i);
            hymn_dereference(H, v);
            <keyword>break</keyword>;
        }
        <keyword>default</keyword>: {
            <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>is <keyword>=</keyword> hymn_value_type(v.is);
            hymn_dereference(H, i);
            hymn_dereference(H, v);
            THROW(<string>&quot;can't get value from %s (expected array, table, or string)&quot;</string>, is)
        }
        }
        <keyword>goto</keyword> dispatch;
    }
    <keyword>case</keyword> OP_LEN: {
        HymnValue value <keyword>=</keyword> pop(H);
        <keyword>switch</keyword> (value.is) {
        <keyword>case</keyword> HYMN_VALUE_STRING: {
            HymnInt len <keyword>=</keyword> (HymnInt)hymn_string_len(hymn_as_string(value));
            push(H, hymn_new_<constant>int</constant>(len));
            <keyword>break</keyword>;
        }
        <keyword>case</keyword> HYMN_VALUE_ARRAY: {
            HymnInt len <keyword>=</keyword> hymn_as_array(value)<keyword>-&gt;</keyword>length;
            push(H, hymn_new_<constant>int</constant>(len));
            <keyword>break</keyword>;
        }
        <keyword>case</keyword> HYMN_VALUE_TABLE: {
            HymnInt len <keyword>=</keyword> (HymnInt)hymn_as_table(value)<keyword>-&gt;</keyword>size;
            push(H, hymn_new_<constant>int</constant>(len));
            <keyword>break</keyword>;
        }
        <keyword>default</keyword>: {
            <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>is <keyword>=</keyword> hymn_value_type(value.is);
            hymn_dereference(H, value);
            THROW(<string>&quot;call to 'len' can't use %s (expected array, string, or table)&quot;</string>, is)
        }
        }
        hymn_dereference(H, value);
        <keyword>goto</keyword> dispatch;
    }
    <keyword>case</keyword> OP_ARRAY_POP: {
        HymnValue a <keyword>=</keyword> pop(H);
        <keyword>if</keyword> (<keyword>!</keyword>hymn_is_array(a)) {
            <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>is <keyword>=</keyword> hymn_value_type(a.is);
            hymn_dereference(H, a);
            THROW(<string>&quot;call to 'pop' can't use %s (expected array)&quot;</string>, is)
        } <keyword>else</keyword> {
            HymnValue value <keyword>=</keyword> hymn_array_pop(hymn_as_array(a));
            push(H, value);
            hymn_dereference(H, a);
        }
        <keyword>goto</keyword> dispatch;
    }
    <keyword>case</keyword> OP_ARRAY_PUSH: {
        HymnValue value <keyword>=</keyword> pop(H);
        HymnValue array <keyword>=</keyword> pop(H);
        <keyword>if</keyword> (<keyword>!</keyword>hymn_is_array(array)) {
            <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>is <keyword>=</keyword> hymn_value_type(array.is);
            hymn_dereference(H, array);
            hymn_dereference(H, value);
            THROW(<string>&quot;call to 'push' can't use %s for 1st argument (expected array)&quot;</string>, is)
        } <keyword>else</keyword> {
            hymn_array_push(hymn_as_array(array), value);
            hymn_dereference(H, array);
        }
        <keyword>goto</keyword> dispatch;
    }
    <keyword>case</keyword> OP_ARRAY_PUSH_LOCALS: {
        HymnValue array <keyword>=</keyword> frame-&gt;stack[READ_BYTE(frame)];
        <keyword>if</keyword> (<keyword>!</keyword>hymn_is_array(array)) {
            <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>is <keyword>=</keyword> hymn_value_type(array.is);
            THROW(<string>&quot;call to 'push' can't use %s for 1st argument (expected array)&quot;</string>, is)
        } <keyword>else</keyword> {
            HymnValue value <keyword>=</keyword> frame-&gt;stack[READ_BYTE(frame)];
            hymn_array_push(hymn_as_array(array), value);
        }
        <keyword>goto</keyword> dispatch;
    }
    <keyword>case</keyword> OP_INSERT: {
        HymnValue p <keyword>=</keyword> pop(H);
        HymnValue i <keyword>=</keyword> pop(H);
        HymnValue v <keyword>=</keyword> pop(H);
        <keyword>if</keyword> (hymn_is_array(v)) {
            <keyword>if</keyword> (<keyword>!</keyword>hymn_is_<constant>int</constant>(i)) {
                <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>is <keyword>=</keyword> hymn_value_type(i.is);
                hymn_dereference(H, p);
                hymn_dereference(H, i);
                hymn_dereference(H, v);
                THROW(<string>&quot;call to 'insert' can't use %s for 2nd argument (expected integer)&quot;</string>, is)
            }
            HymnArray <keyword>*</keyword>array <keyword>=</keyword> hymn_as_array(v);
            HymnInt size <keyword>=</keyword> array-&gt;length;
            HymnInt index <keyword>=</keyword> hymn_as_<constant>int</constant>(i);
            <keyword>if</keyword> (index <keyword>&gt;</keyword> size) {
                hymn_dereference(H, p);
                hymn_dereference(H, i);
                hymn_dereference(H, v);
                THROW(<string>&quot;index out of bounds in call to 'insert': %d &gt; %d&quot;</string>, index, size)
            }
            <keyword>if</keyword> (index <keyword>&lt;</keyword> <constant>0</constant>) {
                index <keyword>=</keyword> size <keyword>+</keyword> index;
                <keyword>if</keyword> (index <keyword>&lt;</keyword> <constant>0</constant>) {
                    hymn_dereference(H, p);
                    hymn_dereference(H, i);
                    hymn_dereference(H, v);
                    THROW(<string>&quot;negative index in 'insert' call: %d&quot;</string>, index)
                }
            }
            <keyword>if</keyword> (index <keyword>==</keyword> size) {
                hymn_array_push(array, p);
            } <keyword>else</keyword> {
                hymn_array_insert(array, index, p);
            }
            hymn_dereference(H, v);
        } <keyword>else</keyword> {
            <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>is <keyword>=</keyword> hymn_value_type(v.is);
            hymn_dereference(H, p);
            hymn_dereference(H, i);
            hymn_dereference(H, v);
            THROW(<string>&quot;call to 'insert' can't use %s for 1st argument (expected array)&quot;</string>, is)
        }
        <keyword>goto</keyword> dispatch;
    }
    <keyword>case</keyword> OP_DELETE: {
        HymnValue i <keyword>=</keyword> pop(H);
        HymnValue v <keyword>=</keyword> pop(H);
        <keyword>if</keyword> (hymn_is_array(v)) {
            <keyword>if</keyword> (<keyword>!</keyword>hymn_is_<constant>int</constant>(i)) {
                <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>is <keyword>=</keyword> hymn_value_type(i.is);
                hymn_dereference(H, i);
                hymn_dereference(H, v);
                THROW(<string>&quot;call to 'delete' can't use %s for 2nd argument (expected integer)&quot;</string>, is)
            }
            HymnArray <keyword>*</keyword>array <keyword>=</keyword> hymn_as_array(v);
            HymnInt size <keyword>=</keyword> array-&gt;length;
            HymnInt index <keyword>=</keyword> hymn_as_<constant>int</constant>(i);
            <keyword>if</keyword> (index <keyword>&gt;</keyword><keyword>=</keyword> size) {
                hymn_dereference(H, i);
                hymn_dereference(H, v);
                THROW(<string>&quot;index out of bounds in call to 'delete': %d &gt;= %d.&quot;</string>, index, size)
            }
            <keyword>if</keyword> (index <keyword>&lt;</keyword> <constant>0</constant>) {
                index <keyword>=</keyword> size <keyword>+</keyword> index;
                <keyword>if</keyword> (index <keyword>&lt;</keyword> <constant>0</constant>) {
                    hymn_dereference(H, i);
                    hymn_dereference(H, v);
                    THROW(<string>&quot;negative index in 'delete' call: %d&quot;</string>, index)
                }
            }
            HymnValue value <keyword>=</keyword> hymn_array_remove_index(array, index);
            push(H, value);
            hymn_dereference(H, v);
        } <keyword>else</keyword> <keyword>if</keyword> (hymn_is_table(v)) {
            <keyword>if</keyword> (<keyword>!</keyword>hymn_is_string(i)) {
                <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>is <keyword>=</keyword> hymn_value_type(i.is);
                hymn_dereference(H, i);
                hymn_dereference(H, v);
                THROW(<string>&quot;call to 'delete' can't use %s for 2nd argument (expected string)&quot;</string>, is)
            }
            HymnTable <keyword>*</keyword>table <keyword>=</keyword> hymn_as_table(v);
            HymnObjectString <keyword>*</keyword>name <keyword>=</keyword> hymn_as_hymn_string(i);
            HymnValue value <keyword>=</keyword> table_remove(table, name);
            <keyword>if</keyword> (hymn_is_undefined(value)) {
                value.is <keyword>=</keyword> HYMN_VALUE_NONE;
            } <keyword>else</keyword> {
                hymn_dereference_string(H, name);
            }
            push(H, value);
            hymn_dereference(H, v);
            hymn_dereference_string(H, name);
        } <keyword>else</keyword> {
            <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>is <keyword>=</keyword> hymn_value_type(v.is);
            hymn_dereference(H, i);
            hymn_dereference(H, v);
            THROW(<string>&quot;call to 'delete' can't use %s for 1st argument (expected array or table)&quot;</string>, is)
        }
        <keyword>goto</keyword> dispatch;
    }
    <keyword>case</keyword> OP_COPY: {
        HymnValue value <keyword>=</keyword> pop(H);
        <keyword>switch</keyword> (value.is) {
        <keyword>case</keyword> HYMN_VALUE_NONE:
        <keyword>case</keyword> HYMN_VALUE_BOOL:
        <keyword>case</keyword> HYMN_VALUE_INTEGER:
        <keyword>case</keyword> HYMN_VALUE_FLOAT:
        <keyword>case</keyword> HYMN_VALUE_STRING:
        <keyword>case</keyword> HYMN_VALUE_FUNC:
        <keyword>case</keyword> HYMN_VALUE_FUNC_NATIVE:
            push(H, value);
            <keyword>break</keyword>;
        <keyword>case</keyword> HYMN_VALUE_ARRAY: {
            HymnArray <keyword>*</keyword>copy <keyword>=</keyword> new_array_copy(hymn_as_array(value));
            HymnValue new <keyword>=</keyword> hymn_new_array_value(copy);
            push(H, new);
            hymn_reference(new);
            hymn_dereference(H, value);
            <keyword>break</keyword>;
        }
        <keyword>case</keyword> HYMN_VALUE_TABLE: {
            HymnTable <keyword>*</keyword>copy <keyword>=</keyword> new_table_copy(hymn_as_table(value));
            HymnValue new <keyword>=</keyword> hymn_new_table_value(copy);
            push(H, new);
            hymn_reference(new);
            hymn_dereference(H, value);
            <keyword>break</keyword>;
        }
        <keyword>default</keyword>:
            push(H, hymn_new_none());
        }
        <keyword>goto</keyword> dispatch;
    }
    <keyword>case</keyword> OP_SLICE: {
        HymnValue b <keyword>=</keyword> pop(H);
        HymnValue a <keyword>=</keyword> pop(H);
        HymnValue v <keyword>=</keyword> pop(H);
        <keyword>if</keyword> (<keyword>!</keyword>hymn_is_<constant>int</constant>(a)) {
            <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>is <keyword>=</keyword> hymn_value_type(a.is);
            hymn_dereference(H, a);
            hymn_dereference(H, b);
            hymn_dereference(H, v);
            THROW(<string>&quot;slice can't use %s (expected integer)&quot;</string>, is)
        }
        HymnInt start <keyword>=</keyword> hymn_as_<constant>int</constant>(a);
        <keyword>if</keyword> (start <keyword>&lt;</keyword> <constant>0</constant>) {
            hymn_dereference(H, a);
            hymn_dereference(H, b);
            hymn_dereference(H, v);
            THROW(<string>&quot;negative slice start: %d&quot;</string>, start)
        }
        <keyword>if</keyword> (hymn_is_string(v)) {
            HymnString <keyword>*</keyword>original <keyword>=</keyword> hymn_as_string(v);
            HymnInt size <keyword>=</keyword> (HymnInt)hymn_string_len(original);
            HymnInt end;
            <keyword>if</keyword> (hymn_is_<constant>int</constant>(b)) {
                end <keyword>=</keyword> hymn_as_<constant>int</constant>(b);
            } <keyword>else</keyword> <keyword>if</keyword> (hymn_is_none(b)) {
                end <keyword>=</keyword> size;
            } <keyword>else</keyword> {
                <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>is <keyword>=</keyword> hymn_value_type(b.is);
                hymn_dereference(H, a);
                hymn_dereference(H, b);
                hymn_dereference(H, v);
                THROW(<string>&quot;slice can't use %s (expected integer)&quot;</string>, is)
            }
            <keyword>if</keyword> (end <keyword>&gt;</keyword> size) {
                hymn_dereference(H, a);
                hymn_dereference(H, b);
                hymn_dereference(H, v);
                THROW(<string>&quot;slice out of bounds: %d &gt; %d&quot;</string>, end, size)
            }
            <keyword>if</keyword> (end <keyword>&lt;</keyword> <constant>0</constant>) {
                end <keyword>=</keyword> size <keyword>+</keyword> end;
                <keyword>if</keyword> (end <keyword>&lt;</keyword> <constant>0</constant>) {
                    hymn_dereference(H, a);
                    hymn_dereference(H, b);
                    hymn_dereference(H, v);
                    THROW(<string>&quot;negative slice end: %d&quot;</string>, end)
                }
            }
            <keyword>if</keyword> (start <keyword>&gt;</keyword><keyword>=</keyword> end) {
                hymn_dereference(H, a);
                hymn_dereference(H, b);
                hymn_dereference(H, v);
                THROW(<string>&quot;slice out of range: %d &gt;= %d&quot;</string>, start, end)
            }
            HymnString <keyword>*</keyword>sub <keyword>=</keyword> hymn_substring(original, (<constant>size_t</constant>)start, (<constant>size_t</constant>)end);
            push_string(H, sub);
        } <keyword>else</keyword> <keyword>if</keyword> (hymn_is_array(v)) {
            HymnArray <keyword>*</keyword>array <keyword>=</keyword> hymn_as_array(v);
            HymnInt size <keyword>=</keyword> array-&gt;length;
            HymnInt end;
            <keyword>if</keyword> (hymn_is_<constant>int</constant>(b)) {
                end <keyword>=</keyword> hymn_as_<constant>int</constant>(b);
            } <keyword>else</keyword> <keyword>if</keyword> (hymn_is_none(b)) {
                end <keyword>=</keyword> size;
            } <keyword>else</keyword> {
                <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>is <keyword>=</keyword> hymn_value_type(b.is);
                hymn_dereference(H, a);
                hymn_dereference(H, b);
                hymn_dereference(H, v);
                THROW(<string>&quot;slice can't use %s (expected integer)&quot;</string>, is)
            }
            <keyword>if</keyword> (end <keyword>&gt;</keyword> size) {
                hymn_dereference(H, a);
                hymn_dereference(H, b);
                hymn_dereference(H, v);
                THROW(<string>&quot;slice out of bounds: %d &gt; %d&quot;</string>, end, size)
            }
            <keyword>if</keyword> (end <keyword>&lt;</keyword> <constant>0</constant>) {
                end <keyword>=</keyword> size <keyword>+</keyword> end;
                <keyword>if</keyword> (end <keyword>&lt;</keyword> <constant>0</constant>) {
                    hymn_dereference(H, a);
                    hymn_dereference(H, b);
                    hymn_dereference(H, v);
                    THROW(<string>&quot;negative slice end: %d&quot;</string>, end)
                }
            }
            <keyword>if</keyword> (start <keyword>&gt;</keyword><keyword>=</keyword> end) {
                hymn_dereference(H, a);
                hymn_dereference(H, b);
                hymn_dereference(H, v);
                THROW(<string>&quot;slice out of range: %d &gt;= %d&quot;</string>, start, end)
            }
            HymnArray <keyword>*</keyword>copy <keyword>=</keyword> new_array_slice(array, start, end);
            HymnValue new <keyword>=</keyword> hymn_new_array_value(copy);
            hymn_reference(new);
            push(H, new);
        } <keyword>else</keyword> {
            <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>is <keyword>=</keyword> hymn_value_type(v.is);
            hymn_dereference(H, a);
            hymn_dereference(H, b);
            hymn_dereference(H, v);
            THROW(<string>&quot;can't slice %s (expected string or array)&quot;</string>, is)
        }
        hymn_dereference(H, v);
        <keyword>goto</keyword> dispatch;
    }
    <keyword>case</keyword> OP_CLEAR: {
        HymnValue value <keyword>=</keyword> pop(H);
        <keyword>switch</keyword> (value.is) {
        <keyword>case</keyword> HYMN_VALUE_BOOL:
            push(H, hymn_new_<constant>bool</constant>(<constant>false</constant>));
            <keyword>break</keyword>;
        <keyword>case</keyword> HYMN_VALUE_INTEGER:
            push(H, hymn_new_<constant>int</constant>(<constant>0</constant>));
            <keyword>break</keyword>;
        <keyword>case</keyword> HYMN_VALUE_FLOAT:
            push(H, hymn_new_<constant>float</constant>(<constant>0.0</constant>));
            <keyword>break</keyword>;
        <keyword>case</keyword> HYMN_VALUE_STRING:
            push_string(H, hymn_new_string(<string>&quot;&quot;</string>));
            <keyword>break</keyword>;
        <keyword>case</keyword> HYMN_VALUE_ARRAY: {
            HymnArray <keyword>*</keyword>array <keyword>=</keyword> hymn_as_array(value);
            hymn_array_clear(H, array);
            push(H, value);
            <keyword>break</keyword>;
        }
        <keyword>case</keyword> HYMN_VALUE_TABLE: {
            HymnTable <keyword>*</keyword>table <keyword>=</keyword> hymn_as_table(value);
            table_clear(H, table);
            push(H, value);
            <keyword>break</keyword>;
        }
        <keyword>case</keyword> HYMN_VALUE_UNDEFINED:
        <keyword>case</keyword> HYMN_VALUE_NONE:
        <keyword>case</keyword> HYMN_VALUE_FUNC:
        <keyword>case</keyword> HYMN_VALUE_FUNC_NATIVE:
        <keyword>case</keyword> HYMN_VALUE_POINTER:
            push(H, hymn_new_none());
            <keyword>break</keyword>;
        <keyword>default</keyword>:
            <keyword>break</keyword>;
        }
        <keyword>goto</keyword> dispatch;
    }
    <keyword>case</keyword> OP_KEYS: {
        HymnValue value <keyword>=</keyword> pop(H);
        <keyword>if</keyword> (<keyword>!</keyword>hymn_is_table(value)) {
            <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>is <keyword>=</keyword> hymn_value_type(value.is);
            hymn_dereference(H, value);
            THROW(<string>&quot;call to 'keys' can't use %s (expected table)&quot;</string>, is)
        } <keyword>else</keyword> {
            HymnTable <keyword>*</keyword>table <keyword>=</keyword> hymn_as_table(value);
            HymnArray <keyword>*</keyword>array <keyword>=</keyword> table_keys(table);
            HymnValue keys <keyword>=</keyword> hymn_new_array_value(array);
            hymn_reference(keys);
            push(H, keys);
            hymn_dereference(H, value);
        }
        <keyword>goto</keyword> dispatch;
    }
    <keyword>case</keyword> OP_INDEX: {
        HymnValue b <keyword>=</keyword> pop(H);
        HymnValue a <keyword>=</keyword> pop(H);
        <keyword>switch</keyword> (a.is) {
        <keyword>case</keyword> HYMN_VALUE_STRING: {
            <keyword>if</keyword> (<keyword>!</keyword>hymn_is_string(b)) {
                <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>is <keyword>=</keyword> hymn_value_type(b.is);
                hymn_dereference(H, a);
                hymn_dereference(H, b);
                THROW(<string>&quot;call to 'index' can't use %s for 2nd argument (expected string)&quot;</string>, is)
            }
            <constant>size_t</constant> index <keyword>=</keyword> <constant>0</constant>;
            <constant>bool</constant> found <keyword>=</keyword> string_find(hymn_as_string(a), hymn_as_string(b), <keyword>&</keyword>index);
            <keyword>if</keyword> (found) {
                push(H, hymn_new_<constant>int</constant>((HymnInt)index));
            } <keyword>else</keyword> {
                push(H, hymn_new_<constant>int</constant>(<keyword>-</keyword><constant>1</constant>));
            }
            hymn_dereference(H, a);
            hymn_dereference(H, b);
            <keyword>break</keyword>;
        }
        <keyword>case</keyword> HYMN_VALUE_ARRAY:
            push(H, hymn_new_<constant>int</constant>(hymn_array_index_of(hymn_as_array(a), b)));
            hymn_dereference(H, a);
            hymn_dereference(H, b);
            <keyword>break</keyword>;
        <keyword>case</keyword> HYMN_VALUE_TABLE: {
            HymnObjectString <keyword>*</keyword>key <keyword>=</keyword> table_key_of(hymn_as_table(a), b);
            <keyword>if</keyword> (key <keyword>==</keyword> <constant>NULL</constant>) {
                push(H, hymn_new_none());
            } <keyword>else</keyword> {
                push(H, hymn_new_string_value(key));
            }
            hymn_dereference(H, a);
            hymn_dereference(H, b);
            <keyword>break</keyword>;
        }
        <keyword>default</keyword>: {
            <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>is <keyword>=</keyword> hymn_value_type(a.is);
            hymn_dereference(H, a);
            hymn_dereference(H, b);
            THROW(<string>&quot;call to 'index' can't use %s for 1st argument (expected string, array, or table)&quot;</string>, is)
        }
        }
        <keyword>goto</keyword> dispatch;
    }
    <keyword>case</keyword> OP_TYPE: {
        HymnValue value <keyword>=</keyword> pop(H);
        <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>is <keyword>=</keyword> hymn_value_type(value.is);
        push_string(H, hymn_new_string(is));
        hymn_dereference(H, value);
        <keyword>goto</keyword> dispatch;
    }
    <keyword>case</keyword> OP_INT: {
        HymnValue value <keyword>=</keyword> pop(H);
        <keyword>if</keyword> (hymn_is_<constant>int</constant>(value)) {
            push(H, value);
        } <keyword>else</keyword> <keyword>if</keyword> (hymn_is_<constant>float</constant>(value)) {
            HymnInt number <keyword>=</keyword> (HymnInt)hymn_as_<constant>float</constant>(value);
            push(H, hymn_new_<constant>int</constant>(number));
        } <keyword>else</keyword> <keyword>if</keyword> (hymn_is_string(value)) {
            HymnString <keyword>*</keyword>string <keyword>=</keyword> hymn_as_string(value);
            <constant>char</constant> <keyword>*</keyword>end <keyword>=</keyword> <constant>NULL</constant>;
            <constant>double</constant> number <keyword>=</keyword> strtod(string, <keyword>&</keyword>end);
            <keyword>if</keyword> (string <keyword>==</keyword> end) {
                push(H, hymn_new_none());
            } <keyword>else</keyword> {
                push(H, hymn_new_<constant>int</constant>((HymnInt)number));
            }
            hymn_dereference(H, value);
        } <keyword>else</keyword> {
            <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>is <keyword>=</keyword> hymn_value_type(value.is);
            hymn_dereference(H, value);
            THROW(<string>&quot;can't cast %s to integer&quot;</string>, is)
        }
        <keyword>goto</keyword> dispatch;
    }
    <keyword>case</keyword> OP_FLOAT: {
        HymnValue value <keyword>=</keyword> pop(H);
        <keyword>if</keyword> (hymn_is_<constant>int</constant>(value)) {
            HymnFloat number <keyword>=</keyword> (HymnFloat)hymn_as_<constant>int</constant>(value);
            push(H, hymn_new_<constant>float</constant>(number));
        } <keyword>else</keyword> <keyword>if</keyword> (hymn_is_<constant>float</constant>(value)) {
            push(H, value);
        } <keyword>else</keyword> <keyword>if</keyword> (hymn_is_string(value)) {
            HymnString <keyword>*</keyword>string <keyword>=</keyword> hymn_as_string(value);
            <constant>char</constant> <keyword>*</keyword>end <keyword>=</keyword> <constant>NULL</constant>;
            <constant>double</constant> number <keyword>=</keyword> strtod(string, <keyword>&</keyword>end);
            <keyword>if</keyword> (string <keyword>==</keyword> end) {
                push(H, hymn_new_none());
            } <keyword>else</keyword> {
                push(H, hymn_new_<constant>float</constant>(number));
            }
            hymn_dereference(H, value);
        } <keyword>else</keyword> {
            <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>is <keyword>=</keyword> hymn_value_type(value.is);
            hymn_dereference(H, value);
            THROW(<string>&quot;can't cast %s to float&quot;</string>, is)
        }
        <keyword>goto</keyword> dispatch;
    }
    <keyword>case</keyword> OP_STRING: {
        HymnValue value <keyword>=</keyword> pop(H);
        push_string(H, hymn_value_to_string(value));
        hymn_dereference(H, value);
        <keyword>goto</keyword> dispatch;
    }
    <keyword>case</keyword> OP_ECHO: {
        HymnValue value <keyword>=</keyword> pop(H);
        HymnString <keyword>*</keyword>string <keyword>=</keyword> hymn_value_to_string(value);
        H-&gt;print(<string>&quot;%s\n&quot;</string>, string);
        hymn_string_delete(string);
        hymn_dereference(H, value);
        <keyword>goto</keyword> dispatch;
    }
    <keyword>case</keyword> OP_PRINT: {
        HymnValue value <keyword>=</keyword> pop(H);
        HymnValue route <keyword>=</keyword> pop(H);
        HymnString <keyword>*</keyword>string <keyword>=</keyword> hymn_value_to_string(value);
        <keyword>if</keyword> (hymn_value_<constant>false</constant>(route)) {
            H-&gt;print(<string>&quot;%s&quot;</string>, string);
        } <keyword>else</keyword> {
            H-&gt;print_error(<string>&quot;%s&quot;</string>, string);
        }
        hymn_string_delete(string);
        hymn_dereference(H, value);
        hymn_dereference(H, route);
        <keyword>goto</keyword> dispatch;
    }
    <keyword>case</keyword> OP_INSPECT: {
        HymnValue value <keyword>=</keyword> pop(H);
        HymnString <keyword>*</keyword>inspect <keyword>=</keyword> <constant>NULL</constant>;
        <keyword>if</keyword> (hymn_is_func(value)) {
            HymnFunction <keyword>*</keyword>func <keyword>=</keyword> hymn_as_func(value);
            <keyword>if</keyword> (func-&gt;source <keyword>!=</keyword> <constant>NULL</constant>) inspect <keyword>=</keyword> hymn_string_copy(func-&gt;source);
        }
        <keyword>if</keyword> (inspect <keyword>==</keyword> <constant>NULL</constant>) inspect <keyword>=</keyword> hymn_value_to_string(value);
        push_string(H, inspect);
        hymn_dereference(H, value);
        <keyword>goto</keyword> dispatch;
    }
    <keyword>case</keyword> OP_DEBUG: {
        HymnValue value <keyword>=</keyword> pop(H);
        HymnString <keyword>*</keyword>debug <keyword>=</keyword> <constant>NULL</constant>;
        <keyword>if</keyword> (hymn_is_func(value)) {
            HymnFunction <keyword>*</keyword>func <keyword>=</keyword> hymn_as_func(value);
            debug <keyword>=</keyword> disassemble_byte_code(<keyword>&</keyword>func-&gt;code);
        }
        <keyword>if</keyword> (debug <keyword>==</keyword> <constant>NULL</constant>) debug <keyword>=</keyword> hymn_value_to_string(value);
        push_string(H, debug);
        hymn_dereference(H, value);
        <keyword>goto</keyword> dispatch;
    }
    <keyword>case</keyword> OP_THROW: {
        frame <keyword>=</keyword> exception(H);
        <keyword>if</keyword> (frame <keyword>==</keyword> <constant>NULL</constant>) <keyword>return</keyword>;
        <keyword>goto</keyword> dispatch;
    }
    <keyword>case</keyword> OP_DUPLICATE: {
        HymnValue top <keyword>=</keyword> peek(H, <constant>1</constant>);
        push(H, top);
        hymn_reference(top);
        <keyword>goto</keyword> dispatch;
    }
    <keyword>case</keyword> OP_USE: {
        HymnValue file <keyword>=</keyword> pop(H);
        <keyword>if</keyword> (hymn_is_string(file)) {
            frame <keyword>=</keyword> import(H, hymn_as_hymn_string(file));
            hymn_dereference(H, file);
            <keyword>if</keyword> (frame <keyword>==</keyword> <constant>NULL</constant>) <keyword>return</keyword>;
        } <keyword>else</keyword> {
            <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>is <keyword>=</keyword> hymn_value_type(file.is);
            hymn_dereference(H, file);
            THROW(<string>&quot;import can't use %s (expected string)&quot;</string>, is)
        }
        <keyword>goto</keyword> dispatch;
    }
    <keyword>default</keyword>:
        UNREACHABLE();
    }
}

<keyword>static</keyword> <constant>char</constant> <keyword>*</keyword>interpret(Hymn <keyword>*</keyword>H) {
    run(H);
    <constant>char</constant> <keyword>*</keyword>error <keyword>=</keyword> <constant>NULL</constant>;
    <keyword>if</keyword> (H-&gt;error) {
        error <keyword>=</keyword> string_to_chars(H-&gt;error);
        hymn_string_delete(H-&gt;error);
        H-&gt;error = <constant>NULL</constant>;
    }
    <keyword>return</keyword> error;
}

<keyword>static</keyword> <constant>void</constant> print_stdout(<keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>format, ...) {
    va_list args;

    va_start(args, format);
    vprintf(format, args);
    va_end(args);
}

<keyword>static</keyword> <constant>void</constant> print_stderr(<keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>format, ...) {
    va_list args;

    va_start(args, format);
    vfprintf(stderr, format, args);
    va_end(args);
}

Hymn <keyword>*</keyword>new_hymn(<constant>void</constant>) {
    Hymn <keyword>*</keyword>H <keyword>=</keyword> hymn_calloc(<constant>1</constant>, sizeof(Hymn));
    reset_stack(H);

<comment>    // STRINGS</comment>

    set_init(<keyword>&</keyword>H-&gt;strings);

    HymnObjectString <keyword>*</keyword>search_this <keyword>=</keyword> hymn_new_intern_string(H, <string>&quot;&lt;parent&gt;&quot;</string> PATH_SEP_STRING <string>&quot;&lt;path&gt;.hm&quot;</string>);
    hymn_reference_string(search_this);

    HymnObjectString <keyword>*</keyword>search_relative <keyword>=</keyword> hymn_new_intern_string(H, <string>&quot;.&quot;</string> PATH_SEP_STRING <string>&quot;&lt;path&gt;.hm&quot;</string>);
    hymn_reference_string(search_relative);

    HymnObjectString <keyword>*</keyword>search_libs <keyword>=</keyword> hymn_new_intern_string(H, <string>&quot;.&quot;</string> PATH_SEP_STRING <string>&quot;libs&quot;</string> PATH_SEP_STRING <string>&quot;&lt;path&gt;.hm&quot;</string>);
    hymn_reference_string(search_libs);

<comment>    // GLOBALS</comment>

    table_init(<keyword>&</keyword>H-&gt;globals);

    HymnObjectString <keyword>*</keyword>globals <keyword>=</keyword> hymn_new_intern_string(H, <string>&quot;GLOBALS&quot;</string>);
    hymn_reference_string(globals);

    HymnValue globals_value <keyword>=</keyword> hymn_new_table_value(<keyword>&</keyword>H-&gt;globals);
    table_put(<keyword>&</keyword>H-&gt;globals, globals, globals_value);
    hymn_reference_string(globals);
    hymn_reference(globals_value);
    hymn_reference(globals_value);

<comment>    // PATHS</comment>

    H-&gt;paths = hymn_new_array(<constant>3</constant>);

    HymnObjectString <keyword>*</keyword>paths <keyword>=</keyword> hymn_new_intern_string(H, <string>&quot;PATHS&quot;</string>);
    hymn_reference_string(paths);

    H-&gt;paths-&gt;items[<constant>0</constant>] <keyword>=</keyword> hymn_new_string_value(search_this);
    H-&gt;paths-&gt;items[<constant>1</constant>] <keyword>=</keyword> hymn_new_string_value(search_relative);
    H-&gt;paths-&gt;items[<constant>2</constant>] <keyword>=</keyword> hymn_new_string_value(search_libs);

    HymnValue paths_value <keyword>=</keyword> hymn_new_array_value(H-&gt;paths);
    table_put(<keyword>&</keyword>H-&gt;globals, paths, paths_value);
    hymn_reference_string(paths);
    hymn_reference(paths_value);
    hymn_reference(paths_value);

<comment>    // IMPORTS</comment>

    H-&gt;imports = hymn_new_table();

    HymnObjectString <keyword>*</keyword>imports <keyword>=</keyword> hymn_new_intern_string(H, <string>&quot;IMPORTS&quot;</string>);
    hymn_reference_string(imports);

    HymnValue imports_value <keyword>=</keyword> hymn_new_table_value(H-&gt;imports);
    table_put(<keyword>&</keyword>H-&gt;globals, imports, imports_value);
    hymn_reference_string(imports);
    hymn_reference(imports_value);
    hymn_reference(imports_value);

    H-&gt;print = print_stdout;
    H-&gt;print_error = print_stderr;

    <keyword>return</keyword> H;
}

<constant>void</constant> hymn_delete(Hymn <keyword>*</keyword>H) {
    {
        HymnTable <keyword>*</keyword>globals_table <keyword>=</keyword> <keyword>&</keyword>H-&gt;globals;
        HymnObjectString <keyword>*</keyword>globals <keyword>=</keyword> hymn_new_intern_string(H, <string>&quot;GLOBALS&quot;</string>);
        table_remove(globals_table, globals);
        hymn_dereference_string(H, globals);

        table_release(H, globals_table);
        assert(globals_table-&gt;size <keyword>==</keyword> <constant>0</constant>);
    }

    hymn_array_delete(H, H-&gt;paths);
    table_delete(H, H-&gt;imports);

    HymnSet <keyword>*</keyword>strings <keyword>=</keyword> <keyword>&</keyword>H-&gt;strings;
    {
        <keyword>unsigned</keyword> <constant>int</constant> bins <keyword>=</keyword> strings-&gt;bins;
        <keyword>for</keyword> (<keyword>unsigned</keyword> <constant>int</constant> i <keyword>=</keyword> <constant>0</constant>; i <keyword>&lt;</keyword> bins; i++) {
            HymnSetItem <keyword>*</keyword>item <keyword>=</keyword> strings-&gt;items[i];
            <keyword>while</keyword> (item <keyword>!=</keyword> <constant>NULL</constant>) {
                HymnSetItem <keyword>*</keyword>next <keyword>=</keyword> item-&gt;next;
                hymn_dereference_string(H, item-&gt;string);
                item <keyword>=</keyword> next;
            }
        }
    }
<constant>#ifdef</constant> HYMN_DEBUG_MEMORY
    {
        <keyword>unsigned</keyword> <constant>int</constant> bins <keyword>=</keyword> strings-&gt;bins;
        <keyword>for</keyword> (<keyword>unsigned</keyword> <constant>int</constant> i <keyword>=</keyword> <constant>0</constant>; i <keyword>&lt;</keyword> bins; i++) {
            HymnSetItem <keyword>*</keyword>item <keyword>=</keyword> strings-&gt;items[i];
            <keyword>while</keyword> (item <keyword>!=</keyword> <constant>NULL</constant>) {
                <constant>fprintf</constant>(stderr, <string>&quot;ENDING STRING REFERENCE: %s\n&quot;</string>, item-&gt;string-&gt;string);
                item <keyword>=</keyword> item-&gt;next;
            }
        }
    }
<constant>#endif</constant>
    assert(strings-&gt;size <keyword>==</keyword> <constant>0</constant>);
    <constant>free</constant>(strings-&gt;items);

    hymn_string_delete(H-&gt;error);

<constant>#ifndef</constant> HYMN_NO_DYNAMIC_LIBS
    HymnLibList <keyword>*</keyword>lib <keyword>=</keyword> H-&gt;libraries;
    <keyword>while</keyword> (lib <keyword>!=</keyword> <constant>NULL</constant>) {
        hymn_close_dlib(lib-&gt;lib);
        HymnLibList <keyword>*</keyword>next <keyword>=</keyword> lib-&gt;next;
        <constant>free</constant>(lib);
        lib <keyword>=</keyword> next;
    }
<constant>#endif</constant>

    <constant>free</constant>(H);
}

HymnValue hymn_get(Hymn <keyword>*</keyword>H, <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>name) {
    <keyword>return</keyword> hymn_table_get(<keyword>&</keyword>H-&gt;globals, name);
}

<constant>void</constant> hymn_add(Hymn <keyword>*</keyword>H, <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>name, HymnValue value) {
    HymnObjectString <keyword>*</keyword>string <keyword>=</keyword> hymn_new_intern_string(H, name);
    HymnValue previous <keyword>=</keyword> table_put(<keyword>&</keyword>H-&gt;globals, string, value);
    <keyword>if</keyword> (hymn_is_undefined(previous)) {
        hymn_reference_string(string);
    } <keyword>else</keyword> {
        hymn_dereference(H, previous);
    }
    hymn_reference(value);
}

<constant>void</constant> hymn_add_string(Hymn <keyword>*</keyword>H, <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>name, <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>string) {
    HymnObjectString <keyword>*</keyword>object <keyword>=</keyword> hymn_new_intern_string(H, string);
    hymn_add(H, name, hymn_new_string_value(object));
}

<constant>void</constant> hymn_add_table(Hymn <keyword>*</keyword>H, <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>name, HymnTable <keyword>*</keyword>table) {
    hymn_add(H, name, hymn_new_table_value(table));
}

<constant>void</constant> hymn_add_pointer(Hymn <keyword>*</keyword>H, <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>name, <constant>void</constant> <keyword>*</keyword>pointer) {
    hymn_add(H, name, hymn_new_pointer(pointer));
}

<constant>void</constant> hymn_add_string_to_table(Hymn <keyword>*</keyword>H, HymnTable <keyword>*</keyword>table, <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>name, <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>string) {
    HymnObjectString <keyword>*</keyword>object <keyword>=</keyword> hymn_new_intern_string(H, string);
    hymn_set_property_<keyword>const</keyword>(H, table, name, hymn_new_string_value(object));
}

<constant>void</constant> hymn_add_function_to_table(Hymn <keyword>*</keyword>H, HymnTable <keyword>*</keyword>table, <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>name, HymnNativeCall func) {
    HymnObjectString <keyword>*</keyword>string <keyword>=</keyword> hymn_new_intern_string(H, name);
    HymnNativeFunction <keyword>*</keyword>native <keyword>=</keyword> new_native_function(string, func);
    HymnValue value <keyword>=</keyword> hymn_new_native(native);
    hymn_set_property(H, table, string, value);
}

<constant>void</constant> hymn_add_function(Hymn <keyword>*</keyword>H, <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>name, HymnNativeCall func) {
    hymn_add_function_to_table(H, <keyword>&</keyword>H-&gt;globals, name, func);
}

<constant>char</constant> <keyword>*</keyword>hymn_call(Hymn <keyword>*</keyword>H, <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>name, <constant>int</constant> arguments) {
    HymnValue function <keyword>=</keyword> hymn_table_get(<keyword>&</keyword>H-&gt;globals, name);
    <keyword>if</keyword> (hymn_is_undefined(function)) {
        <keyword>return</keyword> <constant>NULL</constant>;
    }
    hymn_reference(function);

    push(H, function);
    call_value(H, function, arguments);

    <constant>char</constant> <keyword>*</keyword>error <keyword>=</keyword> interpret(H);
    <keyword>if</keyword> (error) {
        <keyword>return</keyword> error;
    }

    assert(H-&gt;stack_top <keyword>==</keyword> H-&gt;stack);
    reset_stack(H);

    <keyword>return</keyword> <constant>NULL</constant>;
}

<constant>char</constant> <keyword>*</keyword>hymn_debug(Hymn <keyword>*</keyword>H, <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>script, <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>source) {
    HymnString <keyword>*</keyword>code <keyword>=</keyword> <constant>NULL</constant>;
    <keyword>if</keyword> (source <keyword>==</keyword> <constant>NULL</constant>) {
        code <keyword>=</keyword> hymn_read_file(script);
        <keyword>if</keyword> (code <keyword>==</keyword> <constant>NULL</constant>) {
            HymnString <keyword>*</keyword>format <keyword>=</keyword> hymn_string_format(<string>&quot;file not found: %s\n&quot;</string>, script);
            <constant>char</constant> <keyword>*</keyword>error <keyword>=</keyword> string_to_chars(format);
            hymn_string_delete(format);
            <keyword>return</keyword> error;
        }
    } <keyword>else</keyword> {
        code <keyword>=</keyword> hymn_new_string(source);
    }

    CompileResult result <keyword>=</keyword> compile(H, script, code, TYPE_SCRIPT);

    <constant>char</constant> <keyword>*</keyword>error <keyword>=</keyword> result.error;
    <keyword>if</keyword> (error) {
        hymn_string_delete(code);
        <keyword>return</keyword> error;
    }

    HymnFunction <keyword>*</keyword>main <keyword>=</keyword> result.func;

    HymnString <keyword>*</keyword>debug <keyword>=</keyword> disassemble_byte_code(<keyword>&</keyword>main-&gt;code);
    <constant>printf</constant>(<string>&quot;\n-- %s --\n%s\n&quot;</string>, script <keyword>!=</keyword> <constant>NULL</constant> ? script : <string>&quot;script&quot;</string>, debug);
    hymn_string_delete(debug);

    HymnValuePool <keyword>*</keyword>constants <keyword>=</keyword> <keyword>&</keyword>main-&gt;code.constants;
    <constant>int</constant> count <keyword>=</keyword> constants-&gt;count;
    HymnValue <keyword>*</keyword>values <keyword>=</keyword> constants-&gt;values;

    <keyword>for</keyword> (<constant>int</constant> i <keyword>=</keyword> <constant>0</constant>; i <keyword>&lt;</keyword> count; i++) {
        HymnValue value <keyword>=</keyword> values[i];
        <keyword>if</keyword> (hymn_is_func(value)) {
            HymnFunction <keyword>*</keyword>func <keyword>=</keyword> hymn_as_func(value);
            debug <keyword>=</keyword> disassemble_byte_code(<keyword>&</keyword>func-&gt;code);
            <constant>printf</constant>(<string>&quot;\n-- %s --\n%s\n&quot;</string>, func-&gt;name <keyword>!=</keyword> <constant>NULL</constant> ? func-&gt;name : <string>&quot;script&quot;</string>, debug);
            hymn_string_delete(debug);
        }
    }

    <keyword>for</keyword> (<constant>int</constant> i <keyword>=</keyword> <constant>0</constant>; i <keyword>&lt;</keyword> count; i++) {
        HymnValue value <keyword>=</keyword> values[i];
        <keyword>if</keyword> (hymn_is_func(value)) {
            HymnFunction <keyword>*</keyword>func <keyword>=</keyword> hymn_as_func(value);
            function_delete(func);
        }
    }

    function_delete(main);
    hymn_string_delete(code);

    assert(H-&gt;stack_top <keyword>==</keyword> H-&gt;stack);
    reset_stack(H);

    <keyword>return</keyword> <constant>NULL</constant>;
}

<keyword>static</keyword> <constant>char</constant> <keyword>*</keyword>exec(Hymn <keyword>*</keyword>H, <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>script, <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>source, <keyword>enum</keyword> FunctionType type) {
    CompileResult result <keyword>=</keyword> compile(H, script, source, type);

    <constant>char</constant> <keyword>*</keyword>error <keyword>=</keyword> result.error;
    <keyword>if</keyword> (error) {
        <keyword>return</keyword> error;
    }

    HymnFunction <keyword>*</keyword>func <keyword>=</keyword> result.func;
    HymnValue function <keyword>=</keyword> hymn_new_func_value(func);
    hymn_reference(function);

    push(H, function);
    call(H, func, <constant>0</constant>);

    error <keyword>=</keyword> interpret(H);
    <keyword>if</keyword> (error) {
        <keyword>return</keyword> error;
    }

    assert(H-&gt;stack_top <keyword>==</keyword> H-&gt;stack);
    reset_stack(H);

    <keyword>return</keyword> <constant>NULL</constant>;
}

<constant>char</constant> <keyword>*</keyword>hymn_run(Hymn <keyword>*</keyword>H, <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>script, <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>source) {
    <keyword>return</keyword> exec(H, script, source, TYPE_SCRIPT);
}

<constant>char</constant> <keyword>*</keyword>hymn_do(Hymn <keyword>*</keyword>H, <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>source) {
    <keyword>return</keyword> exec(H, <constant>NULL</constant>, source, TYPE_DO);
}

<constant>char</constant> <keyword>*</keyword>hymn_script(Hymn <keyword>*</keyword>H, <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>script) {
    HymnString <keyword>*</keyword>source <keyword>=</keyword> hymn_read_file(script);
    <keyword>if</keyword> (source <keyword>==</keyword> <constant>NULL</constant>) {
        HymnString <keyword>*</keyword>format <keyword>=</keyword> hymn_string_format(<string>&quot;file not found: %s\n&quot;</string>, script);
        <constant>char</constant> <keyword>*</keyword>error <keyword>=</keyword> string_to_chars(format);
        hymn_string_delete(format);
        <keyword>return</keyword> error;
    }
    <constant>char</constant> <keyword>*</keyword>error <keyword>=</keyword> exec(H, script, source, TYPE_SCRIPT);
    hymn_string_delete(source);
    <keyword>return</keyword> error;
}

<constant>#ifndef</constant> HYMN_NO_REPL

<constant>#include</constant> <string>&lt;ctype.h&gt;</string>

<constant>#define</constant> INPUT_LIMIT <constant>256</constant>

<keyword>typedef</keyword> <keyword>struct</keyword> History History;

<keyword>struct</keyword> History {
    HymnString <keyword>*</keyword>input;
    History <keyword>*</keyword>previous;
    History <keyword>*</keyword>next;
};

<constant>#ifndef</constant> _MSC_VER
<constant>#include</constant> <string>&lt;termios.h&gt;</string>

<constant>#define</constant> CURSOR_RESET <string>&quot;\033[2K\r&quot;</string>

<constant>#define</constant> cursor_backspace() <constant>printf</constant>(<string>&quot;\b \b&quot;</string>)
<constant>#define</constant> cursor_forward() <constant>printf</constant>(<string>&quot;\033[1C&quot;</string>)
<constant>#define</constant> cursor_backward() <constant>printf</constant>(<string>&quot;\033[1D&quot;</string>)
<constant>#define</constant> cursor_clear() <constant>printf</constant>(<string>&quot;\033[s\033[K&quot;</string>)
<constant>#define</constant> cursor_erase() <constant>printf</constant>(<string>&quot;\033[1D\033[s\033[K&quot;</string>)
<constant>#define</constant> cursor_unsave() <constant>printf</constant>(<string>&quot;\033[u&quot;</string>)
<constant>#define</constant> cursor_reset() <constant>printf</constant>(CURSOR_RESET)

<keyword>enum</keyword> Keyboard {
    ARROW_UP <keyword>=</keyword> <constant>1000</constant>,
    ARROW_DOWN,
    ARROW_LEFT,
    ARROW_RIGHT,
    PAGE_UP,
    PAGE_DOWN,
    HOME_KEY,
    END_KEY,
    DELETE_KEY
};

<keyword>static</keyword> <constant>char</constant> letters[] <keyword>=</keyword>
    <string>&quot;0123456789&quot;</string>
    <string>&quot;abcdefghijklmnopqrstuvwxyz&quot;</string>
    <string>&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</string>;

<keyword>static</keyword> <keyword>struct</keyword> termios save_termios;

<keyword>static</keyword> <constant>int</constant> read_key(<constant>void</constant>) {
    do {
        <constant>char</constant> c;
        ssize_t e <keyword>=</keyword> read(STDIN_FILENO, <keyword>&</keyword>c, <constant>1</constant>);
        <keyword>if</keyword> (e <keyword>==</keyword> <constant>1</constant>) {
            <keyword>if</keyword> (c <keyword>==</keyword> <string>'\x1b'</string>) {
                <constant>char</constant> sequence[<constant>3</constant>];
                <keyword>if</keyword> (read(STDIN_FILENO, <keyword>&</keyword>sequence[<constant>0</constant>], <constant>1</constant>) <keyword>!=</keyword> <constant>1</constant>) {
                    <keyword>return</keyword> <string>'\x1b'</string>;
                }
                <keyword>if</keyword> (read(STDIN_FILENO, <keyword>&</keyword>sequence[<constant>1</constant>], <constant>1</constant>) <keyword>!=</keyword> <constant>1</constant>) {
                    <keyword>return</keyword> <string>'\x1b'</string>;
                }
                <keyword>if</keyword> (sequence[<constant>0</constant>] <keyword>==</keyword> <string>'['</string>) {
                    <keyword>if</keyword> (sequence[<constant>1</constant>] <keyword>&gt;</keyword><keyword>=</keyword> <string>'0'</string> <keyword>&</keyword><keyword>&</keyword> sequence[<constant>1</constant>] <keyword>&lt;</keyword><keyword>=</keyword> <string>'9'</string>) {
                        <keyword>if</keyword> (read(STDIN_FILENO, <keyword>&</keyword>sequence[<constant>2</constant>], <constant>1</constant>) <keyword>!=</keyword> <constant>1</constant>) {
                            <keyword>return</keyword> <string>'\x1b'</string>;
                        }
                        <keyword>if</keyword> (sequence[<constant>2</constant>] <keyword>==</keyword> <string>'~'</string>) {
                            <keyword>switch</keyword> (sequence[<constant>1</constant>]) {
                            <keyword>case</keyword> <string>'1'</string>: <keyword>return</keyword> HOME_KEY;
                            <keyword>case</keyword> <string>'3'</string>: <keyword>return</keyword> DELETE_KEY;
                            <keyword>case</keyword> <string>'4'</string>: <keyword>return</keyword> END_KEY;
                            <keyword>case</keyword> <string>'5'</string>: <keyword>return</keyword> PAGE_UP;
                            <keyword>case</keyword> <string>'6'</string>: <keyword>return</keyword> PAGE_DOWN;
                            <keyword>case</keyword> <string>'7'</string>: <keyword>return</keyword> HOME_KEY;
                            <keyword>case</keyword> <string>'8'</string>: <keyword>return</keyword> END_KEY;
                            <keyword>default</keyword>: <keyword>break</keyword>;
                            }
                        }
                    } <keyword>else</keyword> {
                        <keyword>switch</keyword> (sequence[<constant>1</constant>]) {
                        <keyword>case</keyword> <string>'A'</string>: <keyword>return</keyword> ARROW_UP;
                        <keyword>case</keyword> <string>'B'</string>: <keyword>return</keyword> ARROW_DOWN;
                        <keyword>case</keyword> <string>'D'</string>: <keyword>return</keyword> ARROW_LEFT;
                        <keyword>case</keyword> <string>'C'</string>: <keyword>return</keyword> ARROW_RIGHT;
                        <keyword>case</keyword> <string>'H'</string>: <keyword>return</keyword> HOME_KEY;
                        <keyword>case</keyword> <string>'F'</string>: <keyword>return</keyword> END_KEY;
                        <keyword>default</keyword>: <keyword>break</keyword>;
                        }
                    }
                } <keyword>else</keyword> <keyword>if</keyword> (sequence[<constant>0</constant>] <keyword>==</keyword> <string>'O'</string>) {
                    <keyword>switch</keyword> (sequence[<constant>1</constant>]) {
                    <keyword>case</keyword> <string>'H'</string>: <keyword>return</keyword> HOME_KEY;
                    <keyword>case</keyword> <string>'F'</string>: <keyword>return</keyword> END_KEY;
                    <keyword>default</keyword>: <keyword>break</keyword>;
                    }
                }
                <keyword>return</keyword> <string>'\x1b'</string>;
            } <keyword>else</keyword> {
                <keyword>return</keyword> c;
            }
        } <keyword>else</keyword> <keyword>if</keyword> (e <keyword>==</keyword> <keyword>-</keyword><constant>1</constant> <keyword>&</keyword><keyword>&</keyword> errno <keyword>!=</keyword> EAGAIN) {
            <constant>printf</constant>(<string>&quot;\nuser interrupt&quot;</string>);
            <keyword>return</keyword> EOF;
        }
    } <keyword>while</keyword> (<constant>true</constant>);
}

<keyword>static</keyword> <constant>void</constant> reset_terminal(<constant>void</constant>) {
    <keyword>if</keyword> (tcsetattr(STDIN_FILENO, TCSANOW, <keyword>&</keyword>save_termios) <keyword>==</keyword> <keyword>-</keyword><constant>1</constant>) {
        perror(<string>&quot;tcsetattr&quot;</string>);
    }
}
<constant>#else</constant>
<keyword>static</keyword> <constant>void</constant> remove_newline(<constant>char</constant> <keyword>*</keyword>line) {
    <constant>size_t</constant> i <keyword>=</keyword> <constant>0</constant>;
    <keyword>while</keyword> (line[i] <keyword>!=</keyword> <string>'\0'</string>) {
        i++;
    }
    <keyword>while</keyword> (i <keyword>&gt;</keyword> <constant>0</constant>) {
        i--;
        <keyword>if</keyword> (line[i] <keyword>!=</keyword> <string>'\n'</string>) <keyword>return</keyword>;
        line[i] <keyword>=</keyword> <string>'\0'</string>;
    }
}
<constant>#endif</constant>

<keyword>static</keyword> <constant>void</constant> call_function(Hymn <keyword>*</keyword>H, HymnFunction <keyword>*</keyword>func) {
    HymnValue function <keyword>=</keyword> hymn_new_func_value(func);
    hymn_reference(function);
    push(H, function);
    call(H, func, <constant>0</constant>);
    <constant>char</constant> <keyword>*</keyword>error <keyword>=</keyword> interpret(H);
    <keyword>if</keyword> (error <keyword>!=</keyword> <constant>NULL</constant>) {
        <constant>fprintf</constant>(stderr, <string>&quot;%s\n&quot;</string>, error);
        fflush(stderr);
        <constant>free</constant>(error);
    }
    assert(H-&gt;stack_top <keyword>==</keyword> H-&gt;stack);
    reset_stack(H);
}

<constant>void</constant> hymn_repl(Hymn <keyword>*</keyword>H) {

    <constant>printf</constant>(<string>&quot;welcome to hymn v&quot;</string> HYMN_VERSION <string>&quot;\ntype .help for more information\n&quot;</string>);

<constant>#ifdef</constant> _MSC_VER
    <constant>char</constant> temp_dir[MAX_PATH];
    GetTempPath(MAX_PATH, temp_dir);
<constant>#else</constant>
    <keyword>if</keyword> (tcgetattr(STDIN_FILENO, <keyword>&</keyword>save_termios) <keyword>==</keyword> <keyword>-</keyword><constant>1</constant>) {
        perror(<string>&quot;tcgetattr&quot;</string>);
        <keyword>return</keyword>;
    }
    <keyword>struct</keyword> termios new_term <keyword>=</keyword> save_termios;
    new_term.c_lflag <keyword>&</keyword><keyword>=</keyword> <keyword>~</keyword>(<constant>0</constant>U | ECHO | ICANON);
    new_term.c_cc[VMIN] <keyword>=</keyword> <constant>1</constant>;
    new_term.c_cc[VTIME] <keyword>=</keyword> <constant>0</constant>;
    <keyword>if</keyword> (tcsetattr(STDIN_FILENO, TCSANOW, <keyword>&</keyword>new_term) <keyword>==</keyword> <keyword>-</keyword><constant>1</constant>) {
        perror(<string>&quot;tcsetattr&quot;</string>);
        <keyword>return</keyword>;
    }
    atexit(reset_terminal);

    <constant>int</constant> index <keyword>=</keyword> <constant>0</constant>;
    <constant>int</constant> count <keyword>=</keyword> <constant>0</constant>;

    History <keyword>*</keyword>lines <keyword>=</keyword> <constant>NULL</constant>;
    History <keyword>*</keyword>cursor <keyword>=</keyword> <constant>NULL</constant>;
<constant>#endif</constant>

    <constant>char</constant> line[INPUT_LIMIT];
    HymnString <keyword>*</keyword>input <keyword>=</keyword> hymn_new_string_with_capacity(INPUT_LIMIT);

    History <keyword>*</keyword>history <keyword>=</keyword> <constant>NULL</constant>;
    <constant>bool</constant> open_editor <keyword>=</keyword> <constant>false</constant>;

    <keyword>while</keyword> (<constant>true</constant>) {
        <constant>printf</constant>(input[<constant>0</constant>] <keyword>==</keyword> <string>'\0'</string> ? <string>&quot;&gt; &quot;</string> : <string>&quot;... &quot;</string>);
        fflush(stdout);

<constant>#ifdef</constant> _MSC_VER
        <keyword>if</keyword> (fgets(line, sizeof(line), stdin) <keyword>==</keyword> <constant>NULL</constant>) {
            <keyword>break</keyword>;
        }
        remove_newline(line);
<constant>#else</constant>
<constant>#define</constant> CONTROL_KEY(c) ((c)<keyword>&</keyword><constant>0</constant>x1f)

        index <keyword>=</keyword> <constant>0</constant>;
        count <keyword>=</keyword> <constant>0</constant>;

        <keyword>while</keyword> (<constant>true</constant>) {
            <constant>int</constant> c <keyword>=</keyword> read_key();
            <keyword>switch</keyword> (c) {
            <keyword>case</keyword> CONTROL_KEY(<string>'d'</string>):
                <constant>printf</constant>(<string>&quot;\n&quot;</string>);
                <keyword>goto</keyword> quit;
            <keyword>case</keyword> CONTROL_KEY(<string>'e'</string>):
                open_editor <keyword>=</keyword> <constant>true</constant>;
                <keyword>goto</keyword> scan;
            <keyword>case</keyword> PAGE_UP:
            <keyword>case</keyword> ARROW_UP:
                <keyword>if</keyword> (lines <keyword>!=</keyword> <constant>NULL</constant>) {
                    <keyword>if</keyword> (cursor <keyword>==</keyword> <constant>NULL</constant>) {
                        cursor <keyword>=</keyword> lines;
                    } <keyword>else</keyword> <keyword>if</keyword> (cursor-&gt;previous <keyword>==</keyword> <constant>NULL</constant>) {
                        <keyword>continue</keyword>;
                    } <keyword>else</keyword> {
                        cursor <keyword>=</keyword> cursor-&gt;previous;
                    }
                    <constant>size_t</constant> len <keyword>=</keyword> hymn_string_len(cursor-&gt;input);
                    <constant>memcpy</constant>(line, cursor-&gt;input, len + <constant>1</constant>);
                    index <keyword>=</keyword> (<constant>int</constant>)len;
                    count <keyword>=</keyword> index;
                    <constant>printf</constant>(CURSOR_RESET <string>&quot;%s %s&quot;</string>, input[<constant>0</constant>] <keyword>==</keyword> <string>'\0'</string> ? <string>&quot;&gt;&quot;</string> : <string>&quot;...&quot;</string>, line);
                    fflush(stdout);
                }
                <keyword>continue</keyword>;
            <keyword>case</keyword> PAGE_DOWN:
            <keyword>case</keyword> ARROW_DOWN:
                <keyword>if</keyword> (cursor <keyword>!=</keyword> <constant>NULL</constant>) {
                    cursor <keyword>=</keyword> cursor-&gt;next;
                    <keyword>if</keyword> (cursor <keyword>!=</keyword> <constant>NULL</constant>) {
                        <constant>size_t</constant> len <keyword>=</keyword> hymn_string_len(cursor-&gt;input);
                        <constant>memcpy</constant>(line, cursor-&gt;input, len + <constant>1</constant>);
                        index <keyword>=</keyword> (<constant>int</constant>)len;
                        count <keyword>=</keyword> index;
                    } <keyword>else</keyword> {
                        line[<constant>0</constant>] <keyword>=</keyword> <string>'\0'</string>;
                        index <keyword>=</keyword> <constant>0</constant>;
                        count <keyword>=</keyword> <constant>0</constant>;
                    }
                    <constant>printf</constant>(CURSOR_RESET <string>&quot;%s %s&quot;</string>, input[<constant>0</constant>] <keyword>==</keyword> <string>'\0'</string> ? <string>&quot;&gt;&quot;</string> : <string>&quot;...&quot;</string>, line);
                    fflush(stdout);
                }
                <keyword>continue</keyword>;
            <keyword>case</keyword> HOME_KEY:
            <keyword>case</keyword> ARROW_LEFT:
                <keyword>if</keyword> (index <keyword>&gt;</keyword> <constant>0</constant>) {
                    index--;
                    cursor_backward();
                    fflush(stdout);
                }
                <keyword>continue</keyword>;
            <keyword>case</keyword> END_KEY:
            <keyword>case</keyword> ARROW_RIGHT:
                <keyword>if</keyword> (index <keyword>&lt;</keyword> count) {
                    index++;
                    cursor_forward();
                    fflush(stdout);
                }
                <keyword>continue</keyword>;
            <keyword>case</keyword> DELETE_KEY:
                <keyword>if</keyword> (index <keyword>&lt;</keyword> count) {
                    count--;
                    <keyword>for</keyword> (<constant>int</constant> i <keyword>=</keyword> index; i <keyword>&lt;</keyword> count; i++) {
                        line[i] <keyword>=</keyword> line[i <keyword>+</keyword> <constant>1</constant>];
                    }
                    cursor_clear();
                    line[count] <keyword>=</keyword> <string>'\0'</string>;
                    <constant>printf</constant>(<string>&quot;%s&quot;</string>, <keyword>&</keyword>line[index]);
                    cursor_unsave();
                    fflush(stdout);
                }
                <keyword>continue</keyword>;
            <keyword>case</keyword> EOF:
                hymn_string_zero(input);
                count <keyword>=</keyword> <constant>0</constant>;
                <keyword>goto</keyword> scan;
            <keyword>case</keyword> <string>'\n'</string>:
            <keyword>case</keyword> <string>'\r'</string>:
                <keyword>goto</keyword> scan;
            <keyword>default</keyword>:
                <keyword>if</keyword> (iscntrl(c)) {
                    <keyword>if</keyword> (c <keyword>==</keyword> <constant>8</constant> || c <keyword>==</keyword> <constant>127</constant>) {
<comment>                        // delete or backspace</comment>
                        <keyword>if</keyword> (index <keyword>&gt;</keyword> <constant>0</constant>) {
                            index--;
                            <keyword>for</keyword> (<constant>int</constant> i <keyword>=</keyword> index; i <keyword>&lt;</keyword> count <keyword>-</keyword> <constant>1</constant>; i++) {
                                line[i] <keyword>=</keyword> line[i <keyword>+</keyword> <constant>1</constant>];
                            }
                            count--;
                            <keyword>if</keyword> (index <keyword>==</keyword> count) {
                                cursor_backspace();
                            } <keyword>else</keyword> {
                                cursor_erase();
                                line[count] <keyword>=</keyword> <string>'\0'</string>;
                                <constant>printf</constant>(<string>&quot;%s&quot;</string>, <keyword>&</keyword>line[index]);
                                cursor_unsave();
                            }
                            fflush(stdout);
                        }
                    } <keyword>else</keyword> {
                        <constant>printf</constant>(<string>&quot;&lt;%d&gt;&quot;</string>, c);
                        fflush(stdout);
                    }
                } <keyword>else</keyword> <keyword>if</keyword> (c <keyword>!=</keyword> <string>'\0'</string>) {
                    <keyword>if</keyword> (count <keyword>&lt;</keyword> INPUT_LIMIT) {
                        count++;
                        <keyword>for</keyword> (<constant>int</constant> i <keyword>=</keyword> count <keyword>-</keyword> <constant>1</constant>; i <keyword>&gt;</keyword> index; i--) {
                            line[i] <keyword>=</keyword> line[i <keyword>-</keyword> <constant>1</constant>];
                        }
                        line[index] <keyword>=</keyword> (<constant>char</constant>)c;
                        index++;
                        <keyword>if</keyword> (index <keyword>==</keyword> count) {
                            <constant>printf</constant>(<string>&quot;%c&quot;</string>, c);
                        } <keyword>else</keyword> {
                            cursor_clear();
                            line[count] <keyword>=</keyword> <string>'\0'</string>;
                            <constant>printf</constant>(<string>&quot;%s&quot;</string>, <keyword>&</keyword>line[index <keyword>-</keyword> <constant>1</constant>]);
                            cursor_unsave();
                            cursor_forward();
                        }
                        fflush(stdout);
                    }
                }
            }
        }

    scan:
        line[count] <keyword>=</keyword> <string>'\0'</string>;
        <constant>printf</constant>(<string>&quot;\n&quot;</string>);
        cursor <keyword>=</keyword> <constant>NULL</constant>;
<constant>#endif</constant>

        <keyword>if</keyword> (line[<constant>0</constant>] <keyword>==</keyword> <string>'.'</string>) {
            <keyword>if</keyword> (hymn_string_equal(line, <string>&quot;.exit&quot;</string>) || hymn_string_equal(line, <string>&quot;.quit&quot;</string>)) {
                <keyword>goto</keyword> quit;
            } <keyword>else</keyword> <keyword>if</keyword> (hymn_string_equal(line, <string>&quot;.edit&quot;</string>)) {
                line[<constant>0</constant>] <keyword>=</keyword> <string>'\0'</string>;
                open_editor <keyword>=</keyword> <constant>true</constant>;
                <keyword>goto</keyword> editing;
            } <keyword>else</keyword> <keyword>if</keyword> (hymn_string_equal(line, <string>&quot;.help&quot;</string>)) {
                <constant>printf</constant>(<string>&quot;.exit   Exit interactive mode\n&quot;</string>
                       <string>&quot;.quit   Alias for .exit\n&quot;</string>
                       <string>&quot;.edit   Edit input using $EDITOR\n&quot;</string>
                       <string>&quot;.save   Save history to [FILE]\n&quot;</string>
                       <string>&quot;.load   Read history from [FILE]\n&quot;</string>
                       <string>&quot;.help   Print this help message\n&quot;</string>
                       <string>&quot;press ^E to use $EDITOR\n&quot;</string>
                       <string>&quot;press ^C to cancel expression\n&quot;</string>
                       <string>&quot;press ^D to exit interactive mode\n&quot;</string>);
            } <keyword>else</keyword> <keyword>if</keyword> (string_starts_with(line, <string>&quot;.save &quot;</string>)) {
                <constant>char</constant> path[PATH_MAX];
                strcpy(path, <keyword>&</keyword>line[<constant>6</constant>]);
                <keyword>if</keyword> (path[<constant>0</constant>] <keyword>==</keyword> <string>'\0'</string>) {
                    <constant>printf</constant>(<string>&quot;bad file path\n&quot;</string>);
                } <keyword>else</keyword> <keyword>if</keyword> (history <keyword>==</keyword> <constant>NULL</constant>) {
                    <constant>printf</constant>(<string>&quot;no history to save\n&quot;</string>);
                } <keyword>else</keyword> <keyword>if</keyword> (hymn_file_exists(path)) {
                    <constant>printf</constant>(<string>&quot;history can't overwrite an existing file: %s\n&quot;</string>, path);
                } <keyword>else</keyword> {
                    FILE <keyword>*</keyword>open <keyword>=</keyword> fopen(path, <string>&quot;w&quot;</string>);
                    <keyword>if</keyword> (open <keyword>==</keyword> <constant>NULL</constant>) {
                        <constant>printf</constant>(<string>&quot;failed to write history: %s\n&quot;</string>, path);
                    } <keyword>else</keyword> {
                        History <keyword>*</keyword>head <keyword>=</keyword> history;
                        <keyword>while</keyword> (head-&gt;previous <keyword>!=</keyword> <constant>NULL</constant>) {
                            head <keyword>=</keyword> head-&gt;previous;
                        }
                        <keyword>while</keyword> (head <keyword>!=</keyword> <constant>NULL</constant>) {
                            <constant>fprintf</constant>(open, <string>&quot;%s\n&quot;</string>, head-&gt;input);
                            head <keyword>=</keyword> head-&gt;next;
                        }
                        fclose(open);
                        <constant>printf</constant>(<string>&quot;history saved to: %s\n&quot;</string>, path);
                    }
                }
            } <keyword>else</keyword> <keyword>if</keyword> (string_starts_with(line, <string>&quot;.load &quot;</string>)) {
                <constant>char</constant> path[PATH_MAX];
                strcpy(path, <keyword>&</keyword>line[<constant>6</constant>]);
                <keyword>if</keyword> (path[<constant>0</constant>] <keyword>==</keyword> <string>'\0'</string>) {
                    <constant>printf</constant>(<string>&quot;bad file path\n&quot;</string>);
                } <keyword>else</keyword> <keyword>if</keyword> (hymn_file_exists(path)) {
                    HymnString <keyword>*</keyword>source <keyword>=</keyword> hymn_read_file(path);
                    <keyword>if</keyword> (source <keyword>==</keyword> <constant>NULL</constant>) {
                        <constant>printf</constant>(<string>&quot;failed to read history: %s\n&quot;</string>, path);
                    } <keyword>else</keyword> {
                        <constant>char</constant> <keyword>*</keyword>error <keyword>=</keyword> hymn_do(H, source);
                        hymn_string_delete(source);
                        <keyword>if</keyword> (error <keyword>!=</keyword> <constant>NULL</constant>) {
                            <constant>fprintf</constant>(stderr, <string>&quot;%s\n&quot;</string>, error);
                            fflush(stderr);
                            <constant>free</constant>(error);
                        }
                    }
                } <keyword>else</keyword> {
                    <constant>printf</constant>(<string>&quot;history file not found: %s\n&quot;</string>, path);
                }
            } <keyword>else</keyword> <keyword>if</keyword> (hymn_string_equal(line, <string>&quot;.save&quot;</string>)) {
                <constant>printf</constant>(<string>&quot;specify a path\n&quot;</string>);
            } <keyword>else</keyword> <keyword>if</keyword> (hymn_string_equal(line, <string>&quot;.load&quot;</string>)) {
                <constant>printf</constant>(<string>&quot;specify a path\n&quot;</string>);
            } <keyword>else</keyword> {
                <constant>printf</constant>(<string>&quot;invalid interactive command\n&quot;</string>);
            }
            <keyword>continue</keyword>;
        }

    editing:
        <keyword>if</keyword> (line[<constant>0</constant>] <keyword>!=</keyword> <string>'\0'</string>) {
<constant>#ifndef</constant> _MSC_VER
            History <keyword>*</keyword>save <keyword>=</keyword> hymn_calloc(<constant>1</constant>, sizeof(History));
            save-&gt;input = hymn_new_string(line);
            <keyword>if</keyword> (lines <keyword>==</keyword> <constant>NULL</constant>) {
                lines <keyword>=</keyword> save;
            } <keyword>else</keyword> {
                lines-&gt;next = save;
                save-&gt;previous = lines;
                lines <keyword>=</keyword> save;
            }
<constant>#endif</constant>
            <keyword>if</keyword> (input[<constant>0</constant>] <keyword>!=</keyword> <string>'\0'</string>) input <keyword>=</keyword> hymn_string_append_<constant>char</constant>(input, <string>'\n'</string>);
            input <keyword>=</keyword> hymn_string_append(input, line);
            hymn_string_trim(input);
        }

        <keyword>if</keyword> (open_editor) {
            open_editor <keyword>=</keyword> <constant>false</constant>;

            <constant>char</constant> <keyword>*</keyword>editor <keyword>=</keyword> getenv(<string>&quot;EDITOR&quot;</string>);
            <keyword>if</keyword> (editor <keyword>==</keyword> <constant>NULL</constant>) {
<constant>#ifdef</constant> _MSC_VER
                editor <keyword>=</keyword> <string>&quot;notepad&quot;</string>;
<constant>#else</constant>
                <constant>printf</constant>(<string>&quot;no EDITOR set\n&quot;</string>);
                <keyword>continue</keyword>;
<constant>#endif</constant>
            }

            FILE <keyword>*</keyword>temp <keyword>=</keyword> <constant>NULL</constant>;

<constant>#ifdef</constant> _MSC_VER
            <constant>char</constant> path[MAX_PATH];
            GetTempFileName(temp_dir, <string>&quot;hymn&quot;</string>, <constant>0</constant>, path);
            temp <keyword>=</keyword> fopen(path, <string>&quot;w&quot;</string>);
<constant>#else</constant>
            <constant>char</constant> path[] <keyword>=</keyword> <string>&quot;/tmp/hymn.XXXXXX&quot;</string>;
            <keyword>for</keyword> (<constant>int</constant> a <keyword>=</keyword> <constant>0</constant>; a <keyword>&lt;</keyword> <constant>64</constant>; a++) {
                <keyword>for</keyword> (<constant>int</constant> x <keyword>=</keyword> <constant>0</constant>; x <keyword>&lt;</keyword> <constant>6</constant>; x++) {
                    path[<constant>10</constant> <keyword>+</keyword> x] <keyword>=</keyword> letters[(<constant>size_t</constant>)((<constant>double</constant>)rand() <keyword>/</keyword> RAND_MAX <keyword>*</keyword> (sizeof(letters) <keyword>-</keyword> <constant>1</constant>))];
                }
                temp <keyword>=</keyword> fopen(path, <string>&quot;wx&quot;</string>);
                <keyword>if</keyword> (temp <keyword>!=</keyword> <constant>NULL</constant>) {
                    <keyword>break</keyword>;
                }
            }
<constant>#endif</constant>

            <keyword>if</keyword> (temp <keyword>==</keyword> <constant>NULL</constant>) {
                <constant>printf</constant>(<string>&quot;failed to create temporary file\n&quot;</string>);
                <keyword>continue</keyword>;
            }

            hymn_string_trim(input);
            <keyword>if</keyword> (hymn_string_len(input) <keyword>&gt;</keyword> <constant>0</constant>) {
                <constant>fprintf</constant>(temp, <string>&quot;%s&quot;</string>, input);
                hymn_string_zero(input);
            }

            fclose(temp);

            HymnString <keyword>*</keyword>edit <keyword>=</keyword> hymn_string_format(<string>&quot;%s %s&quot;</string>, editor, path);
            <constant>int</constant> result <keyword>=</keyword> system(edit);
            <keyword>if</keyword> (result <keyword>==</keyword> <keyword>-</keyword><constant>1</constant>) {
                <constant>printf</constant>(<string>&quot;failed edit: %d\n&quot;</string>, result);
            }
            hymn_string_delete(edit);

            HymnString <keyword>*</keyword>content <keyword>=</keyword> hymn_read_file(path);
            unlink(path);

            <keyword>if</keyword> (content <keyword>==</keyword> <constant>NULL</constant>) {
                <constant>printf</constant>(<string>&quot;failed to read temporary file\n&quot;</string>);
                <keyword>continue</keyword>;
            }

            input <keyword>=</keyword> hymn_string_append(input, content);
            hymn_string_delete(content);
            hymn_string_trim(input);
            <keyword>if</keyword> (input[<constant>0</constant>] <keyword>==</keyword> <string>'\0'</string>) {
                <keyword>continue</keyword>;
            }
            <constant>printf</constant>(<string>&quot;%s\n&quot;</string>, input);
        }

        <keyword>if</keyword> (input[<constant>0</constant>] <keyword>==</keyword> <string>'\0'</string>) <keyword>continue</keyword>;

        CompileResult result <keyword>=</keyword> compile(H, <constant>NULL</constant>, input, TYPE_REPL);
        <constant>char</constant> <keyword>*</keyword>error <keyword>=</keyword> result.error;
        <keyword>if</keyword> (error <keyword>!=</keyword> <constant>NULL</constant>) {
            <keyword>if</keyword> (<keyword>!</keyword>hymn_string_equal(error, <string>&quot;&lt;eof&gt;&quot;</string>)) {
                hymn_string_zero(input);
                <constant>fprintf</constant>(stderr, <string>&quot;%s\n&quot;</string>, error);
                fflush(stderr);
                <constant>free</constant>(error);
            }
            <keyword>continue</keyword>;
        }
        HymnFunction <keyword>*</keyword>func <keyword>=</keyword> result.func;

        History <keyword>*</keyword>save <keyword>=</keyword> hymn_calloc(<constant>1</constant>, sizeof(History));
        save-&gt;input = hymn_new_string(input);
        <keyword>if</keyword> (history <keyword>==</keyword> <constant>NULL</constant>) {
            history <keyword>=</keyword> save;
        } <keyword>else</keyword> {
            history-&gt;next = save;
            save-&gt;previous = history;
            history <keyword>=</keyword> save;
        }
        hymn_string_zero(input);

        call_function(H, func);
    }

quit:
    hymn_string_delete(input);
<constant>#ifndef</constant> _MSC_VER
    <keyword>while</keyword> (lines <keyword>!=</keyword> <constant>NULL</constant>) {
        hymn_string_delete(lines-&gt;input);
        History <keyword>*</keyword>previous <keyword>=</keyword> lines-&gt;previous;
        <constant>free</constant>(lines);
        lines <keyword>=</keyword> previous;
    }
<constant>#endif</constant>
    <keyword>while</keyword> (history <keyword>!=</keyword> <constant>NULL</constant>) {
        hymn_string_delete(history-&gt;input);
        History <keyword>*</keyword>previous <keyword>=</keyword> history-&gt;previous;
        <constant>free</constant>(history);
        history <keyword>=</keyword> previous;
    }
}
<constant>#endif</constant>

<constant>#ifndef</constant> HYMN_NO_DYNAMIC_LIBS

<constant>void</constant> hymn_add_dlib(Hymn <keyword>*</keyword>H, <constant>void</constant> <keyword>*</keyword>library) {
    HymnLibList <keyword>*</keyword>tail <keyword>=</keyword> H-&gt;libraries;
    HymnLibList <keyword>*</keyword>head <keyword>=</keyword> hymn_calloc(<constant>1</constant>, sizeof(HymnLibList));
    head-&gt;lib = library;
    head-&gt;next = tail;
    H-&gt;libraries = head;
}

<constant>#ifdef</constant> _MSC_VER
<keyword>typedef</keyword> <constant>void</constant> (<keyword>*</keyword>HymnDynamicLib)(Hymn <keyword>*</keyword>H);

<constant>void</constant> hymn_close_dlib(<constant>void</constant> <keyword>*</keyword>library) {
    FreeLibrary(library);
}

HymnString <keyword>*</keyword>hymn_use_dlib(Hymn <keyword>*</keyword>H, <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>path, <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>func) {
    HINSTANCE lib <keyword>=</keyword> LoadLibrary(path);
    <keyword>if</keyword> (lib <keyword>!=</keyword> <constant>NULL</constant>) {
        HymnDynamicLib proc <keyword>=</keyword> (HymnDynamicLib)GetProcAddress(lib, func);
        <keyword>if</keyword> (proc <keyword>!=</keyword> <constant>NULL</constant>) {
            proc(H);
            hymn_add_dlib(H, lib);
            <keyword>return</keyword> <constant>NULL</constant>;
        }
    }

    HymnString <keyword>*</keyword>message <keyword>=</keyword> <constant>NULL</constant>;
    <constant>int</constant> error <keyword>=</keyword> GetLastError();
    <constant>char</constant> buffer[<constant>128</constant>];
    <keyword>if</keyword> (FormatMessage(FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM, <constant>0</constant>, error, <constant>0</constant>, buffer, sizeof(buffer), <constant>0</constant>)) {
        message <keyword>=</keyword> hymn_new_string(buffer);
    } <keyword>else</keyword> {
        message <keyword>=</keyword> hymn_string_format(<string>&quot;windows error: %d\n&quot;</string>, error);
    }
    <keyword>if</keyword> (lib <keyword>!=</keyword> <constant>NULL</constant>) {
        hymn_close_dlib(lib);
    }
    <keyword>return</keyword> message;
}

<constant>#else</constant>
<constant>#include</constant> <string>&lt;dlfcn.h&gt;</string>

<constant>void</constant> hymn_close_dlib(<constant>void</constant> <keyword>*</keyword>library) {
    dlclose(library);
}

HymnString <keyword>*</keyword>hymn_use_dlib(Hymn <keyword>*</keyword>H, <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>path, <keyword>const</keyword> <constant>char</constant> <keyword>*</keyword>func) {
    <constant>void</constant> <keyword>*</keyword>lib <keyword>=</keyword> dlopen(path, RTLD_NOW);
    <keyword>if</keyword> (lib <keyword>!=</keyword> <constant>NULL</constant>) {
        <constant>void</constant> <keyword>*</keyword>(<keyword>*</keyword>proc)(Hymn <keyword>*</keyword>);
        <keyword>*</keyword>(<constant>void</constant> <keyword>*</keyword><keyword>*</keyword>)(<keyword>&</keyword>proc) <keyword>=</keyword> dlsym(lib, func);
        <keyword>if</keyword> (proc <keyword>!=</keyword> <constant>NULL</constant>) {
            proc(H);
            hymn_add_dlib(H, lib);
            <keyword>return</keyword> <constant>NULL</constant>;
        }
    }

    HymnString <keyword>*</keyword>message <keyword>=</keyword> hymn_new_string(dlerror());
    <keyword>if</keyword> (lib <keyword>!=</keyword> <constant>NULL</constant>) {
        hymn_close_dlib(lib);
    }
    <keyword>return</keyword> message;
}
<constant>#endif</constant>

<constant>#endif</constant></code></pre></div>
      </section>
    </main>
    <footer>
      <p>
        Made with ❤ by <a href="https://nathanmcmillan.github.io/">Nathan McMillan</a>. You can find the website source code
        <a href="https://github.com/nathanmcmillan/hymn-website">here</a>.
      </p>
    </footer>
  </body>
</html>