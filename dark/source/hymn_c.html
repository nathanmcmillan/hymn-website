<!DOCTYPE html>
<html>
  <head>
    <title>hymn.c</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" type="text/css" href="/dark/css/index.css" />
  </head>

  <body>
    <header>
      <div class="header">
        <div class="header-left">Hymn Script</div>
        <div>
          <a href="/dark/index.html">Home</a>
          <a href="/dark/learn.html">Learn</a>
          <a href="/dark/play.html">Play</a>
          <a href="https://github.com/nathanmcmillan/hymn-lang/tags">Download</a>
          <a href="/dark/source">Source</a>
          <a href="/source/hymn_c.html">Light</a>
        </div>
      </div>
    </header>
    <main id="index">
      <h1 class="centered-header">hymn.c</h1>
      <hr class="section-line" />
      <section>
        <hr class="padding" />
        <div class="code"><pre><code>/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */

#include &quot;hymn.h&quot;

void *hymn_malloc(size_t size) {
    void *mem = malloc(size);
    if (mem) {
        return mem;
    }
    fprintf(stderr, &quot;malloc failed.\n&quot;);
    exit(1);
}

void *hymn_calloc(size_t count, size_t size) {
    void *mem = calloc(count, size);
    if (mem) {
        return mem;
    }
    fprintf(stderr, &quot;calloc failed.\n&quot;);
    exit(1);
}

void *hymn_realloc(void *mem, size_t size) {
    mem = realloc(mem, size);
    if (mem) {
        return mem;
    }
    fprintf(stderr, &quot;realloc failed.\n&quot;);
    exit(1);
}

void *hymn_malloc_int(int count, size_t size) {
    if (count &lt; 0) {
        fprintf(stderr, &quot;malloc negative count.\n&quot;);
        exit(1);
    }
    void *mem = malloc((size_t)count * size);
    if (mem) {
        return mem;
    }
    fprintf(stderr, &quot;malloc failed.\n&quot;);
    exit(1);
}

void *hymn_calloc_int(int count, size_t size) {
    if (count &lt; 0) {
        fprintf(stderr, &quot;calloc negative count.\n&quot;);
        exit(1);
    }
    void *mem = calloc((size_t)count, size);
    if (mem) {
        return mem;
    }
    fprintf(stderr, &quot;calloc failed.\n&quot;);
    exit(1);
}

void *hymn_realloc_int(void *mem, int count, size_t size) {
    if (count &lt; 0) {
        fprintf(stderr, &quot;realloc negative count.\n&quot;);
        exit(1);
    }
    mem = realloc(mem, (size_t)count * size);
    if (mem) {
        return mem;
    }
    fprintf(stderr, &quot;realloc failed.\n&quot;);
    exit(1);
}

static void hymn_mem_copy(void *dest, void *src, int count, size_t size) {
    if (count &lt; 0) {
        fprintf(stderr, &quot;memcpy negative count.\n&quot;);
        exit(1);
    }
    memcpy(dest, src, (size_t)count * size);
}

static HymnStringHead *string_head_init(size_t length, size_t capacity) {
    size_t memory = sizeof(HymnStringHead) + capacity + 1;
    HymnStringHead *head = (HymnStringHead *)hymn_malloc(memory);
    memset(head, 0, memory);
    head-&gt;length = length;
    head-&gt;capacity = capacity;
    return head;
}

HymnString *hymn_new_string_with_capacity(size_t capacity) {
    HymnStringHead *head = string_head_init(0, capacity);
    return (HymnString *)(head + 1);
}

HymnString *hymn_new_string_with_length(const char *chars, size_t length) {
    HymnStringHead *head = string_head_init(length, length);
    char *string = (char *)(head + 1);
    memcpy(string, chars, length);
    return (HymnString *)string;
}

HymnString *hymn_new_empty_string(size_t length) {
    HymnStringHead *head = string_head_init(length, length);
    char *string = (char *)(head + 1);
    return (HymnString *)string;
}

HymnString *hymn_new_string(const char *chars) {
    size_t length = strlen(chars);
    return hymn_new_string_with_length(chars, length);
}

HymnString *hymn_substring(const char *init, size_t start, size_t end) {
    size_t length = end - start;
    HymnStringHead *head = string_head_init(length, length);
    char *string = (char *)(head + 1);
    memcpy(string, &init[start], length);
    string[length] = '\0';
    return (HymnString *)string;
}

static bool space(char c) {
    return c == ' ' || c == '\t' || c == '\n' || c == '\r';
}

void hymn_string_trim(HymnString *string) {
    size_t len = hymn_string_len(string);
    size_t start = 0;
    while (start &lt; len) {
        char c = string[start];
        if (!space(c)) {
            break;
        }
        start++;
    }
    if (start == len) {
        hymn_string_zero(string);
    } else {
        size_t end = len - 1;
        while (end &gt; start) {
            char c = string[end];
            if (!space(c)) {
                break;
            }
            end--;
        }
        end++;
        size_t offset = start;
        size_t size = end - start;
        for (size_t i = 0; i &lt; size; i++) {
            string[i] = string[offset++];
        }
        HymnStringHead *head = hymn_string_head(string);
        head-&gt;length = size;
        string[size] = '\0';
    }
}

HymnString *hymn_string_copy(HymnString *string) {
    HymnStringHead *head = hymn_string_head(string);
    return hymn_new_string_with_length(string, head-&gt;length);
}

void hymn_string_delete(HymnString *string) {
    if (string == NULL) {
        return;
    }
    free((char *)string - sizeof(HymnStringHead));
}

void hymn_string_zero(HymnString *string) {
    HymnStringHead *head = hymn_string_head(string);
    head-&gt;length = 0;
    string[0] = '\0';
}

static HymnStringHead *string_resize(HymnStringHead *head, size_t capacity) {
    size_t memory = sizeof(HymnStringHead) + capacity + 1;
    HymnStringHead *new = hymn_realloc(head, memory);
    new-&gt;capacity = capacity;
    return new;
}

HymnString *hymn_string_append(HymnString *string, const char *b) {
    HymnStringHead *head = hymn_string_head(string);
    size_t len_a = head-&gt;length;
    size_t len_b = strlen(b);
    size_t len = len_a + len_b;
    if (len &gt; head-&gt;capacity) {
        head = string_resize(head, len * 2);
    }
    head-&gt;length = len;
    char *s = (char *)(head + 1);
    memcpy(s + len_a, b, len_b + 1);
    s[len] = '\0';
    return (HymnString *)s;
}

HymnString *hymn_string_append_char(HymnString *string, const char b) {
    HymnStringHead *head = hymn_string_head(string);
    size_t len = head-&gt;length + 1;
    if (len &gt; head-&gt;capacity) {
        head = string_resize(head, len * 2);
    }
    head-&gt;length = len;
    char *s = (char *)(head + 1);
    s[len - 1] = b;
    s[len] = '\0';
    return (HymnString *)s;
}

HymnString *hymn_string_append_substring(HymnString *string, const char *b, size_t start, size_t end) {
    HymnStringHead *head = hymn_string_head(string);
    size_t len_a = head-&gt;length;
    size_t len_b = end - start;
    size_t len = len_a + len_b;
    if (len &gt; head-&gt;capacity) {
        head = string_resize(head, len * 2);
    }
    head-&gt;length = len;
    char *s = (char *)(head + 1);
    memcpy(s + len_a, &b[start], len_b);
    s[len] = '\0';
    return (HymnString *)s;
}

static bool string_starts_with(const char *t, const char *s) {
    size_t tlen = strlen(t);
    size_t slen = strlen(s);
    return tlen &lt; slen ? false : memcmp(t, s, slen) == 0;
}

bool hymn_string_starts_with(HymnString *s, const char *using) {
    size_t slen = hymn_string_len(s);
    size_t ulen = strlen(using);
    return slen &lt; ulen ? false : memcmp(s, using, ulen) == 0;
}

static bool string_find(HymnString *string, HymnString *sub, size_t *out) {
    HymnStringHead *head = hymn_string_head(string);
    HymnStringHead *head_sub = hymn_string_head(sub);
    size_t len = head-&gt;length;
    size_t len_sub = head_sub-&gt;length;
    if (len_sub &gt; len) {
        return false;
    } else if (len == 0) {
        *out = 0;
        return true;
    }
    size_t end = len - len_sub + 1;
    for (size_t i = 0; i &lt; end; i++) {
        bool match = true;
        for (size_t k = 0; k &lt; len_sub; k++) {
            if (sub[k] != string[i + k]) {
                match = false;
                break;
            }
        }
        if (match) {
            *out = i;
            return true;
        }
    }
    return false;
}

HymnString *hymn_string_replace(HymnString *string, const char *find, const char *replace) {
    HymnStringHead *head = hymn_string_head(string);
    size_t len = head-&gt;length;
    size_t len_sub = strlen(find);
    if (len == 0 || len_sub &gt; len) {
        return hymn_new_string(&quot;&quot;);
    }
    HymnString *out = hymn_new_string_with_capacity(len);
    size_t end = len - len_sub + 1;
    size_t pos = 0;
    for (size_t i = 0; i &lt; end; i++) {
        bool match = true;
        for (size_t k = 0; k &lt; len_sub; k++) {
            if (find[k] != string[i + k]) {
                match = false;
                break;
            }
        }
        if (match) {
            out = hymn_string_append_substring(out, string, pos, i);
            out = hymn_string_append(out, replace);
            i += len_sub;
            pos = i;
            i--;
        }
    }
    if (pos &lt; len) {
        out = hymn_string_append_substring(out, string, pos, len);
    }
    return out;
}

static HymnString *char_to_string(char ch) {
    HymnString *s = hymn_new_empty_string(1);
    s[0] = ch;
    return s;
}

HymnString *hymn_int_to_string(HymnInt number) {
    size_t len = (size_t)snprintf(NULL, 0, &quot;%lld&quot;, number);
    char *str = hymn_malloc(len + 1);
    snprintf(str, len + 1, &quot;%lld&quot;, number);
    HymnString *s = hymn_new_string_with_length(str, len);
    free(str);
    return s;
}

HymnString *hymn_float_to_string(HymnFloat number) {
    size_t len = (size_t)snprintf(NULL, 0, &quot;%g&quot;, number);
    char *str = hymn_malloc(len + 1);
    snprintf(str, len + 1, &quot;%g&quot;, number);
    HymnString *s = hymn_new_string_with_length(str, len);
    free(str);
    return s;
}

static char *string_to_chars(HymnString *this) {
    size_t len = hymn_string_len(this);
    char *s = hymn_malloc((len + 1) * sizeof(char));
    memcpy(s, this, len);
    s[len] = '\0';
    return s;
}

HymnString *hymn_string_format(const char *format, ...) {
    va_list args;

    va_start(args, format);
    size_t len = (size_t)vsnprintf(NULL, 0, format, args);
    va_end(args);
    char *chars = hymn_malloc((len + 1) * sizeof(char));
    va_start(args, format);
    len = (size_t)vsnprintf(chars, len + 1, format, args);
    va_end(args);
    HymnString *str = hymn_new_string_with_length(chars, len);
    free(chars);
    return str;
}

static HymnString *string_append_format(HymnString *this, const char *format, ...) {
    va_list args;

    va_start(args, format);
    size_t len = (size_t)vsnprintf(NULL, 0, format, args);
    va_end(args);
    char *chars = hymn_malloc((len + 1) * sizeof(char));
    va_start(args, format);
    len = (size_t)vsnprintf(chars, len + 1, format, args);
    va_end(args);
    this = hymn_string_append(this, chars);
    free(chars);
    return this;
}

HymnString *hymn_working_directory(void) {
    char path[PATH_MAX];
    if (getcwd(path, sizeof(path)) != NULL) {
        return hymn_new_string(path);
    }
    return NULL;
}

HymnString *hymn_path_convert(HymnString *path) {
    size_t size = hymn_string_len(path);
    HymnString *convert = hymn_string_copy(path);
    for (size_t i = 0; i &lt; size; i++) {
        if (convert[i] == PATH_SEP_OTHER) {
            convert[i] = PATH_SEP;
        }
    }
    return convert;
}

HymnString *hymn_path_normalize(HymnString *path) {
    size_t i = 0;
    size_t size = hymn_string_len(path);
    if (size &gt; 1 && path[0] == '.') {
        if (path[1] == '.') {
            if (size &gt; 2 && path[2] == PATH_SEP) {
                i = 3;
            }
        } else if (path[1] == PATH_SEP) {
            i = 2;
        }
    }

    size_t n = 0;
    char normal[PATH_MAX];

    while (i &lt; size) {
        if (path[i] == PATH_SEP) {
            if (i + 2 &lt; size) {
                if (path[i + 1] == '.' && path[i + 2] == PATH_SEP) {
                    i += 2;
                    continue;
                } else if (path[i + 2] == '.' && i + 3 &lt; size && path[i + 3] == PATH_SEP) {
                    if (n &gt; 0) {
                        n--;
                        while (n &gt; 0) {
                            if (normal[n] == PATH_SEP) {
                                break;
                            }
                            n--;
                        }
                    }
                    i += 3;
                    continue;
                }
            }
        }

        normal[n] = path[i];
        n++;
        i++;
    }

    normal[n] = '\0';
    return hymn_new_string(normal);
}

HymnString *hymn_path_parent(HymnString *path) {
    size_t size = hymn_string_len(path);
    if (size &lt; 2) {
        return hymn_string_copy(path);
    }
    size_t index = size - 2;
    while (true) {
        if (index == 0 || path[index] == PATH_SEP) {
            return hymn_substring(path, 0, index);
        }
        index--;
    }
}

HymnString *hymn_path_absolute(HymnString *path) {
    HymnString *working = hymn_working_directory();
    if (hymn_string_starts_with(path, working)) {
        hymn_string_delete(working);
        return hymn_path_normalize(path);
    }
    working = hymn_string_append_char(working, PATH_SEP);
    working = hymn_string_append(working, path);
    HymnString *normal = hymn_path_normalize(working);
    hymn_string_delete(working);
    return normal;
}

size_t hymn_file_size(const char *path) {
    FILE *open = fopen(path, &quot;r&quot;);
    if (open == NULL) {
        return 0;
    }
    size_t size = 0;
    int ch;
    while ((ch = fgetc(open)) != EOF) {
        size++;
    }
    fclose(open);
    return size;
}

HymnString *hymn_read_file(const char *path) {
    size_t size = hymn_file_size(path);
    FILE *open = fopen(path, &quot;r&quot;);
    if (open == NULL) {
        return NULL;
    }
    HymnString *string = hymn_new_string_with_capacity(size);
    HymnStringHead *head = hymn_string_head(string);
    for (size_t i = 0; i &lt; size; i++) {
        string[i] = (char)fgetc(open);
    }
    fclose(open);
    head-&gt;length = size;
    return string;
}

bool hymn_file_exists(const char *path) {
    struct stat b;
    return stat(path, &b) == 0;
}

#ifdef _MSC_VER
#define ANSI_COLOR_RED &quot;&quot;
#define ANSI_COLOR_RESET &quot;&quot;
#else
#define ANSI_COLOR_RED &quot;\x1b[31m&quot;
#define ANSI_COLOR_RESET &quot;\x1b[0m&quot;
#endif

typedef struct JumpList JumpList;
typedef struct LoopList LoopList;

typedef struct Token Token;
typedef struct Local Local;
typedef struct Rule Rule;
typedef struct Scope Scope;
typedef struct Compiler Compiler;
typedef struct CompileResult CompileResult;

typedef struct Instruction Instruction;
typedef struct Optimizer Optimizer;

static const float LOAD_FACTOR = 0.80f;
static const unsigned int INITIAL_BINS = 1 &lt;&lt; 3;
static const unsigned int MAXIMUM_BINS = 1 &lt;&lt; 30;

enum TokenType {
    TOKEN_ADD,
    TOKEN_AND,
    TOKEN_ASSIGN,
    TOKEN_ASSIGN_ADD,
    TOKEN_ASSIGN_BIT_AND,
    TOKEN_ASSIGN_BIT_LEFT_SHIFT,
    TOKEN_ASSIGN_BIT_OR,
    TOKEN_ASSIGN_BIT_RIGHT_SHIFT,
    TOKEN_ASSIGN_BIT_XOR,
    TOKEN_ASSIGN_DIVIDE,
    TOKEN_ASSIGN_MODULO,
    TOKEN_ASSIGN_MULTIPLY,
    TOKEN_ASSIGN_SUBTRACT,
    TOKEN_BIT_AND,
    TOKEN_BIT_LEFT_SHIFT,
    TOKEN_BIT_NOT,
    TOKEN_BIT_OR,
    TOKEN_BIT_RIGHT_SHIFT,
    TOKEN_BIT_XOR,
    TOKEN_BREAK,
    TOKEN_CLEAR,
    TOKEN_COLON,
    TOKEN_COMMA,
    TOKEN_CONTINUE,
    TOKEN_COPY,
    TOKEN_DEBUG,
    TOKEN_DELETE,
    TOKEN_DIVIDE,
    TOKEN_DOT,
    TOKEN_ECHO,
    TOKEN_ELIF,
    TOKEN_ELSE,
    TOKEN_EOF,
    TOKEN_EQUAL,
    TOKEN_ERROR,
    TOKEN_EXCEPT,
    TOKEN_EXISTS,
    TOKEN_FALSE,
    TOKEN_FLOAT,
    TOKEN_FOR,
    TOKEN_FUNCTION,
    TOKEN_GREATER,
    TOKEN_GREATER_EQUAL,
    TOKEN_IDENT,
    TOKEN_IF,
    TOKEN_IN,
    TOKEN_INDEX,
    TOKEN_INSERT,
    TOKEN_INSPECT,
    TOKEN_INTEGER,
    TOKEN_KEYS,
    TOKEN_LEFT_CURLY,
    TOKEN_LEFT_PAREN,
    TOKEN_LEFT_SQUARE,
    TOKEN_LEN,
    TOKEN_LESS,
    TOKEN_LESS_EQUAL,
    TOKEN_LET,
    TOKEN_MODULO,
    TOKEN_MULTIPLY,
    TOKEN_NONE,
    TOKEN_NOT,
    TOKEN_NOT_EQUAL,
    TOKEN_OR,
    TOKEN_POINTER,
    TOKEN_POP,
    TOKEN_PRINT,
    TOKEN_PUSH,
    TOKEN_RETURN,
    TOKEN_RIGHT_CURLY,
    TOKEN_RIGHT_PAREN,
    TOKEN_RIGHT_SQUARE,
    TOKEN_STRING,
    TOKEN_SUBTRACT,
    TOKEN_THROW,
    TOKEN_TO_FLOAT,
    TOKEN_TO_INTEGER,
    TOKEN_TO_STRING,
    TOKEN_TRUE,
    TOKEN_TRY,
    TOKEN_TYPE_FUNC,
    TOKEN_UNDEFINED,
    TOKEN_USE,
    TOKEN_VALUE,
    TOKEN_WHILE,
};

enum Precedence {
    PRECEDENCE_NONE,
    PRECEDENCE_ASSIGN,
    PRECEDENCE_BITS,
    PRECEDENCE_OR,
    PRECEDENCE_AND,
    PRECEDENCE_EQUALITY,
    PRECEDENCE_COMPARE,
    PRECEDENCE_TERM,
    PRECEDENCE_FACTOR,
    PRECEDENCE_UNARY,
    PRECEDENCE_CALL,
};

enum StringStatus {
    STRING_STATUS_NONE,
    STRING_STATUS_BEGIN,
    STRING_STATUS_ADD,
    STRING_STATUS_CLOSE,
    STRING_STATUS_CONTINUE,
};

enum OpCode {
    OP_ADD,
    OP_ADD_LOCALS,
    OP_INCREMENT,
    OP_INSERT,
    OP_ARRAY_POP,
    OP_ARRAY_PUSH,
    OP_ARRAY_PUSH_LOCALS,
    OP_BIT_AND,
    OP_BIT_LEFT_SHIFT,
    OP_BIT_NOT,
    OP_BIT_OR,
    OP_BIT_RIGHT_SHIFT,
    OP_BIT_XOR,
    OP_CALL,
    OP_TAIL_CALL,
    OP_SELF,
    OP_CLEAR,
    OP_CONSTANT,
    OP_COPY,
    OP_DEFINE_GLOBAL,
    OP_DEBUG,
    OP_DELETE,
    OP_DIVIDE,
    OP_DUPLICATE,
    OP_ECHO,
    OP_EQUAL,
    OP_EXISTS,
    OP_FALSE,
    OP_GET_DYNAMIC,
    OP_GET_GLOBAL,
    OP_GET_GLOBAL_PROPERTY,
    OP_GET_LOCAL,
    OP_GET_LOCALS,
    OP_GET_PROPERTY,
    OP_GREATER,
    OP_GREATER_EQUAL,
    OP_INDEX,
    OP_INSPECT,
    OP_JUMP,
    OP_JUMP_IF_EQUAL,
    OP_JUMP_IF_NOT_EQUAL,
    OP_JUMP_IF_LESS,
    OP_JUMP_IF_GREATER,
    OP_JUMP_IF_GREATER_LOCALS,
    OP_JUMP_IF_LESS_EQUAL,
    OP_JUMP_IF_GREATER_EQUAL,
    OP_JUMP_IF_FALSE,
    OP_JUMP_IF_TRUE,
    OP_KEYS,
    OP_LEN,
    OP_LESS,
    OP_LESS_EQUAL,
    OP_LOOP,
    OP_MODULO,
    OP_MODULO_LOCALS,
    OP_MULTIPLY,
    OP_NEGATE,
    OP_NEW_ARRAY,
    OP_NEW_TABLE,
    OP_NONE,
    OP_NOT,
    OP_NOT_EQUAL,
    OP_POP,
    OP_POP_TWO,
    OP_POP_N,
    OP_PRINT,
    OP_RETURN,
    OP_SET_DYNAMIC,
    OP_SET_GLOBAL,
    OP_SET_LOCAL,
    OP_SET_PROPERTY,
    OP_INCREMENT_LOCAL,
    OP_INCREMENT_LOCAL_AND_SET,
    OP_INCREMENT_LOOP,
    OP_SLICE,
    OP_SUBTRACT,
    OP_THROW,
    OP_FLOAT,
    OP_INT,
    OP_STRING,
    OP_TRUE,
    OP_TYPE,
    OP_USE,
    OP_FOR,
    OP_FOR_LOOP,
    OP_VOID,
};

enum FunctionType {
    TYPE_FUNCTION,
    TYPE_SCRIPT,
    TYPE_DO,
    TYPE_REPL,
};

static void compile_with_precedence(Compiler *C, enum Precedence precedence);
static void compile_call(Compiler *C, bool assign);
static void compile_group(Compiler *C, bool assign);
static void compile_none(Compiler *C, bool assign);
static void compile_true(Compiler *C, bool assign);
static void compile_false(Compiler *C, bool assign);
static void compile_integer(Compiler *C, bool assign);
static void compile_float(Compiler *C, bool assign);
static void compile_string(Compiler *C, bool assign);
static void compile_array(Compiler *C, bool assign);
static void compile_table(Compiler *C, bool assign);
static void compile_variable(Compiler *C, bool assign);
static void compile_unary(Compiler *C, bool assign);
static void compile_binary(Compiler *C, bool assign);
static void compile_dot(Compiler *C, bool assign);
static void compile_pointer(Compiler *C, bool assign);
static void compile_square(Compiler *C, bool assign);
static void compile_and(Compiler *C, bool assign);
static void compile_or(Compiler *C, bool assign);
static void array_pop_expression(Compiler *C, bool assign);
static void delete_expression(Compiler *C, bool assign);
static void len_expression(Compiler *C, bool assign);
static void cast_integer_expression(Compiler *C, bool assign);
static void cast_float_expression(Compiler *C, bool assign);
static void cast_string_expression(Compiler *C, bool assign);
static void clear_expression(Compiler *C, bool assign);
static void copy_expression(Compiler *C, bool assign);
static void index_expression(Compiler *C, bool assign);
static void keys_expression(Compiler *C, bool assign);
static void type_expression(Compiler *C, bool assign);
static void exists_expression(Compiler *C, bool assign);
static void inspect_expression(Compiler *C, bool assign);
static void debug_expression(Compiler *C, bool assign);
static void function_expression(Compiler *C, bool assign);
static void declaration(Compiler *C);
static void statement(Compiler *C);
static void expression_statement(Compiler *C);
static void expression(Compiler *C);

static char *interpret(Hymn *H);

struct JumpList {
    int jump;
    int depth;
    HymnByteCode *code;
    JumpList *next;
};

struct LoopList {
    int start;
    int depth;
    HymnByteCode *code;
    LoopList *next;
    bool is_for;
    char padding[7];
};

struct Token {
    HymnInt integer;
    HymnFloat floating;
    int row;
    int column;
    size_t start;
    unsigned int length;
    enum TokenType type;
};

struct Local {
    Token name;
    int depth;
    char padding[4];
};

struct Rule {
    void (*prefix)(Compiler *, bool);
    void (*infix)(Compiler *, bool);
    enum Precedence precedence;
    char padding[4];
};

struct Scope {
    struct Scope *enclosing;
    HymnFunction *func;
    size_t begin;
    Local locals[HYMN_UINT8_COUNT];
    int local_count;
    int depth;
    enum FunctionType type;
    char padding[4];
};

struct Compiler {
    Hymn *H;
    Scope *scope;
    LoopList *loop;
    JumpList *jump;
    JumpList *jump_or;
    JumpList *jump_and;
    JumpList *jump_for;
    HymnString *error;
    const char *script;
    const char *source;
    size_t pos;
    size_t size;
    int pop;
    int barrier;
    int row;
    int column;
    Token previous;
    Token current;
    int string_format;
    enum StringStatus string_status;
    bool interactive;
    char padding[7];
};

struct CompileResult {
    HymnFunction *func;
    char *error;
};

HymnValue hymn_new_undefined(void) {
    return (HymnValue){.is = HYMN_VALUE_UNDEFINED, .as = {.i = 0}};
}

HymnValue hymn_new_none(void) {
    return (HymnValue){.is = HYMN_VALUE_NONE, .as = {.i = 0}};
}

HymnValue hymn_new_bool(bool v) {
    return (HymnValue){.is = HYMN_VALUE_BOOL, .as = {.b = v}};
}

HymnValue hymn_new_int(HymnInt v) {
    return (HymnValue){.is = HYMN_VALUE_INTEGER, .as = {.i = v}};
}

HymnValue hymn_new_float(HymnFloat v) {
    return (HymnValue){.is = HYMN_VALUE_FLOAT, .as = {.f = v}};
}

HymnValue hymn_new_native(HymnNativeFunction *v) {
    return (HymnValue){.is = HYMN_VALUE_FUNC_NATIVE, .as = {.o = (void *)v}};
}

HymnValue hymn_new_pointer(void *v) {
    return (HymnValue){.is = HYMN_VALUE_POINTER, .as = {.p = v}};
}

HymnValue hymn_new_string_value(HymnObjectString *v) {
    return (HymnValue){.is = HYMN_VALUE_STRING, .as = {.o = (void *)v}};
}

HymnValue hymn_new_array_value(HymnArray *v) {
    return (HymnValue){.is = HYMN_VALUE_ARRAY, .as = {.o = (void *)v}};
}

HymnValue hymn_new_table_value(HymnTable *v) {
    return (HymnValue){.is = HYMN_VALUE_TABLE, .as = {.o = (void *)v}};
}

HymnValue hymn_new_func_value(HymnFunction *v) {
    return (HymnValue){.is = HYMN_VALUE_FUNC, .as = {.o = (void *)v}};
}

bool hymn_as_bool(HymnValue v) {
    return (v).as.b;
}

HymnInt hymn_as_int(HymnValue v) {
    return (v).as.i;
}

HymnFloat hymn_as_float(HymnValue v) {
    return (v).as.f;
}

HymnNativeFunction *hymn_as_native(HymnValue v) {
    return (HymnNativeFunction *)(v).as.o;
}

void *hymn_as_pointer(HymnValue v) {
    return (v).as.p;
}

void *hymn_as_object(HymnValue v) {
    return (void *)(v).as.o;
}

HymnObjectString *hymn_as_hymn_string(HymnValue v) {
    return (HymnObjectString *)(v).as.o;
}

HymnString *hymn_as_string(HymnValue v) {
    return hymn_as_hymn_string(v)-&gt;string;
}

HymnArray *hymn_as_array(HymnValue v) {
    return (HymnArray *)(v).as.o;
}

HymnTable *hymn_as_table(HymnValue v) {
    return (HymnTable *)(v).as.o;
}

HymnFunction *hymn_as_func(HymnValue v) {
    return (HymnFunction *)(v).as.o;
}

bool hymn_is_undefined(HymnValue v) {
    return (v).is == HYMN_VALUE_UNDEFINED;
}

bool hymn_is_none(HymnValue v) {
    return (v).is == HYMN_VALUE_NONE;
}

bool hymn_is_bool(HymnValue v) {
    return (v).is == HYMN_VALUE_BOOL;
}

bool hymn_is_int(HymnValue v) {
    return (v).is == HYMN_VALUE_INTEGER;
}

bool hymn_is_float(HymnValue v) {
    return (v).is == HYMN_VALUE_FLOAT;
}

bool hymn_is_native(HymnValue v) {
    return (v).is == HYMN_VALUE_FUNC_NATIVE;
}

bool hymn_is_pointer(HymnValue v) {
    return (v).is == HYMN_VALUE_POINTER;
}

bool hymn_is_string(HymnValue v) {
    return (v).is == HYMN_VALUE_STRING;
}

bool hymn_is_array(HymnValue v) {
    return (v).is == HYMN_VALUE_ARRAY;
}

bool hymn_is_table(HymnValue v) {
    return (v).is == HYMN_VALUE_TABLE;
}

bool hymn_is_func(HymnValue v) {
    return (v).is == HYMN_VALUE_FUNC;
}

static Rule rules[] = {
    [TOKEN_ADD] = {NULL, compile_binary, PRECEDENCE_TERM, {0}},
    [TOKEN_AND] = {NULL, compile_and, PRECEDENCE_AND, {0}},
    [TOKEN_ASSIGN] = {NULL, NULL, PRECEDENCE_NONE, {0}},
    [TOKEN_ASSIGN_ADD] = {NULL, NULL, PRECEDENCE_NONE, {0}},
    [TOKEN_ASSIGN_BIT_AND] = {NULL, NULL, PRECEDENCE_NONE, {0}},
    [TOKEN_ASSIGN_BIT_LEFT_SHIFT] = {NULL, NULL, PRECEDENCE_NONE, {0}},
    [TOKEN_ASSIGN_BIT_OR] = {NULL, NULL, PRECEDENCE_NONE, {0}},
    [TOKEN_ASSIGN_BIT_RIGHT_SHIFT] = {NULL, NULL, PRECEDENCE_NONE, {0}},
    [TOKEN_ASSIGN_BIT_XOR] = {NULL, NULL, PRECEDENCE_NONE, {0}},
    [TOKEN_ASSIGN_DIVIDE] = {NULL, NULL, PRECEDENCE_NONE, {0}},
    [TOKEN_ASSIGN_MODULO] = {NULL, NULL, PRECEDENCE_NONE, {0}},
    [TOKEN_ASSIGN_MULTIPLY] = {NULL, NULL, PRECEDENCE_NONE, {0}},
    [TOKEN_ASSIGN_SUBTRACT] = {NULL, NULL, PRECEDENCE_NONE, {0}},
    [TOKEN_BIT_AND] = {NULL, compile_binary, PRECEDENCE_BITS, {0}},
    [TOKEN_BIT_LEFT_SHIFT] = {NULL, compile_binary, PRECEDENCE_BITS, {0}},
    [TOKEN_BIT_NOT] = {compile_unary, NULL, PRECEDENCE_NONE, {0}},
    [TOKEN_BIT_OR] = {NULL, compile_binary, PRECEDENCE_BITS, {0}},
    [TOKEN_BIT_RIGHT_SHIFT] = {NULL, compile_binary, PRECEDENCE_BITS, {0}},
    [TOKEN_BIT_XOR] = {NULL, compile_binary, PRECEDENCE_BITS, {0}},
    [TOKEN_BREAK] = {NULL, NULL, PRECEDENCE_NONE, {0}},
    [TOKEN_CLEAR] = {clear_expression, NULL, PRECEDENCE_NONE, {0}},
    [TOKEN_COLON] = {NULL, NULL, PRECEDENCE_NONE, {0}},
    [TOKEN_COMMA] = {NULL, NULL, PRECEDENCE_NONE, {0}},
    [TOKEN_CONTINUE] = {NULL, NULL, PRECEDENCE_NONE, {0}},
    [TOKEN_COPY] = {copy_expression, NULL, PRECEDENCE_NONE, {0}},
    [TOKEN_DEBUG] = {debug_expression, NULL, PRECEDENCE_NONE, {0}},
    [TOKEN_DELETE] = {delete_expression, NULL, PRECEDENCE_NONE, {0}},
    [TOKEN_DIVIDE] = {NULL, compile_binary, PRECEDENCE_FACTOR, {0}},
    [TOKEN_DOT] = {NULL, compile_dot, PRECEDENCE_CALL, {0}},
    [TOKEN_ECHO] = {NULL, NULL, PRECEDENCE_NONE, {0}},
    [TOKEN_ELIF] = {NULL, NULL, PRECEDENCE_NONE, {0}},
    [TOKEN_ELSE] = {NULL, NULL, PRECEDENCE_NONE, {0}},
    [TOKEN_EOF] = {NULL, NULL, PRECEDENCE_NONE, {0}},
    [TOKEN_EQUAL] = {NULL, compile_binary, PRECEDENCE_EQUALITY, {0}},
    [TOKEN_ERROR] = {NULL, NULL, PRECEDENCE_NONE, {0}},
    [TOKEN_EXCEPT] = {NULL, NULL, PRECEDENCE_NONE, {0}},
    [TOKEN_EXISTS] = {exists_expression, NULL, PRECEDENCE_NONE, {0}},
    [TOKEN_FALSE] = {compile_false, NULL, PRECEDENCE_NONE, {0}},
    [TOKEN_FLOAT] = {compile_float, NULL, PRECEDENCE_NONE, {0}},
    [TOKEN_FOR] = {NULL, NULL, PRECEDENCE_NONE, {0}},
    [TOKEN_FUNCTION] = {function_expression, NULL, PRECEDENCE_NONE, {0}},
    [TOKEN_GREATER] = {NULL, compile_binary, PRECEDENCE_COMPARE, {0}},
    [TOKEN_GREATER_EQUAL] = {NULL, compile_binary, PRECEDENCE_COMPARE, {0}},
    [TOKEN_IDENT] = {compile_variable, NULL, PRECEDENCE_NONE, {0}},
    [TOKEN_INSPECT] = {inspect_expression, NULL, PRECEDENCE_NONE, {0}},
    [TOKEN_IF] = {NULL, NULL, PRECEDENCE_NONE, {0}},
    [TOKEN_IN] = {NULL, NULL, PRECEDENCE_NONE, {0}},
    [TOKEN_INDEX] = {index_expression, NULL, PRECEDENCE_NONE, {0}},
    [TOKEN_INSERT] = {NULL, NULL, PRECEDENCE_NONE, {0}},
    [TOKEN_INTEGER] = {compile_integer, NULL, PRECEDENCE_NONE, {0}},
    [TOKEN_KEYS] = {keys_expression, NULL, PRECEDENCE_NONE, {0}},
    [TOKEN_LEFT_CURLY] = {compile_table, NULL, PRECEDENCE_NONE, {0}},
    [TOKEN_LEFT_PAREN] = {compile_group, compile_call, PRECEDENCE_CALL, {0}},
    [TOKEN_LEFT_SQUARE] = {compile_array, compile_square, PRECEDENCE_CALL, {0}},
    [TOKEN_LEN] = {len_expression, NULL, PRECEDENCE_NONE, {0}},
    [TOKEN_LESS] = {NULL, compile_binary, PRECEDENCE_COMPARE, {0}},
    [TOKEN_LESS_EQUAL] = {NULL, compile_binary, PRECEDENCE_COMPARE, {0}},
    [TOKEN_LET] = {NULL, NULL, PRECEDENCE_NONE, {0}},
    [TOKEN_MODULO] = {NULL, compile_binary, PRECEDENCE_FACTOR, {0}},
    [TOKEN_MULTIPLY] = {NULL, compile_binary, PRECEDENCE_FACTOR, {0}},
    [TOKEN_NONE] = {compile_none, NULL, PRECEDENCE_NONE, {0}},
    [TOKEN_NOT] = {compile_unary, NULL, PRECEDENCE_NONE, {0}},
    [TOKEN_NOT_EQUAL] = {NULL, compile_binary, PRECEDENCE_EQUALITY, {0}},
    [TOKEN_OR] = {NULL, compile_or, PRECEDENCE_OR, {0}},
    [TOKEN_POINTER] = {NULL, compile_pointer, PRECEDENCE_CALL, {0}},
    [TOKEN_POP] = {array_pop_expression, NULL, PRECEDENCE_NONE, {0}},
    [TOKEN_PRINT] = {NULL, NULL, PRECEDENCE_NONE, {0}},
    [TOKEN_PUSH] = {NULL, NULL, PRECEDENCE_NONE, {0}},
    [TOKEN_RETURN] = {NULL, NULL, PRECEDENCE_NONE, {0}},
    [TOKEN_RIGHT_CURLY] = {NULL, NULL, PRECEDENCE_NONE, {0}},
    [TOKEN_RIGHT_PAREN] = {NULL, NULL, PRECEDENCE_NONE, {0}},
    [TOKEN_RIGHT_SQUARE] = {NULL, NULL, PRECEDENCE_NONE, {0}},
    [TOKEN_STRING] = {compile_string, NULL, PRECEDENCE_NONE, {0}},
    [TOKEN_SUBTRACT] = {compile_unary, compile_binary, PRECEDENCE_TERM, {0}},
    [TOKEN_THROW] = {NULL, NULL, PRECEDENCE_NONE, {0}},
    [TOKEN_TO_FLOAT] = {cast_float_expression, NULL, PRECEDENCE_NONE, {0}},
    [TOKEN_TO_INTEGER] = {cast_integer_expression, NULL, PRECEDENCE_NONE, {0}},
    [TOKEN_TO_STRING] = {cast_string_expression, NULL, PRECEDENCE_NONE, {0}},
    [TOKEN_TRUE] = {compile_true, NULL, PRECEDENCE_NONE, {0}},
    [TOKEN_TRY] = {NULL, NULL, PRECEDENCE_NONE, {0}},
    [TOKEN_TYPE_FUNC] = {type_expression, NULL, PRECEDENCE_NONE, {0}},
    [TOKEN_UNDEFINED] = {NULL, NULL, PRECEDENCE_NONE, {0}},
    [TOKEN_USE] = {NULL, NULL, PRECEDENCE_NONE, {0}},
    [TOKEN_VALUE] = {NULL, NULL, PRECEDENCE_NONE, {0}},
    [TOKEN_WHILE] = {NULL, NULL, PRECEDENCE_NONE, {0}},
};

const char *hymn_value_type(enum HymnValueType type) {
    switch (type) {
    case HYMN_VALUE_UNDEFINED: return &quot;undefined&quot;;
    case HYMN_VALUE_NONE: return &quot;none&quot;;
    case HYMN_VALUE_BOOL: return &quot;boolean&quot;;
    case HYMN_VALUE_INTEGER: return &quot;integer&quot;;
    case HYMN_VALUE_FLOAT: return &quot;float&quot;;
    case HYMN_VALUE_STRING: return &quot;string&quot;;
    case HYMN_VALUE_ARRAY: return &quot;array&quot;;
    case HYMN_VALUE_TABLE: return &quot;table&quot;;
    case HYMN_VALUE_FUNC: return &quot;function&quot;;
    case HYMN_VALUE_FUNC_NATIVE: return &quot;native&quot;;
    case HYMN_VALUE_POINTER: return &quot;pointer&quot;;
    default: return &quot;?&quot;;
    }
}

static unsigned int string_mix_code(HymnString *key) {
    size_t length = hymn_string_len(key);
    unsigned int hash = 0;
    for (size_t i = 0; i &lt; length; i++) {
        hash = 31 * hash + (unsigned int)key[i];
    }
    return hash ^ (hash &gt;&gt; 16);
}

static unsigned int string_mix_code_const(const char *key) {
    size_t length = strlen(key);
    unsigned int hash = 0;
    for (size_t i = 0; i &lt; length; i++) {
        hash = 31 * hash + (unsigned int)key[i];
    }
    return hash ^ (hash &gt;&gt; 16);
}

static HymnObjectString *new_hymn_string_with_hash(HymnString *string, unsigned int hash) {
    HymnObjectString *object = hymn_calloc(1, sizeof(HymnObjectString));
    object-&gt;string = string;
    object-&gt;hash = hash;
    return object;
}

HymnObjectString *hymn_new_string_object(HymnString *string) {
    return new_hymn_string_with_hash(string, string_mix_code(string));
}

static void table_init(HymnTable *this) {
    this-&gt;size = 0;
    this-&gt;bins = INITIAL_BINS;
    this-&gt;items = hymn_calloc(this-&gt;bins, sizeof(HymnTableItem *));
}

static unsigned int table_get_bin(HymnTable *this, unsigned int hash) {
    return (this-&gt;bins - 1U) & hash;
}

static void table_resize(HymnTable *this) {
    unsigned int old_bins = this-&gt;bins;

    if (old_bins &gt;= MAXIMUM_BINS) {
        return;
    }

    unsigned int bins = old_bins &lt;&lt; 1U;

    HymnTableItem **old_items = this-&gt;items;
    HymnTableItem **items = hymn_calloc(bins, sizeof(HymnTableItem *));

    for (unsigned int i = 0; i &lt; old_bins; i++) {
        HymnTableItem *item = old_items[i];
        if (item == NULL) {
            continue;
        }
        if (item-&gt;next == NULL) {
            items[(bins - 1) & item-&gt;key-&gt;hash] = item;
        } else {
            HymnTableItem *low_head = NULL;
            HymnTableItem *low_tail = NULL;
            HymnTableItem *high_head = NULL;
            HymnTableItem *high_tail = NULL;
            do {
                if ((old_bins & item-&gt;key-&gt;hash) == 0) {
                    if (low_tail == NULL) {
                        low_head = item;
                    } else {
                        low_tail-&gt;next = item;
                    }
                    low_tail = item;
                } else {
                    if (high_tail == NULL) {
                        high_head = item;
                    } else {
                        high_tail-&gt;next = item;
                    }
                    high_tail = item;
                }
                item = item-&gt;next;
            } while (item != NULL);

            if (low_tail != NULL) {
                low_tail-&gt;next = NULL;
                items[i] = low_head;
            }

            if (high_tail != NULL) {
                high_tail-&gt;next = NULL;
                items[i + old_bins] = high_head;
            }
        }
    }

    free(old_items);

    this-&gt;bins = bins;
    this-&gt;items = items;
}

static HymnValue table_put(HymnTable *this, HymnObjectString *key, HymnValue value) {
    unsigned int bin = table_get_bin(this, key-&gt;hash);
    HymnTableItem *item = this-&gt;items[bin];
    HymnTableItem *previous = NULL;
    while (item != NULL) {
        if (key == item-&gt;key) {
            HymnValue old = item-&gt;value;
            item-&gt;value = value;
            return old;
        }
        previous = item;
        item = item-&gt;next;
    }
    item = hymn_malloc(sizeof(HymnTableItem));
    item-&gt;key = key;
    item-&gt;value = value;
    item-&gt;next = NULL;
    if (previous == NULL) {
        this-&gt;items[bin] = item;
    } else {
        previous-&gt;next = item;
    }
    this-&gt;size++;
    if (this-&gt;size &gt;= (int)((float)this-&gt;bins * LOAD_FACTOR)) {
        table_resize(this);
    }
    return hymn_new_undefined();
}

static HymnValue table_get(HymnTable *this, HymnObjectString *key) {
    unsigned int bin = table_get_bin(this, key-&gt;hash);
    HymnTableItem *item = this-&gt;items[bin];
    while (item != NULL) {
        if (key == item-&gt;key) {
            return item-&gt;value;
        }
        item = item-&gt;next;
    }
    return hymn_new_undefined();
}

HymnValue hymn_table_get(HymnTable *this, const char *key) {
    unsigned int hash = string_mix_code_const(key);
    unsigned int bin = table_get_bin(this, hash);
    HymnTableItem *item = this-&gt;items[bin];
    while (item != NULL) {
        if (hymn_string_equal(key, item-&gt;key-&gt;string)) {
            return item-&gt;value;
        }
        item = item-&gt;next;
    }
    return hymn_new_undefined();
}

static HymnTableItem *table_next(HymnTable *this, HymnObjectString *key) {
    unsigned int bins = this-&gt;bins;
    if (key == NULL) {
        for (unsigned int i = 0; i &lt; bins; i++) {
            HymnTableItem *item = this-&gt;items[i];
            if (item != NULL) {
                return item;
            }
        }
        return NULL;
    }
    unsigned int bin = table_get_bin(this, key-&gt;hash);
    {
        HymnTableItem *item = this-&gt;items[bin];
        while (item != NULL) {
            HymnTableItem *next = item-&gt;next;
            if (key == item-&gt;key) {
                if (next != NULL) {
                    return next;
                }
            }
            item = next;
        }
    }
    for (unsigned int i = bin + 1; i &lt; bins; i++) {
        HymnTableItem *item = this-&gt;items[i];
        if (item != NULL) {
            return item;
        }
    }
    return NULL;
}

static HymnValue table_remove(HymnTable *this, HymnObjectString *key) {
    unsigned int bin = table_get_bin(this, key-&gt;hash);
    HymnTableItem *item = this-&gt;items[bin];
    HymnTableItem *previous = NULL;
    while (item != NULL) {
        if (key == item-&gt;key) {
            if (previous == NULL) {
                this-&gt;items[bin] = item-&gt;next;
            } else {
                previous-&gt;next = item-&gt;next;
            }
            HymnValue value = item-&gt;value;
            free(item);
            this-&gt;size--;
            return value;
        }
        previous = item;
        item = item-&gt;next;
    }
    return hymn_new_undefined();
}

static void table_clear(Hymn *H, HymnTable *this) {
    this-&gt;size = 0;
    unsigned int bins = this-&gt;bins;
    for (unsigned int i = 0; i &lt; bins; i++) {
        HymnTableItem *item = this-&gt;items[i];
        while (item != NULL) {
            HymnTableItem *next = item-&gt;next;
            hymn_dereference(H, item-&gt;value);
            hymn_dereference_string(H, item-&gt;key);
            free(item);
            item = next;
        }
        this-&gt;items[i] = NULL;
    }
}

static void table_release(Hymn *H, HymnTable *this) {
    table_clear(H, this);
    free(this-&gt;items);
}

static void table_delete(Hymn *H, HymnTable *this) {
    table_release(H, this);
    free(this);
}

void hymn_set_property(Hymn *H, HymnTable *table, HymnObjectString *name, HymnValue value) {
    hymn_reference(value);
    HymnValue previous = table_put(table, name, value);
    if (hymn_is_undefined(previous)) {
        hymn_reference_string(name);
    } else {
        hymn_dereference(H, previous);
    }
}

void hymn_set_property_const(Hymn *H, HymnTable *table, const char *name, HymnValue value) {
    HymnObjectString *key = hymn_new_intern_string(H, name);
    hymn_set_property(H, table, key, value);
}

static void set_init(HymnSet *this) {
    this-&gt;size = 0;
    this-&gt;bins = INITIAL_BINS;
    this-&gt;items = hymn_calloc(this-&gt;bins, sizeof(HymnSetItem *));
}

static unsigned int set_get_bin(HymnSet *this, unsigned int hash) {
    return (this-&gt;bins - 1U) & hash;
}

static void set_resize(HymnSet *this) {
    unsigned int old_bins = this-&gt;bins;

    if (old_bins &gt;= MAXIMUM_BINS) {
        return;
    }

    unsigned int bins = old_bins &lt;&lt; 1U;

    HymnSetItem **old_items = this-&gt;items;
    HymnSetItem **items = hymn_calloc(bins, sizeof(HymnSetItem *));

    for (unsigned int i = 0; i &lt; old_bins; i++) {
        HymnSetItem *item = old_items[i];
        if (item == NULL) {
            continue;
        }
        if (item-&gt;next == NULL) {
            items[(bins - 1) & item-&gt;string-&gt;hash] = item;
        } else {
            HymnSetItem *low_head = NULL;
            HymnSetItem *low_tail = NULL;
            HymnSetItem *high_head = NULL;
            HymnSetItem *high_tail = NULL;
            do {
                if ((old_bins & item-&gt;string-&gt;hash) == 0) {
                    if (low_tail == NULL) {
                        low_head = item;
                    } else {
                        low_tail-&gt;next = item;
                    }
                    low_tail = item;
                } else {
                    if (high_tail == NULL) {
                        high_head = item;
                    } else {
                        high_tail-&gt;next = item;
                    }
                    high_tail = item;
                }
                item = item-&gt;next;
            } while (item != NULL);

            if (low_tail != NULL) {
                low_tail-&gt;next = NULL;
                items[i] = low_head;
            }

            if (high_tail != NULL) {
                high_tail-&gt;next = NULL;
                items[i + old_bins] = high_head;
            }
        }
    }

    free(old_items);

    this-&gt;bins = bins;
    this-&gt;items = items;
}

static HymnObjectString *set_add_or_get(HymnSet *this, HymnString *add) {
    unsigned int hash = string_mix_code(add);
    unsigned int bin = set_get_bin(this, hash);
    HymnSetItem *item = this-&gt;items[bin];
    HymnSetItem *previous = NULL;
    while (item != NULL) {
        if (hymn_string_equal(add, item-&gt;string-&gt;string)) {
            return item-&gt;string;
        }
        previous = item;
        item = item-&gt;next;
    }
    HymnObjectString *new = new_hymn_string_with_hash(add, hash);
    item = hymn_malloc(sizeof(HymnSetItem));
    item-&gt;string = new;
    item-&gt;next = NULL;
    if (previous == NULL) {
        this-&gt;items[bin] = item;
    } else {
        previous-&gt;next = item;
    }
    this-&gt;size++;
    if (this-&gt;size &gt;= (int)((float)this-&gt;bins * LOAD_FACTOR)) {
        set_resize(this);
    }
    return new;
}

static HymnObjectString *set_remove(HymnSet *this, HymnString *remove) {
    unsigned int hash = string_mix_code(remove);
    unsigned int bin = set_get_bin(this, hash);
    HymnSetItem *item = this-&gt;items[bin];
    HymnSetItem *previous = NULL;
    while (item != NULL) {
        if (hymn_string_equal(remove, item-&gt;string-&gt;string)) {
            if (previous == NULL) {
                this-&gt;items[bin] = item-&gt;next;
            } else {
                previous-&gt;next = item-&gt;next;
            }
            HymnObjectString *string = item-&gt;string;
            free(item);
            this-&gt;size--;
            return string;
        }
        previous = item;
        item = item-&gt;next;
    }
    return NULL;
}

static HymnByteCode *current(Compiler *C) {
    return &C-&gt;scope-&gt;func-&gt;code;
}

static void compile_error(Compiler *C, Token *token, const char *format, ...) {
    if (C-&gt;error != NULL) {
        return;
    }

    if (C-&gt;interactive && token-&gt;type == TOKEN_EOF) {
        C-&gt;error = hymn_new_string(&quot;&lt;eof&gt;&quot;);
        goto clean;
    }

    va_list ap;
    va_start(ap, format);
    size_t len = (size_t)vsnprintf(NULL, 0, format, ap);
    va_end(ap);
    char *chars = hymn_malloc((len + 1) * sizeof(char));
    va_start(ap, format);
    len = (size_t)vsnprintf(chars, len + 1, format, ap);
    va_end(ap);

    HymnString *error = hymn_new_string_with_capacity(len + 128);
    error = hymn_string_append(error, chars);

    free(chars);

    if (token-&gt;type != TOKEN_EOF && token-&gt;length &gt; 0) {
        const char *source = C-&gt;source;
        const size_t size = C-&gt;size;
        const size_t start = token-&gt;start;

        size_t begin = start;
        while (true) {
            if (source[begin] == '\n') {
                begin++;
                break;
            }
            if (begin == 0) break;
            begin--;
        }

        while (true) {
            if (source[begin] != ' ' || begin == size) break;
            begin++;
        }

        size_t end = start;
        while (true) {
            if (source[end] == '\n' || end == size) break;
            end++;
        }

        if (begin &lt; end) {
            error = string_append_format(error, &quot;\n  | %.*s\n    &quot;, end - begin, &source[begin]);
            for (int i = 0; i &lt; (int)(start - begin); i++) {
                error = hymn_string_append_char(error, ' ');
            }
            error = hymn_string_append(error, ANSI_COLOR_RED);
            for (unsigned int i = 0; i &lt; token-&gt;length; i++) {
                error = hymn_string_append_char(error, '^');
            }
            error = hymn_string_append(error, ANSI_COLOR_RESET);
        }
    }

    error = string_append_format(error, &quot;\n  at %s:%d&quot;, C-&gt;script == NULL ? &quot;script&quot; : C-&gt;script, token-&gt;row);

    C-&gt;error = error;

clean:
    C-&gt;current.type = TOKEN_EOF;
    C-&gt;previous.type = TOKEN_EOF;
}

static char next_char(Compiler *C) {
    size_t pos = C-&gt;pos;
    if (pos == C-&gt;size) {
        return '\0';
    }
    char c = C-&gt;source[pos];
    C-&gt;pos = pos + 1;
    if (c == '\n') {
        C-&gt;row++;
        C-&gt;column = 0;
    } else {
        C-&gt;column++;
    }
    return c;
}

static char peek_char(Compiler *C) {
    if (C-&gt;pos == C-&gt;size) {
        return '\0';
    }
    return C-&gt;source[C-&gt;pos];
}

static char peek_two_char(Compiler *C) {
    if (C-&gt;pos + 1 &gt;= C-&gt;size) {
        return '\0';
    }
    return C-&gt;source[C-&gt;pos + 1];
}

static void token(Compiler *C, enum TokenType type) {
    Token *current = &C-&gt;current;
    current-&gt;type = type;
    current-&gt;row = C-&gt;row;
    current-&gt;column = C-&gt;column;
    if (C-&gt;pos == 0) {
        current-&gt;start = 0;
    } else {
        current-&gt;start = C-&gt;pos - 1;
    }
    current-&gt;length = 1;
}

static void token_special(Compiler *C, enum TokenType type, size_t offset, size_t length) {
    Token *current = &C-&gt;current;
    current-&gt;type = type;
    current-&gt;row = C-&gt;row;
    current-&gt;column = C-&gt;column;
    if (C-&gt;pos &lt; offset) {
        current-&gt;start = 0;
    } else {
        current-&gt;start = C-&gt;pos - offset;
    }
    current-&gt;length = (unsigned int)length;
}

static void value_token(Compiler *C, enum TokenType type, size_t start, size_t end) {
    Token *current = &C-&gt;current;
    current-&gt;type = type;
    current-&gt;row = C-&gt;row;
    current-&gt;column = C-&gt;column;
    current-&gt;start = start;
    current-&gt;length = (unsigned int)(end - start);
}

static void int_token(Compiler *C, enum TokenType type, size_t start, size_t end, HymnInt integer) {
    Token *current = &C-&gt;current;
    current-&gt;type = type;
    current-&gt;row = C-&gt;row;
    current-&gt;column = C-&gt;column;
    current-&gt;start = start;
    current-&gt;length = (unsigned int)(end - start);
    current-&gt;integer = integer;
}

static void float_token(Compiler *C, enum TokenType type, size_t start, size_t end, HymnFloat floating) {
    Token *current = &C-&gt;current;
    current-&gt;type = type;
    current-&gt;row = C-&gt;row;
    current-&gt;column = C-&gt;column;
    current-&gt;start = start;
    current-&gt;length = (unsigned int)(end - start);
    current-&gt;floating = floating;
}

static enum TokenType ident_trie(const char *ident, int offset, const char *rest, enum TokenType type) {
    int i = 0;
    do {
        if (ident[offset + i] != rest[i]) {
            return TOKEN_UNDEFINED;
        }
        i++;
    } while (rest[i] != '\0');
    return type;
}

static enum TokenType ident_keyword(const char *ident, size_t size) {
    switch (ident[0]) {
    case 'o':
        if (size == 2) return ident_trie(ident, 1, &quot;r&quot;, TOKEN_OR);
        break;
    case 'u':
        if (size == 3) return ident_trie(ident, 1, &quot;se&quot;, TOKEN_USE);
        break;
    case 'a':
        if (size == 3) return ident_trie(ident, 1, &quot;nd&quot;, TOKEN_AND);
        break;
    case 'n':
        if (size == 4) return ident_trie(ident, 1, &quot;one&quot;, TOKEN_NONE);
        break;
    case 'w':
        if (size == 5) return ident_trie(ident, 1, &quot;hile&quot;, TOKEN_WHILE);
        break;
    case 'b':
        if (size == 5) return ident_trie(ident, 1, &quot;reak&quot;, TOKEN_BREAK);
        break;
    case 'd':
        if (size == 5) return ident_trie(ident, 1, &quot;ebug&quot;, TOKEN_DEBUG);
        if (size == 6) return ident_trie(ident, 1, &quot;elete&quot;, TOKEN_DELETE);
        break;
    case 'r':
        if (size == 6) return ident_trie(ident, 1, &quot;eturn&quot;, TOKEN_RETURN);
        break;
    case 's':
        if (size == 3) return ident_trie(ident, 1, &quot;tr&quot;, TOKEN_TO_STRING);
        break;
    case 'k':
        if (size == 4) return ident_trie(ident, 1, &quot;eys&quot;, TOKEN_KEYS);
        break;
    case 'c':
        if (size == 4) return ident_trie(ident, 1, &quot;opy&quot;, TOKEN_COPY);
        if (size == 5) return ident_trie(ident, 1, &quot;lear&quot;, TOKEN_CLEAR);
        if (size == 8) return ident_trie(ident, 1, &quot;ontinue&quot;, TOKEN_CONTINUE);
        break;
    case 'l':
        if (size == 3 && ident[1] == 'e') {
            if (ident[2] == 't') return TOKEN_LET;
            if (ident[2] == 'n') return TOKEN_LEN;
        }
        break;
    case 't':
        if (size == 3) return ident_trie(ident, 1, &quot;ry&quot;, TOKEN_TRY);
        if (size == 5) return ident_trie(ident, 1, &quot;hrow&quot;, TOKEN_THROW);
        if (size == 4) {
            if (ident[1] == 'r') return ident_trie(ident, 2, &quot;ue&quot;, TOKEN_TRUE);
            if (ident[1] == 'y') return ident_trie(ident, 2, &quot;pe&quot;, TOKEN_TYPE_FUNC);
        }
        break;
    case 'i':
        if (size == 3) return ident_trie(ident, 1, &quot;nt&quot;, TOKEN_TO_INTEGER);
        if (size == 5) return ident_trie(ident, 1, &quot;ndex&quot;, TOKEN_INDEX);
        if (size == 6) return ident_trie(ident, 1, &quot;nsert&quot;, TOKEN_INSERT);
        if (size == 7) return ident_trie(ident, 1, &quot;nspect&quot;, TOKEN_INSPECT);
        if (size == 2) {
            if (ident[1] == 'f') return TOKEN_IF;
            if (ident[1] == 'n') return TOKEN_IN;
        }
        break;
    case 'p':
        if (size == 3) return ident_trie(ident, 1, &quot;op&quot;, TOKEN_POP);
        if (size == 5) return ident_trie(ident, 1, &quot;rint&quot;, TOKEN_PRINT);
        if (size == 4) return ident_trie(ident, 1, &quot;ush&quot;, TOKEN_PUSH);
        break;
    case 'e':
        if (size == 6) {
            if (ident[1] == 'x') {
                if (ident[2] == 'c') return ident_trie(ident, 3, &quot;ept&quot;, TOKEN_EXCEPT);
                if (ident[2] == 'i') return ident_trie(ident, 3, &quot;sts&quot;, TOKEN_EXISTS);
            }
        } else if (size == 4) {
            if (ident[1] == 'l') {
                if (ident[2] == 's') {
                    if (ident[3] == 'e') {
                        return TOKEN_ELSE;
                    }
                } else if (ident[2] == 'i' && ident[3] == 'f') {
                    return TOKEN_ELIF;
                }
            } else if (ident[1] == 'c') {
                return ident_trie(ident, 2, &quot;ho&quot;, TOKEN_ECHO);
            }
        }
        break;
    case 'f':
        if (size == 3) return ident_trie(ident, 1, &quot;or&quot;, TOKEN_FOR);
        if (size == 4) return ident_trie(ident, 1, &quot;unc&quot;, TOKEN_FUNCTION);
        if (size == 5) {
            if (ident[1] == 'a') return ident_trie(ident, 2, &quot;lse&quot;, TOKEN_FALSE);
            if (ident[1] == 'l') return ident_trie(ident, 2, &quot;oat&quot;, TOKEN_TO_FLOAT);
        }
        break;
    default:
        break;
    }
    return TOKEN_UNDEFINED;
}

static void push_ident_token(Compiler *C, size_t start, size_t end) {
    const char *ident = &C-&gt;source[start];
    size_t size = end - start;
    enum TokenType keyword = ident_keyword(ident, size);
    if (keyword != TOKEN_UNDEFINED && C-&gt;previous.type != TOKEN_DOT) {
        value_token(C, keyword, start, end);
    } else {
        value_token(C, TOKEN_IDENT, start, end);
    }
}

static bool is_digit(char c) {
    return c &gt;= '0' && c &lt;= '9';
}

static bool is_ident(char c) {
    return (c &gt;= 'a' && c &lt;= 'z') || (c &gt;= 'A' && c &lt;= 'Z') || (c &gt;= '0' && c &lt;= '9') || c == '_';
}

static enum StringStatus string_status(Compiler *C) {
    size_t i = C-&gt;pos;
    const char *source = C-&gt;source;
    const size_t size = C-&gt;size;
    bool expression = false;
    int brackets = 1;
    while (true) {
        if (i &gt;= size) return false;
        switch (source[i]) {
        case '}':
            if (brackets &gt; 1) {
                expression = true;
                i++;
                brackets--;
                continue;
            }
            return expression ? STRING_STATUS_BEGIN : STRING_STATUS_CONTINUE;
        case '&quot;':
            return STRING_STATUS_NONE;
        case ' ':
        case '\t':
        case '\r':
        case '\n':
            i++;
            continue;
        case '{':
            expression = true;
            i++;
            brackets++;
            continue;
        default:
            expression = true;
            i++;
            continue;
        }
    }
}

static void parse_string(Compiler *C, size_t start) {
    while (true) {
        char c = next_char(C);
        if (c == '\\') {
            next_char(C);
            continue;
        } else if (c == '$') {
            if (peek_char(C) == '{') {
                next_char(C);
                enum StringStatus status = string_status(C);
                if (status == STRING_STATUS_BEGIN) {
                    C-&gt;string_format = 1;
                    C-&gt;string_status = STRING_STATUS_BEGIN;
                    size_t end = C-&gt;pos - 2;
                    value_token(C, TOKEN_STRING, start, end);
                    return;
                } else if (status == STRING_STATUS_CONTINUE) {
                    C-&gt;string_status = STRING_STATUS_CONTINUE;
                    size_t end = C-&gt;pos - 2;
                    value_token(C, TOKEN_STRING, start, end);
                    while (true) {
                        c = next_char(C);
                        if (c == '}' || c == '\0') return;
                    }
                } else {
                    continue;
                }
            }
        } else if (c == '&quot;' || c == '\0') {
            break;
        }
    }
    size_t end = C-&gt;pos - 1;
    value_token(C, TOKEN_STRING, start, end);
}

static void advance(Compiler *C) {
    C-&gt;previous = C-&gt;current;
    if (C-&gt;previous.type == TOKEN_EOF) {
        return;
    }
    switch (C-&gt;string_status) {
    case STRING_STATUS_BEGIN:
        C-&gt;string_status = STRING_STATUS_ADD;
        token(C, TOKEN_ADD);
        return;
    case STRING_STATUS_ADD:
        C-&gt;string_status = STRING_STATUS_NONE;
        token(C, TOKEN_LEFT_PAREN);
        return;
    case STRING_STATUS_CLOSE:
        C-&gt;string_status = STRING_STATUS_CONTINUE;
        token(C, TOKEN_ADD);
        return;
    case STRING_STATUS_CONTINUE: {
        C-&gt;string_status = STRING_STATUS_NONE;
        size_t start = C-&gt;pos;
        parse_string(C, start);
        return;
    }
    default:
        break;
    }
    while (true) {
        char c = next_char(C);
        switch (c) {
        case ' ':
        case '\t':
        case '\r':
        case '\n':
            c = peek_char(C);
            while (c != '\0' && (c == ' ' || c == '\t' || c == '\r' || c == '\n')) {
                next_char(C);
                c = peek_char(C);
            }
            continue;
        case '#': {
            next_char(C);
            c = peek_char(C);
            while (c != '\n' && c != '\0') {
                next_char(C);
                c = peek_char(C);
            }
            continue;
        }
        case '!':
            if (peek_char(C) == '=') {
                next_char(C);
                token_special(C, TOKEN_NOT_EQUAL, 2, 2);
            } else {
                token(C, TOKEN_NOT);
            }
            return;
        case '=':
            if (peek_char(C) == '=') {
                next_char(C);
                token_special(C, TOKEN_EQUAL, 2, 2);
            } else {
                token(C, TOKEN_ASSIGN);
            }
            return;
        case '-': {
            if (peek_char(C) == '=') {
                next_char(C);
                token_special(C, TOKEN_ASSIGN_SUBTRACT, 2, 2);
                return;
            } else if (peek_char(C) == '&gt;') {
                next_char(C);
                token_special(C, TOKEN_POINTER, 2, 2);
                return;
            } else {
                token(C, TOKEN_SUBTRACT);
                return;
            }
        }
        case '+':
            if (peek_char(C) == '=') {
                next_char(C);
                token_special(C, TOKEN_ASSIGN_ADD, 2, 2);
            } else {
                token(C, TOKEN_ADD);
            }
            return;
        case '*':
            if (peek_char(C) == '=') {
                next_char(C);
                token_special(C, TOKEN_ASSIGN_MULTIPLY, 2, 2);
            } else {
                token(C, TOKEN_MULTIPLY);
            }
            return;
        case '/':
            if (peek_char(C) == '=') {
                next_char(C);
                token_special(C, TOKEN_ASSIGN_DIVIDE, 2, 2);
            } else {
                token(C, TOKEN_DIVIDE);
            }
            return;
        case '%':
            if (peek_char(C) == '=') {
                next_char(C);
                token_special(C, TOKEN_ASSIGN_MODULO, 2, 2);
            } else {
                token(C, TOKEN_MODULO);
            }
            return;
        case '&':
            if (peek_char(C) == '=') {
                next_char(C);
                token_special(C, TOKEN_ASSIGN_BIT_AND, 2, 2);
            } else {
                token(C, TOKEN_BIT_AND);
            }
            return;
        case '|':
            if (peek_char(C) == '=') {
                next_char(C);
                token_special(C, TOKEN_ASSIGN_BIT_OR, 2, 2);
            } else {
                token(C, TOKEN_BIT_OR);
            }
            return;
        case '^':
            if (peek_char(C) == '=') {
                next_char(C);
                token_special(C, TOKEN_ASSIGN_BIT_XOR, 2, 2);
            } else {
                token(C, TOKEN_BIT_XOR);
            }
            return;
        case '&gt;':
            if (peek_char(C) == '=') {
                next_char(C);
                token_special(C, TOKEN_GREATER_EQUAL, 2, 2);
            } else if (peek_char(C) == '&gt;') {
                next_char(C);
                if (peek_char(C) == '=') {
                    next_char(C);
                    token_special(C, TOKEN_ASSIGN_BIT_RIGHT_SHIFT, 2, 2);
                } else {
                    token_special(C, TOKEN_BIT_RIGHT_SHIFT, 2, 2);
                }
            } else {
                token(C, TOKEN_GREATER);
            }
            return;
        case '&lt;':
            if (peek_char(C) == '=') {
                next_char(C);
                token_special(C, TOKEN_LESS_EQUAL, 2, 2);
            } else if (peek_char(C) == '&lt;') {
                next_char(C);
                if (peek_char(C) == '=') {
                    next_char(C);
                    token_special(C, TOKEN_ASSIGN_BIT_LEFT_SHIFT, 2, 2);
                } else {
                    token_special(C, TOKEN_BIT_LEFT_SHIFT, 2, 2);
                }
            } else {
                token(C, TOKEN_LESS);
            }
            return;
        case '~': token(C, TOKEN_BIT_NOT); return;
        case ',': token(C, TOKEN_COMMA); return;
        case '.': token(C, TOKEN_DOT); return;
        case '(': token(C, TOKEN_LEFT_PAREN); return;
        case ')': token(C, TOKEN_RIGHT_PAREN); return;
        case '[': token(C, TOKEN_LEFT_SQUARE); return;
        case ']': token(C, TOKEN_RIGHT_SQUARE); return;
        case '{':
            if (C-&gt;string_format &gt;= 1) {
                C-&gt;string_format++;
            }
            token(C, TOKEN_LEFT_CURLY);
            return;
        case '}':
            if (C-&gt;string_format == 1) {
                C-&gt;string_format = 0;
                C-&gt;string_status = STRING_STATUS_CLOSE;
                token(C, TOKEN_RIGHT_PAREN);
                return;
            } else if (C-&gt;string_format &gt; 1) {
                C-&gt;string_format--;
            }
            token(C, TOKEN_RIGHT_CURLY);
            return;
        case ':': token(C, TOKEN_COLON); return;
        case '\0': token(C, TOKEN_EOF); return;
        case '&quot;': {
            size_t start = C-&gt;pos;
            parse_string(C, start);
            return;
        }
        case '\'': {
            size_t start = C-&gt;pos;
            while (true) {
                c = next_char(C);
                if (c == '\\') {
                    next_char(C);
                    continue;
                } else if (c == '\'' || c == '\0') {
                    break;
                }
            }
            size_t end = C-&gt;pos - 1;
            value_token(C, TOKEN_STRING, start, end);
            return;
        }
        default: {
            if (is_digit(c)) {
                size_t start = C-&gt;pos - 1;
                if (c == '0') {
                    const char p = peek_char(C);
                    if (p == 'b') {
                        next_char(C);
                        while (true) {
                            c = peek_char(C);
                            if (c != '0' && c != '1') {
                                break;
                            }
                            next_char(C);
                        }
                        size_t end = C-&gt;pos;
                        long long number = (long long)strtoll(&C-&gt;source[start + 2], NULL, 2);
                        int_token(C, TOKEN_INTEGER, start, end, number);
                        return;
                    } else if (p == 'x') {
                        next_char(C);
                        while (true) {
                            c = peek_char(C);
                            if (!(c &gt;= '0' && c &lt;= '9') && !(c &gt;= 'a' && c &lt;= 'f')) {
                                break;
                            }
                            next_char(C);
                        }
                        size_t end = C-&gt;pos;
                        long long number = (long long)strtoll(&C-&gt;source[start + 2], NULL, 16);
                        int_token(C, TOKEN_INTEGER, start, end, number);
                        return;
                    }
                }
                while (is_digit(peek_char(C))) {
                    next_char(C);
                }
                const char p = peek_char(C);
                if (p == '.') {
                    next_char(C);
                    while (is_digit(peek_char(C))) {
                        next_char(C);
                    }
                    const char n = peek_char(C);
                    if (n == 'e' || n == 'E') {
                        next_char(C);
                        const char e = peek_char(C);
                        if (e == '-' || e == '+') next_char(C);
                        while (is_digit(peek_char(C))) {
                            next_char(C);
                        }
                    }
                    size_t end = C-&gt;pos;
                    double number = atof(&C-&gt;source[start]);
                    float_token(C, TOKEN_FLOAT, start, end, number);
                    return;
                } else if (p == 'e' || p == 'E') {
                    next_char(C);
                    const char n = peek_char(C);
                    if (n == '-' || n == '+') next_char(C);
                    while (is_digit(peek_char(C))) {
                        next_char(C);
                    }
                    size_t end = C-&gt;pos;
                    double number = atof(&C-&gt;source[start]);
                    if (trunc(number) == number) {
                        int_token(C, TOKEN_INTEGER, start, end, (long long)number);
                    } else {
                        float_token(C, TOKEN_FLOAT, start, end, number);
                    }
                    return;
                }
                size_t end = C-&gt;pos;
                long long number = atoll(&C-&gt;source[start]);
                int_token(C, TOKEN_INTEGER, start, end, number);
                return;
            } else if (is_ident(c)) {
                size_t start = C-&gt;pos - 1;
                while (true) {
                    c = peek_char(C);
                    if (is_ident(c)) {
                        next_char(C);
                        continue;
                    } else if (c == '-') {
                        if (is_ident(peek_two_char(C))) {
                            next_char(C);
                            next_char(C);
                            continue;
                        }
                    }
                    break;
                }
                size_t end = C-&gt;pos;
                push_ident_token(C, start, end);
                return;
            } else {
                token(C, TOKEN_ERROR);
                compile_error(C, &C-&gt;current, &quot;unknown character: %c&quot;, c);
            }
        }
        }
    }
}

bool hymn_value_false(HymnValue value) {
    switch (value.is) {
    case HYMN_VALUE_NONE: return true;
    case HYMN_VALUE_BOOL: return !hymn_as_bool(value);
    case HYMN_VALUE_INTEGER: return hymn_as_int(value) == 0;
    case HYMN_VALUE_FLOAT: return hymn_as_float(value) == 0.0;
    case HYMN_VALUE_STRING: return hymn_string_len(hymn_as_string(value)) == 0;
    case HYMN_VALUE_ARRAY: return hymn_as_array(value)-&gt;length == 0;
    case HYMN_VALUE_TABLE: return hymn_as_table(value)-&gt;size == 0;
    case HYMN_VALUE_FUNC: return hymn_as_func(value) == NULL;
    case HYMN_VALUE_FUNC_NATIVE: return hymn_as_native(value) == NULL;
    default: return false;
    }
}

bool hymn_values_equal(HymnValue a, HymnValue b) {
    switch (a.is) {
    case HYMN_VALUE_NONE: return hymn_is_none(b);
    case HYMN_VALUE_BOOL: return hymn_is_bool(b) && hymn_as_bool(a) == hymn_as_bool(b);
    case HYMN_VALUE_INTEGER:
        switch (b.is) {
        case HYMN_VALUE_INTEGER: return hymn_as_int(a) == hymn_as_int(b);
        case HYMN_VALUE_FLOAT: return (HymnFloat)hymn_as_int(a) == hymn_as_float(b);
        default: return false;
        }
    case HYMN_VALUE_FLOAT:
        switch (b.is) {
        case HYMN_VALUE_INTEGER: return hymn_as_float(a) == (HymnFloat)hymn_as_int(b);
        case HYMN_VALUE_FLOAT: return hymn_as_float(a) == hymn_as_float(b);
        default: return false;
        }
    case HYMN_VALUE_STRING:
    case HYMN_VALUE_ARRAY:
    case HYMN_VALUE_TABLE:
    case HYMN_VALUE_FUNC:
    case HYMN_VALUE_FUNC_NATIVE:
        return b.is == a.is && hymn_as_object(a) == hymn_as_object(b);
    case HYMN_VALUE_POINTER:
        return hymn_is_pointer(b) && hymn_as_pointer(a) == hymn_as_pointer(b);
    default: return false;
    }
}

bool hymn_match_values(HymnValue a, HymnValue b) {
    if (a.is != b.is) {
        return false;
    }
    switch (a.is) {
    case HYMN_VALUE_UNDEFINED:
    case HYMN_VALUE_NONE: return true;
    case HYMN_VALUE_BOOL: return hymn_as_bool(a) == hymn_as_bool(b);
    case HYMN_VALUE_INTEGER: return hymn_as_int(a) == hymn_as_int(b);
    case HYMN_VALUE_FLOAT: return hymn_as_float(a) == hymn_as_float(b);
    case HYMN_VALUE_STRING:
    case HYMN_VALUE_ARRAY:
    case HYMN_VALUE_TABLE:
    case HYMN_VALUE_FUNC:
    case HYMN_VALUE_FUNC_NATIVE:
        return hymn_as_object(a) == hymn_as_object(b);
    case HYMN_VALUE_POINTER: return hymn_as_pointer(a) == hymn_as_pointer(b);
    default:
        return false;
    }
}

static void value_pool_init(HymnValuePool *this) {
    this-&gt;count = 0;
    this-&gt;capacity = 8;
    this-&gt;values = hymn_malloc(8 * sizeof(HymnValue));
}

static int value_pool_add(HymnValuePool *this, HymnValue value) {
    int count = this-&gt;count;
    for (int c = 0; c &lt; count; c++) {
        if (hymn_match_values(this-&gt;values[c], value)) {
            return c;
        }
    }
    if (count &gt;= this-&gt;capacity) {
        this-&gt;capacity *= 2;
        this-&gt;values = hymn_realloc_int(this-&gt;values, this-&gt;capacity, sizeof(HymnValue));
    }
    this-&gt;values[count] = value;
    this-&gt;count = count + 1;
    return count;
}

static void byte_code_init(HymnByteCode *this) {
    this-&gt;count = 0;
    this-&gt;capacity = 8;
    this-&gt;instructions = hymn_malloc(8 * sizeof(uint8_t));
    this-&gt;lines = hymn_malloc(8 * sizeof(int));
    value_pool_init(&this-&gt;constants);
}

static HymnFunction *new_function(const char *script) {
    HymnFunction *func = hymn_calloc(1, sizeof(HymnFunction));
    byte_code_init(&func-&gt;code);
    if (script != NULL) {
        func-&gt;script = hymn_new_string(script);
    }
    return func;
}

static HymnNativeFunction *new_native_function(HymnObjectString *name, HymnNativeCall func) {
    HymnNativeFunction *native = hymn_calloc(1, sizeof(HymnNativeFunction));
    native-&gt;name = name;
    native-&gt;func = func;
    hymn_reference_string(name);
    return native;
}

static void array_init_with_capacity(HymnArray *this, HymnInt length, HymnInt capacity) {
    if (capacity == 0) {
        this-&gt;items = NULL;
    } else {
        this-&gt;items = hymn_calloc((size_t)capacity, sizeof(HymnValue));
    }
    this-&gt;length = length;
    this-&gt;capacity = capacity;
}

static HymnArray *new_array_with_capacity(HymnInt length, HymnInt capacity) {
    HymnArray *this = hymn_calloc(1, sizeof(HymnArray));
    array_init_with_capacity(this, length, capacity);
    return this;
}

HymnArray *hymn_new_array(HymnInt length) {
    return new_array_with_capacity(length, length);
}

static HymnArray *new_array_slice(HymnArray *from, HymnInt start, HymnInt end) {
    HymnInt length = end - start;
    size_t size = (size_t)length * sizeof(HymnValue);
    HymnArray *this = hymn_calloc(1, sizeof(HymnArray));
    this-&gt;items = hymn_malloc(size);
    memcpy(this-&gt;items, &from-&gt;items[start], size);
    this-&gt;length = length;
    this-&gt;capacity = length;
    for (HymnInt i = 0; i &lt; length; i++) {
        hymn_reference(this-&gt;items[i]);
    }
    return this;
}

static HymnArray *new_array_copy(HymnArray *from) {
    return new_array_slice(from, 0, from-&gt;length);
}

static void array_update_capacity(HymnArray *this, HymnInt length) {
    if (length &gt; this-&gt;capacity) {
        if (this-&gt;capacity == 0) {
            this-&gt;capacity = length;
            this-&gt;items = hymn_calloc((size_t)length, sizeof(HymnValue));
        } else {
            this-&gt;capacity = length * 2;
            this-&gt;items = hymn_realloc(this-&gt;items, (size_t)this-&gt;capacity * sizeof(HymnValue));
            memset(this-&gt;items + (size_t)this-&gt;length, 0, (size_t)(this-&gt;capacity - this-&gt;length));
        }
    }
}

void hymn_array_push(HymnArray *this, HymnValue value) {
    HymnInt length = this-&gt;length + 1;
    array_update_capacity(this, length);
    this-&gt;length = length;
    this-&gt;items[length - 1] = value;
}

void hymn_array_insert(HymnArray *this, HymnInt index, HymnValue value) {
    HymnInt length = this-&gt;length + 1;
    array_update_capacity(this, length);
    this-&gt;length = length;
    HymnValue *items = this-&gt;items;
    for (HymnInt i = length - 1; i &gt; index; i--) {
        items[i] = items[i - 1];
    }
    items[index] = value;
}

HymnValue hymn_array_get(HymnArray *this, HymnInt index) {
    if (index &gt;= this-&gt;length) {
        return hymn_new_undefined();
    }
    return this-&gt;items[index];
}

HymnInt hymn_array_index_of(HymnArray *this, HymnValue match) {
    HymnInt len = this-&gt;length;
    HymnValue *items = this-&gt;items;
    for (HymnInt i = 0; i &lt; len; i++) {
        if (hymn_match_values(match, items[i])) {
            return i;
        }
    }
    return -1;
}

HymnValue hymn_array_pop(HymnArray *this) {
    if (this-&gt;length == 0) {
        return hymn_new_none();
    }
    return this-&gt;items[--this-&gt;length];
}

HymnValue hymn_array_remove_index(HymnArray *this, HymnInt index) {
    HymnInt len = --this-&gt;length;
    HymnValue *items = this-&gt;items;
    HymnValue deleted = items[index];
    while (index &lt; len) {
        items[index] = items[index + 1];
        index++;
    }
    return deleted;
}

void hymn_array_clear(Hymn *H, HymnArray *this) {
    HymnInt len = this-&gt;length;
    HymnValue *items = this-&gt;items;
    for (HymnInt i = 0; i &lt; len; i++) {
        hymn_dereference(H, items[i]);
    }
    this-&gt;length = 0;
}

void hymn_array_delete(Hymn *H, HymnArray *this) {
    hymn_array_clear(H, this);
    free(this-&gt;items);
    free(this);
}

HymnTable *hymn_new_table(void) {
    HymnTable *this = hymn_calloc(1, sizeof(HymnTable));
    table_init(this);
    return this;
}

static HymnTable *new_table_copy(HymnTable *from) {
    HymnTable *this = hymn_new_table();
    unsigned int bins = from-&gt;bins;
    for (unsigned int i = 0; i &lt; bins; i++) {
        HymnTableItem *item = from-&gt;items[i];
        while (item != NULL) {
            table_put(this, item-&gt;key, item-&gt;value);
            hymn_reference_string(item-&gt;key);
            hymn_reference(item-&gt;value);
            item = item-&gt;next;
        }
    }
    return this;
}

static HymnArray *table_keys(HymnTable *this) {
    int size = this-&gt;size;
    HymnArray *array = hymn_new_array((HymnInt)size);
    if (size == 0) {
        return array;
    }
    HymnValue *keys = array-&gt;items;
    unsigned int total = 0;
    unsigned int bins = this-&gt;bins;
    for (unsigned int i = 0; i &lt; bins; i++) {
        HymnTableItem *item = this-&gt;items[i];
        while (item != NULL) {
            HymnString *string = item-&gt;key-&gt;string;
            unsigned int insert = 0;
            while (insert != total) {
                if (strcmp(string, hymn_as_string(keys[insert])) &lt; 0) {
                    for (unsigned int swap = total; swap &gt; insert; swap--) {
                        keys[swap] = keys[swap - 1];
                    }
                    break;
                }
                insert++;
            }
            HymnValue value = hymn_new_string_value(item-&gt;key);
            hymn_reference(value);
            keys[insert] = value;
            total++;
            item = item-&gt;next;
        }
    }
    return array;
}

static HymnObjectString *table_key_of(HymnTable *this, HymnValue match) {
    unsigned int bin = 0;
    HymnTableItem *item = NULL;

    unsigned int bins = this-&gt;bins;
    for (unsigned int i = 0; i &lt; bins; i++) {
        HymnTableItem *start = this-&gt;items[i];
        if (start) {
            bin = i;
            item = start;
            break;
        }
    }

    if (item == NULL) return NULL;
    if (hymn_match_values(match, item-&gt;value)) return item-&gt;key;

    while (true) {
        item = item-&gt;next;
        if (item == NULL) {
            for (bin = bin + 1; bin &lt; bins; bin++) {
                HymnTableItem *start = this-&gt;items[bin];
                if (start) {
                    item = start;
                    break;
                }
            }
            if (item == NULL) return NULL;
        }
        if (hymn_match_values(match, item-&gt;value)) return item-&gt;key;
    }
}

static void scope_init(Compiler *C, Scope *scope, enum FunctionType type, size_t begin) {
    scope-&gt;enclosing = C-&gt;scope;
    C-&gt;scope = scope;

    scope-&gt;local_count = 0;
    scope-&gt;depth = 0;
    scope-&gt;func = new_function(C-&gt;script);
    scope-&gt;type = type;
    scope-&gt;begin = begin;

    if (type == TYPE_FUNCTION) {
        scope-&gt;func-&gt;name = hymn_substring(C-&gt;source, C-&gt;previous.start, C-&gt;previous.start + C-&gt;previous.length);
    }

    Local *local = &scope-&gt;locals[scope-&gt;local_count++];
    local-&gt;depth = 0;
    local-&gt;name.start = 0;
    local-&gt;name.length = 0;
}

static void byte_code_delete(HymnByteCode *this) {
    free(this-&gt;instructions);
    free(this-&gt;lines);
    free(this-&gt;constants.values);
}

static uint8_t byte_code_new_constant(Compiler *C, HymnValue value) {
    HymnByteCode *code = current(C);
    int constant = value_pool_add(&code-&gt;constants, value);
    if (constant &gt; UINT8_MAX) {
        compile_error(C, &C-&gt;previous, &quot;too many constants&quot;);
        constant = 0;
    }
    return (uint8_t)constant;
}

static void write_byte(HymnByteCode *code, uint8_t b, int row) {
    int count = code-&gt;count;
    if (count &gt;= code-&gt;capacity) {
        code-&gt;capacity *= 2;
        code-&gt;instructions = hymn_realloc_int(code-&gt;instructions, code-&gt;capacity, sizeof(uint8_t));
        code-&gt;lines = hymn_realloc_int(code-&gt;lines, code-&gt;capacity, sizeof(int));
    }
    code-&gt;instructions[count] = b;
    code-&gt;lines[count] = row;
    code-&gt;count = count + 1;
}

static void emit(Compiler *C, uint8_t i) {
    write_byte(current(C), i, C-&gt;previous.row);
}

static void emit_pop(Compiler *C) {
    HymnByteCode *code = current(C);
    write_byte(code, OP_POP, C-&gt;previous.row);
    C-&gt;pop = code-&gt;count;
}

static void emit_short(Compiler *C, uint8_t i, uint8_t b) {
    int row = C-&gt;previous.row;
    HymnByteCode *code = current(C);
    write_byte(code, i, row);
    write_byte(code, b, row);
}

static void emit_word(Compiler *C, uint8_t i, uint8_t b, uint8_t n) {
    int row = C-&gt;previous.row;
    HymnByteCode *code = current(C);
    write_byte(code, i, row);
    write_byte(code, b, row);
    write_byte(code, n, row);
}

static uint8_t emit_constant(Compiler *C, HymnValue value) {
    uint8_t constant = byte_code_new_constant(C, value);
    emit_short(C, OP_CONSTANT, constant);
    return constant;
}

static Rule *token_rule(enum TokenType type) {
    return &rules[type];
}

HymnObjectString *hymn_intern_string(Hymn *H, HymnString *string) {
    HymnObjectString *object = set_add_or_get(&H-&gt;strings, string);
    if (object-&gt;string != string) {
        hymn_string_delete(string);
    }
    return object;
}

HymnObjectString *hymn_new_intern_string(Hymn *H, const char *value) {
    return hymn_intern_string(H, hymn_new_string(value));
}

static HymnValue compile_intern_string(Hymn *H, HymnString *string) {
    HymnObjectString *object = set_add_or_get(&H-&gt;strings, string);
    if (object-&gt;string == string) {
        hymn_reference_string(object);
    } else {
        hymn_string_delete(string);
    }
    return hymn_new_string_value(object);
}

static bool check_assign(Compiler *C) {
    switch (C-&gt;current.type) {
    case TOKEN_ASSIGN:
    case TOKEN_ASSIGN_ADD:
    case TOKEN_ASSIGN_BIT_AND:
    case TOKEN_ASSIGN_BIT_LEFT_SHIFT:
    case TOKEN_ASSIGN_BIT_OR:
    case TOKEN_ASSIGN_BIT_RIGHT_SHIFT:
    case TOKEN_ASSIGN_BIT_XOR:
    case TOKEN_ASSIGN_DIVIDE:
    case TOKEN_ASSIGN_MODULO:
    case TOKEN_ASSIGN_MULTIPLY:
    case TOKEN_ASSIGN_SUBTRACT:
        return true;
    default:
        return false;
    }
}

static bool check(Compiler *C, enum TokenType type) {
    return C-&gt;current.type == type;
}

static bool match(Compiler *C, enum TokenType type) {
    if (C-&gt;current.type != type) {
        return false;
    }
    advance(C);
    return true;
}

static void compile_with_precedence(Compiler *C, enum Precedence precedence) {
    advance(C);
    Rule *rule = token_rule(C-&gt;previous.type);
    void (*prefix)(Compiler *, bool) = rule-&gt;prefix;
    if (prefix == NULL) {
        compile_error(C, &C-&gt;previous, &quot;expression expected near '%.*s'&quot;, C-&gt;previous.length, &C-&gt;source[C-&gt;previous.start]);
        return;
    }
    bool assign = precedence &lt;= PRECEDENCE_ASSIGN;
    prefix(C, assign);
    while (precedence &lt;= token_rule(C-&gt;current.type)-&gt;precedence) {
        advance(C);
        void (*infix)(Compiler *, bool) = token_rule(C-&gt;previous.type)-&gt;infix;
        if (infix == NULL) {
            compile_error(C, &C-&gt;previous, &quot;expected infix&quot;);
            return;
        }
        infix(C, assign);
    }
    if (assign && check_assign(C)) {
        advance(C);
        compile_error(C, &C-&gt;current, &quot;invalid assignment&quot;);
    }
}

static void consume(Compiler *C, enum TokenType type, const char *error) {
    if (C-&gt;current.type == type) {
        advance(C);
        return;
    }
    compile_error(C, &C-&gt;current, error);
}

static uint8_t push_hidden_local(Compiler *C) {
    Scope *scope = C-&gt;scope;
    if (scope-&gt;local_count == HYMN_UINT8_COUNT) {
        compile_error(C, &C-&gt;previous, &quot;too many local variables in scope&quot;);
        return 0;
    }
    uint8_t index = (uint8_t)scope-&gt;local_count++;
    Local *local = &scope-&gt;locals[index];
    local-&gt;name = (Token){0};
    local-&gt;depth = scope-&gt;depth;
    return index;
}

static uint8_t arguments(Compiler *C) {
    uint8_t count = 0;
    if (!check(C, TOKEN_RIGHT_PAREN)) {
        do {
            expression(C);
            if (count == UINT8_MAX) {
                compile_error(C, &C-&gt;previous, &quot;too many function arguments&quot;);
                break;
            }
            count++;
        } while (match(C, TOKEN_COMMA));
    }
    consume(C, TOKEN_RIGHT_PAREN, &quot;function has no closing ')'&quot;);
    return count;
}

static void compile_call(Compiler *C, bool assign) {
    (void)assign;
    uint8_t count = arguments(C);
    emit_short(C, OP_CALL, count);
}

static void compile_group(Compiler *C, bool assign) {
    (void)assign;
    expression(C);
    consume(C, TOKEN_RIGHT_PAREN, &quot;parenthesis group has no closing ')'&quot;);
}

static void compile_none(Compiler *C, bool assign) {
    (void)assign;
    emit(C, OP_NONE);
}

static void compile_true(Compiler *C, bool assign) {
    (void)assign;
    emit(C, OP_TRUE);
}

static void compile_false(Compiler *C, bool assign) {
    (void)assign;
    emit(C, OP_FALSE);
}

static void compile_integer(Compiler *C, bool assign) {
    (void)assign;
    emit_constant(C, hymn_new_int(C-&gt;current.integer));
}

static void compile_float(Compiler *C, bool assign) {
    (void)assign;
    emit_constant(C, hymn_new_float(C-&gt;current.floating));
}

static char escape_sequence(const char c) {
    switch (c) {
    case 'b':
        return '\b';
    case 'f':
        return '\f';
    case 'n':
        return '\n';
    case 'r':
        return '\r';
    case 't':
        return '\t';
    case 'v':
        return '\v';
    default:
        return c;
    }
}

static HymnString *parse_string_literal(const char *string, size_t start, size_t len) {
    const size_t end = start + len;
    HymnString *literal = hymn_new_string_with_capacity(len);
    for (size_t i = start; i &lt; end; i++) {
        const char c = string[i];
        if (c == '\\' && i + 1 &lt; end) {
            const char e = escape_sequence(string[i + 1]);
            literal = hymn_string_append_char(literal, e);
            i++;
        } else {
            literal = hymn_string_append_char(literal, c);
        }
    }
    return literal;
}

static HymnValue string_literal(Compiler *C) {
    Token *previous = &C-&gt;previous;
    HymnString *string = parse_string_literal(C-&gt;source, previous-&gt;start, previous-&gt;length);
    while (check(C, TOKEN_STRING)) {
        Token *current = &C-&gt;current;
        HymnString *and = parse_string_literal(C-&gt;source, current-&gt;start, current-&gt;length);
        string = hymn_string_append(string, and);
        hymn_string_delete(and);
        advance(C);
    }
    return compile_intern_string(C-&gt;H, string);
}

static void compile_string(Compiler *C, bool assign) {
    (void)assign;
    emit_constant(C, string_literal(C));
}

static uint8_t ident_constant_string(Compiler *C) {
    return byte_code_new_constant(C, string_literal(C));
}

static uint8_t ident_constant(Compiler *C, Token *token) {
    HymnString *string = hymn_substring(C-&gt;source, token-&gt;start, token-&gt;start + token-&gt;length);
    return byte_code_new_constant(C, compile_intern_string(C-&gt;H, string));
}

static void begin_scope(Compiler *C) {
    C-&gt;scope-&gt;depth++;
}

static void end_scope(Compiler *C) {
    Scope *scope = C-&gt;scope;
    scope-&gt;depth--;
    while (scope-&gt;local_count &gt; 0 && scope-&gt;locals[scope-&gt;local_count - 1].depth &gt; scope-&gt;depth) {
        emit_pop(C);
        scope-&gt;local_count--;
    }
    C-&gt;barrier = scope-&gt;func-&gt;code.count;
}

static void compile_array(Compiler *C, bool assign) {
    (void)assign;
    emit(C, OP_NEW_ARRAY);
    if (match(C, TOKEN_RIGHT_SQUARE)) {
        return;
    }
    while (!check(C, TOKEN_RIGHT_SQUARE) && !check(C, TOKEN_EOF)) {
        emit(C, OP_DUPLICATE);
        expression(C);
        emit(C, OP_ARRAY_PUSH);
        if (!check(C, TOKEN_RIGHT_SQUARE)) {
            consume(C, TOKEN_COMMA, &quot;expected ',' between array elements&quot;);
        }
    }
    consume(C, TOKEN_RIGHT_SQUARE, &quot;expected ']' at end of array declaration&quot;);
}

static void compile_table(Compiler *C, bool assign) {
    (void)assign;
    emit(C, OP_NEW_TABLE);
    if (match(C, TOKEN_RIGHT_CURLY)) {
        return;
    }
    while (!check(C, TOKEN_RIGHT_CURLY) && !check(C, TOKEN_EOF)) {
        emit(C, OP_DUPLICATE);
        uint8_t name;
        if (match(C, TOKEN_IDENT)) {
            name = ident_constant(C, &C-&gt;previous);
        } else if (match(C, TOKEN_STRING)) {
            name = ident_constant_string(C);
        } else {
            name = UINT8_MAX;
            compile_error(C, &C-&gt;current, &quot;expected table key&quot;);
        }
        consume(C, TOKEN_COLON, &quot;expected ':' between table key and value&quot;);
        expression(C);
        emit_short(C, OP_SET_PROPERTY, name);
        emit_pop(C);
        if (!check(C, TOKEN_RIGHT_CURLY)) {
            consume(C, TOKEN_COMMA, &quot;expected ',' between table elements&quot;);
        }
    }
    consume(C, TOKEN_RIGHT_CURLY, &quot;expected '}' at end of table declaration&quot;);
}

static void function_delete(HymnFunction *this) {
    byte_code_delete(&this-&gt;code);
    hymn_string_delete(this-&gt;name);
    hymn_string_delete(this-&gt;script);
    hymn_string_delete(this-&gt;source);
    HymnExceptList *except = this-&gt;except;
    while (except != NULL) {
        HymnExceptList *next = except-&gt;next;
        free(except);
        except = next;
    }
    free(this);
}

static void native_function_delete(Hymn *H, HymnNativeFunction *this) {
    hymn_dereference_string(H, this-&gt;name);
    free(this);
}

static void push_local(Compiler *C, Token name) {
    Scope *scope = C-&gt;scope;
    if (scope-&gt;local_count == HYMN_UINT8_COUNT) {
        compile_error(C, &name, &quot;too many local variables in scope&quot;);
        return;
    }
    Local *local = &scope-&gt;locals[scope-&gt;local_count++];
    local-&gt;name = name;
    local-&gt;depth = -1;
}

static bool ident_match(Compiler *C, Token *a, Token *b) {
    if (a-&gt;length != b-&gt;length) {
        return false;
    }
    return memcmp(&C-&gt;source[a-&gt;start], &C-&gt;source[b-&gt;start], a-&gt;length) == 0;
}

static uint8_t variable(Compiler *C, const char *error) {
    consume(C, TOKEN_IDENT, error);
    Scope *scope = C-&gt;scope;
    if (scope-&gt;depth == 0) {
        return ident_constant(C, &C-&gt;previous);
    }
    Token *name = &C-&gt;previous;
    for (int i = scope-&gt;local_count - 1; i &gt;= 0; i--) {
        Local *local = &scope-&gt;locals[i];
        if (local-&gt;depth != -1 && local-&gt;depth &lt; scope-&gt;depth) {
            break;
        } else if (ident_match(C, name, &local-&gt;name)) {
            compile_error(C, name, &quot;variable '%.*s' already exists in scope&quot;, name-&gt;length, &C-&gt;source[name-&gt;start]);
        }
    }
    push_local(C, *name);
    return 0;
}

static void local_initialize(Compiler *C) {
    Scope *scope = C-&gt;scope;
    if (scope-&gt;depth == 0) {
        return;
    }
    scope-&gt;locals[scope-&gt;local_count - 1].depth = scope-&gt;depth;
}

static void finalize_variable(Compiler *C, uint8_t global) {
    if (C-&gt;scope-&gt;depth &gt; 0) {
        local_initialize(C);
        return;
    }
    emit_short(C, OP_DEFINE_GLOBAL, global);
}

static void type_declaration(Compiler *C) {
    if (match(C, TOKEN_COLON)) {
        enum TokenType type = C-&gt;current.type;
        switch (type) {
        case TOKEN_NONE:
        case TOKEN_TO_FLOAT:
        case TOKEN_TO_STRING:
        case TOKEN_TO_INTEGER:
            advance(C);
            return;
        default:
            compile_error(C, &C-&gt;previous, &quot;unavailable type declaration&quot;);
            return;
        }
    }
}

static void define_new_variable(Compiler *C) {
    uint8_t global = variable(C, &quot;expected a variable name&quot;);
    type_declaration(C);
    consume(C, TOKEN_ASSIGN, &quot;expected '=' after variable&quot;);
    expression(C);
    finalize_variable(C, global);
}

static int resolve_local(Compiler *C, Token *name) {
    Scope *scope = C-&gt;scope;
    for (int i = scope-&gt;local_count - 1; i &gt;= 0; i--) {
        Local *local = &scope-&gt;locals[i];
        if (ident_match(C, name, &local-&gt;name)) {
            if (local-&gt;depth == -1) {
                compile_error(C, name, &quot;local variable '%.*s' referenced before assignment&quot;, name-&gt;length, &C-&gt;source[name-&gt;start]);
            }
            return i;
        }
    }
    return -1;
}

static void named_variable(Compiler *C, Token token, bool assign) {
    uint8_t get;
    uint8_t set;
    int var = resolve_local(C, &token);
    if (var != -1) {
        get = OP_GET_LOCAL;
        set = OP_SET_LOCAL;
    } else {
        get = OP_GET_GLOBAL;
        set = OP_SET_GLOBAL;
        var = ident_constant(C, &token);
    }
    if (assign && check_assign(C)) {
        enum TokenType type = C-&gt;current.type;
        advance(C);
        if (type != TOKEN_ASSIGN) {
            emit_short(C, get, (uint8_t)var);
        }
        expression(C);
        switch (type) {
        case TOKEN_ASSIGN_ADD: emit(C, OP_ADD); break;
        case TOKEN_ASSIGN_BIT_AND: emit(C, OP_BIT_AND); break;
        case TOKEN_ASSIGN_BIT_LEFT_SHIFT: emit(C, OP_BIT_LEFT_SHIFT); break;
        case TOKEN_ASSIGN_BIT_OR: emit(C, OP_BIT_OR); break;
        case TOKEN_ASSIGN_BIT_RIGHT_SHIFT: emit(C, OP_BIT_RIGHT_SHIFT); break;
        case TOKEN_ASSIGN_BIT_XOR: emit(C, OP_BIT_XOR); break;
        case TOKEN_ASSIGN_DIVIDE: emit(C, OP_DIVIDE); break;
        case TOKEN_ASSIGN_MODULO: emit(C, OP_MODULO); break;
        case TOKEN_ASSIGN_MULTIPLY: emit(C, OP_MULTIPLY); break;
        case TOKEN_ASSIGN_SUBTRACT: emit(C, OP_SUBTRACT); break;
        default: break;
        }
        emit_short(C, set, (uint8_t)var);
    } else {
        emit_short(C, get, (uint8_t)var);
    }
}

static void compile_variable(Compiler *C, bool assign) {
    named_variable(C, C-&gt;previous, assign);
}

static void compile_unary(Compiler *C, bool assign) {
    (void)assign;
    enum TokenType type = C-&gt;previous.type;
    compile_with_precedence(C, PRECEDENCE_UNARY);
    switch (type) {
    case TOKEN_NOT: emit(C, OP_NOT); break;
    case TOKEN_SUBTRACT: emit(C, OP_NEGATE); break;
    case TOKEN_BIT_NOT: emit(C, OP_BIT_NOT); break;
    default: return;
    }
}

static void compile_binary(Compiler *C, bool assign) {
    (void)assign;
    enum TokenType type = C-&gt;previous.type;
    Rule *rule = token_rule(type);
    compile_with_precedence(C, (enum Precedence)(rule-&gt;precedence + 1));
    switch (type) {
    case TOKEN_ADD: emit(C, OP_ADD); break;
    case TOKEN_SUBTRACT: emit(C, OP_SUBTRACT); break;
    case TOKEN_MODULO: emit(C, OP_MODULO); break;
    case TOKEN_MULTIPLY: emit(C, OP_MULTIPLY); break;
    case TOKEN_DIVIDE: emit(C, OP_DIVIDE); break;
    case TOKEN_EQUAL: emit(C, OP_EQUAL); break;
    case TOKEN_NOT_EQUAL: emit(C, OP_NOT_EQUAL); break;
    case TOKEN_LESS: emit(C, OP_LESS); break;
    case TOKEN_LESS_EQUAL: emit(C, OP_LESS_EQUAL); break;
    case TOKEN_GREATER: emit(C, OP_GREATER); break;
    case TOKEN_GREATER_EQUAL: emit(C, OP_GREATER_EQUAL); break;
    case TOKEN_BIT_OR: emit(C, OP_BIT_OR); break;
    case TOKEN_BIT_AND: emit(C, OP_BIT_AND); break;
    case TOKEN_BIT_XOR: emit(C, OP_BIT_XOR); break;
    case TOKEN_BIT_LEFT_SHIFT: emit(C, OP_BIT_LEFT_SHIFT); break;
    case TOKEN_BIT_RIGHT_SHIFT: emit(C, OP_BIT_RIGHT_SHIFT); break;
    default: return;
    }
}

static void compile_dot(Compiler *C, bool assign) {
    consume(C, TOKEN_IDENT, &quot;expected table key after '.'&quot;);
    uint8_t name = ident_constant(C, &C-&gt;previous);
    if (assign && match(C, TOKEN_ASSIGN)) {
        expression(C);
        emit_short(C, OP_SET_PROPERTY, name);
    } else {
        emit_short(C, OP_GET_PROPERTY, name);
    }
}

static void compile_pointer(Compiler *C, bool assign) {
    (void)assign;
    consume(C, TOKEN_IDENT, &quot;expected table key after '-&gt;'&quot;);
    uint8_t name = ident_constant(C, &C-&gt;previous);
    consume(C, TOKEN_LEFT_PAREN, &quot;expected '(' after function name&quot;);
    emit_short(C, OP_SELF, name);
    uint8_t count = arguments(C);
    if (count == UINT8_MAX) {
        compile_error(C, &C-&gt;previous, &quot;too many function arguments&quot;);
        return;
    }
    emit_short(C, OP_CALL, (uint8_t)(count + 1));
}

static void compile_square(Compiler *C, bool assign) {
    if (match(C, TOKEN_COLON)) {
        emit_constant(C, hymn_new_int(0));
        if (match(C, TOKEN_RIGHT_SQUARE)) {
            emit_constant(C, hymn_new_none());
        } else {
            expression(C);
            consume(C, TOKEN_RIGHT_SQUARE, &quot;expected ']' after square bracket expression&quot;);
        }
        emit(C, OP_SLICE);
    } else {
        expression(C);
        if (match(C, TOKEN_COLON)) {
            if (match(C, TOKEN_RIGHT_SQUARE)) {
                emit_constant(C, hymn_new_none());
            } else {
                expression(C);
                consume(C, TOKEN_RIGHT_SQUARE, &quot;expected ']' after square bracket expression&quot;);
            }
            emit(C, OP_SLICE);
        } else {
            consume(C, TOKEN_RIGHT_SQUARE, &quot;expected ']' after square bracket expression&quot;);
            if (assign && match(C, TOKEN_ASSIGN)) {
                expression(C);
                emit(C, OP_SET_DYNAMIC);
            } else {
                emit(C, OP_GET_DYNAMIC);
            }
        }
    }
}

static int emit_jump(Compiler *C, uint8_t instruction) {
    emit(C, instruction);
    emit_short(C, UINT8_MAX, UINT8_MAX);
    return current(C)-&gt;count - 2;
}

static void patch_jump(Compiler *C, int jump) {
    if (jump == -1) {
        return;
    }
    HymnByteCode *code = current(C);
    int count = code-&gt;count;
    int offset = count - jump - 2;
    if (offset &gt; UINT16_MAX) {
        compile_error(C, &C-&gt;previous, &quot;jump offset too large&quot;);
        return;
    }
    code-&gt;instructions[jump] = (uint8_t)((offset &gt;&gt; 8) & UINT8_MAX);
    code-&gt;instructions[jump + 1] = (uint8_t)(offset & UINT8_MAX);
}

static JumpList *add_jump(Compiler *C, JumpList *list, enum OpCode instruction) {
    JumpList *jump = hymn_calloc(1, sizeof(JumpList));
    jump-&gt;jump = emit_jump(C, (uint8_t)instruction);
    jump-&gt;depth = C-&gt;scope-&gt;depth;
    jump-&gt;code = current(C);
    jump-&gt;next = list;
    return jump;
}

static void free_jump_and_list(Compiler *C) {
    JumpList *jump = C-&gt;jump_and;
    HymnByteCode *code = current(C);
    int depth = C-&gt;scope-&gt;depth;
    while (jump != NULL) {
        if (jump-&gt;code != code || jump-&gt;depth &lt; depth) {
            break;
        }
        patch_jump(C, jump-&gt;jump);
        JumpList *next = jump-&gt;next;
        free(jump);
        jump = next;
    }
    C-&gt;jump_and = jump;
}

static void free_jump_or_list(Compiler *C) {
    JumpList *jump = C-&gt;jump_or;
    HymnByteCode *code = current(C);
    int depth = C-&gt;scope-&gt;depth;
    while (jump != NULL) {
        if (jump-&gt;code != code || jump-&gt;depth &lt; depth) {
            break;
        }
        patch_jump(C, jump-&gt;jump);
        JumpList *next = jump-&gt;next;
        free(jump);
        jump = next;
    }
    C-&gt;jump_or = jump;
}

static void free_jumps(Compiler *C, JumpList *jump) {
    while (jump != NULL) {
        patch_jump(C, jump-&gt;jump);
        JumpList *next = jump-&gt;next;
        free(jump);
        jump = next;
    }
}

static void compile_and(Compiler *C, bool assign) {
    (void)assign;
    C-&gt;jump_and = add_jump(C, C-&gt;jump_and, OP_JUMP_IF_FALSE);
    compile_with_precedence(C, PRECEDENCE_AND);
}

static void compile_or(Compiler *C, bool assign) {
    (void)assign;
    C-&gt;jump_or = add_jump(C, C-&gt;jump_or, OP_JUMP_IF_TRUE);
    free_jump_and_list(C);
    compile_with_precedence(C, PRECEDENCE_OR);
}

static int next(uint8_t instruction) {
    switch (instruction) {
    case OP_CALL:
    case OP_CONSTANT:
    case OP_DEFINE_GLOBAL:
    case OP_EXISTS:
    case OP_GET_GLOBAL:
    case OP_GET_LOCAL:
    case OP_GET_PROPERTY:
    case OP_INCREMENT:
    case OP_POP_N:
    case OP_PRINT:
    case OP_SELF:
    case OP_SET_GLOBAL:
    case OP_SET_LOCAL:
    case OP_SET_PROPERTY:
    case OP_TAIL_CALL:
        return 2;
    case OP_ADD_LOCALS:
    case OP_ARRAY_PUSH_LOCALS:
    case OP_GET_GLOBAL_PROPERTY:
    case OP_GET_LOCALS:
    case OP_INCREMENT_LOCAL:
    case OP_INCREMENT_LOCAL_AND_SET:
    case OP_JUMP:
    case OP_JUMP_IF_EQUAL:
    case OP_JUMP_IF_FALSE:
    case OP_JUMP_IF_GREATER:
    case OP_JUMP_IF_GREATER_EQUAL:
    case OP_JUMP_IF_LESS:
    case OP_JUMP_IF_LESS_EQUAL:
    case OP_JUMP_IF_NOT_EQUAL:
    case OP_JUMP_IF_TRUE:
    case OP_LOOP:
    case OP_MODULO_LOCALS:
        return 3;
    case OP_FOR:
    case OP_FOR_LOOP:
        return 4;
    case OP_INCREMENT_LOOP:
    case OP_JUMP_IF_GREATER_LOCALS:
        return 5;
    default:
        return 1;
    }
}

struct Instruction {
    Instruction *next;
    int index;
    uint8_t instruction;
    char padding[3];
};

struct Optimizer {
    HymnByteCode *code;
    Instruction *important;
    HymnExceptList *except;
};

#define GET_JUMP(instructions, index, x, y) (((int)instructions[index + x] &lt;&lt; 8) | (int)instructions[index + y])

#define UPDATE_JUMP(instructions, index, x, y, jump)              \
    instructions[index + x] = (uint8_t)((jump &gt;&gt; 8) & UINT8_MAX); \
    instructions[index + y] = (uint8_t)(jump & UINT8_MAX);

#define IS_ADJUSTABLE(off, compare, T, operator)                                         \
    if (index compare target) {                                                          \
        int offset = index + off;                                                        \
        int jump = ((int)instructions[offset - 2] &lt;&lt; 8) | (int)instructions[offset - 1]; \
        if (offset operator jump == target) {                                            \
            return view;                                                                 \
        }                                                                                \
    }                                                                                    \
    break;

static Instruction *adjustable(Optimizer *optimizer, int target) {
    Instruction *view = optimizer-&gt;important;
    uint8_t *instructions = optimizer-&gt;code-&gt;instructions;
    while (view != NULL) {
        int index = view-&gt;index;
        uint8_t instruction = view-&gt;instruction;
        switch (instruction) {
        case OP_JUMP:
        case OP_JUMP_IF_FALSE:
        case OP_JUMP_IF_TRUE:
        case OP_JUMP_IF_EQUAL:
        case OP_JUMP_IF_NOT_EQUAL:
        case OP_JUMP_IF_LESS:
        case OP_JUMP_IF_GREATER:
        case OP_JUMP_IF_LESS_EQUAL:
        case OP_JUMP_IF_GREATER_EQUAL: {
            IS_ADJUSTABLE(3, &lt;, target, +)
        }
        case OP_FOR: {
            IS_ADJUSTABLE(4, &lt;, target, +)
        }
        case OP_JUMP_IF_GREATER_LOCALS: {
            IS_ADJUSTABLE(5, &lt;, target, +)
        }
        case OP_LOOP: {
            IS_ADJUSTABLE(3, &gt;=, target, -)
        }
        case OP_FOR_LOOP: {
            IS_ADJUSTABLE(4, &gt;=, target, -)
        }
        case OP_INCREMENT_LOOP: {
            IS_ADJUSTABLE(5, &gt;=, target, -)
        }
        default:
            break;
        }
        view = view-&gt;next;
    }
    return NULL;
}

static void rewriting(Optimizer *optimizer, int start, int shift, bool inside) {
    uint8_t *instructions = optimizer-&gt;code-&gt;instructions;
    Instruction *view = optimizer-&gt;important;
    while (view != NULL) {
        int i = view-&gt;index;
        switch (view-&gt;instruction) {
        case OP_JUMP:
        case OP_JUMP_IF_FALSE:
        case OP_JUMP_IF_TRUE:
        case OP_JUMP_IF_EQUAL:
        case OP_JUMP_IF_NOT_EQUAL:
        case OP_JUMP_IF_LESS:
        case OP_JUMP_IF_GREATER:
        case OP_JUMP_IF_LESS_EQUAL:
        case OP_JUMP_IF_GREATER_EQUAL: {
            if (i &lt; start) {
                int jump = GET_JUMP(instructions, i, 1, 2);
                int destination = i + 3 + jump;
                assert((destination &lt; start || destination &gt; start + shift) || !inside);
                if (destination &gt; start) {
                    jump -= shift;
                    UPDATE_JUMP(instructions, i, 1, 2, jump)
                } else if (destination &gt;= start && destination &lt;= start + shift && inside) {
                    // not sure about this
                    jump -= next(optimizer-&gt;code-&gt;instructions[destination]);
                    UPDATE_JUMP(instructions, i, 1, 2, jump)
                }
            }
            break;
        }
        case OP_JUMP_IF_GREATER_LOCALS: {
            if (i &lt; start) {
                int jump = GET_JUMP(instructions, i, 3, 4);
                int destination = i + 5 + jump;
                assert((destination &lt; start || destination &gt; start + shift) || !inside);
                if (destination &gt; start) {
                    jump -= shift;
                    UPDATE_JUMP(instructions, i, 3, 4, jump)
                } else if (destination &gt;= start && destination &lt;= start + shift && inside) {
                    // not sure about this
                    jump -= next(optimizer-&gt;code-&gt;instructions[destination]);
                    UPDATE_JUMP(instructions, i, 3, 4, jump)
                }
            }
            break;
        }
        case OP_FOR: {
            if (i &lt; start) {
                int jump = GET_JUMP(instructions, i, 2, 3);
                int destination = i + 4 + jump;
                assert((destination &lt; start || destination &gt; start + shift) || !inside);
                if (destination &gt; start) {
                    jump -= shift;
                    UPDATE_JUMP(instructions, i, 2, 3, jump)
                }
            }
            break;
        }
        case OP_LOOP: {
            if (i &gt;= start) {
                int jump = GET_JUMP(instructions, i, 1, 2);
                int destination = i + 3 - jump;
                assert((destination &lt; start || destination &gt; start + shift) || !inside);
                if (destination &lt; start) {
                    jump -= shift;
                    UPDATE_JUMP(instructions, i, 1, 2, jump)
                } else if (destination &gt;= start && destination &lt;= start + shift && inside) {
                    // not sure about this
                    jump -= next(optimizer-&gt;code-&gt;instructions[destination]);
                    UPDATE_JUMP(instructions, i, 1, 2, jump)
                }
            }
            break;
        }
        case OP_FOR_LOOP: {
            if (i &gt;= start) {
                int jump = GET_JUMP(instructions, i, 2, 3);
                int destination = i + 3 - jump;
                assert((destination &lt; start || destination &gt; start + shift) || !inside);
                if (destination &lt; start) {
                    jump -= shift;
                    UPDATE_JUMP(instructions, i, 2, 3, jump)
                } else if (destination &gt;= start && destination &lt;= start + shift && inside) {
                    // not sure about this
                    jump -= next(optimizer-&gt;code-&gt;instructions[destination]);
                    UPDATE_JUMP(instructions, i, 2, 3, jump)
                }
            }
            break;
        }
        case OP_INCREMENT_LOOP: {
            if (i &gt;= start) {
                int jump = GET_JUMP(instructions, i, 3, 4);
                int destination = i + 5 - jump;
                assert((destination &lt; start || destination &gt; start + shift) || !inside);
                if (destination &lt; start) {
                    jump -= shift;
                    UPDATE_JUMP(instructions, i, 3, 4, jump)
                } else if (destination &gt;= start && destination &lt;= start + shift && inside) {
                    // not sure about this
                    jump -= next(optimizer-&gt;code-&gt;instructions[destination]);
                    UPDATE_JUMP(instructions, i, 3, 4, jump)
                }
            }
            break;
        }
        default: break;
        }
        if (i &gt;= start) {
            view-&gt;index = i - shift;
        }
        view = view-&gt;next;
    }

    int *lines = optimizer-&gt;code-&gt;lines;
    int count = optimizer-&gt;code-&gt;count - shift;
    for (int c = start; c &lt; count; c++) {
        int n = c + shift;
        instructions[c] = instructions[n];
        lines[c] = lines[n];
    }
    optimizer-&gt;code-&gt;count = count;

    HymnExceptList *except = optimizer-&gt;except;
    while (except != NULL) {
        if (start &lt; except-&gt;start) {
            except-&gt;start -= shift;
            except-&gt;end -= shift;
        } else if (start &lt; except-&gt;end) {
            except-&gt;end -= shift;
        }
        except = except-&gt;next;
    }
}

static void rewrite(Optimizer *optimizer, int start, int shift) {
    rewriting(optimizer, start, shift, true);
}

static void update(Optimizer *optimizer, int index, uint8_t instruction) {
    Instruction *view = optimizer-&gt;important;
    while (view != NULL) {
        if (index == view-&gt;index) {
            view-&gt;instruction = instruction;
            optimizer-&gt;code-&gt;instructions[index] = instruction;
            return;
        }
        view = view-&gt;next;
    }
    fprintf(stderr, &quot;optimization failed to find instruction to update\n&quot;);
    exit(1);
}

static void move(Optimizer *optimizer, int index, uint8_t instruction, int to) {
    Instruction *view = optimizer-&gt;important;
    while (view != NULL) {
        if (index == view-&gt;index) {
            view-&gt;index = to;
            view-&gt;instruction = instruction;
            optimizer-&gt;code-&gt;instructions[to] = instruction;
            return;
        }
        view = view-&gt;next;
    }
    fprintf(stderr, &quot;optimization failed to find instruction to move\n&quot;);
    exit(1);
}

static void deletion(Optimizer *optimizer, int index) {
    Instruction *view = optimizer-&gt;important;
    Instruction *previous = NULL;
    while (view != NULL) {
        if (index == view-&gt;index) {
            Instruction *next = view-&gt;next;
            free(view);
            if (previous == NULL) {
                optimizer-&gt;important = next;
            } else {
                previous-&gt;next = next;
            }
            return;
        }
        previous = view;
        view = view-&gt;next;
    }
    fprintf(stderr, &quot;optimization failed to find instruction to delete\n&quot;);
    exit(1);
}

static void interest(Optimizer *optimizer) {
    uint8_t *instructions = optimizer-&gt;code-&gt;instructions;
    int count = optimizer-&gt;code-&gt;count;
    Instruction *head = NULL;
    Instruction *tail = NULL;
    int i = 0;
    while (i &lt; count) {
        uint8_t instruction = instructions[i];
        switch (instruction) {
        case OP_JUMP:
        case OP_JUMP_IF_FALSE:
        case OP_JUMP_IF_TRUE:
        case OP_JUMP_IF_EQUAL:
        case OP_JUMP_IF_NOT_EQUAL:
        case OP_JUMP_IF_LESS:
        case OP_JUMP_IF_GREATER:
        case OP_JUMP_IF_GREATER_LOCALS:
        case OP_JUMP_IF_LESS_EQUAL:
        case OP_JUMP_IF_GREATER_EQUAL:
        case OP_FOR:
        case OP_LOOP:
        case OP_FOR_LOOP:
        case OP_INCREMENT_LOOP: {
            Instruction *important = hymn_calloc(1, sizeof(Instruction));
            important-&gt;index = i;
            important-&gt;instruction = instruction;
            if (tail == NULL) {
                head = important;
            } else {
                tail-&gt;next = important;
            }
            tail = important;
            break;
        }
        default:
            break;
        }
        i += next(instruction);
    }
    optimizer-&gt;important = head;
}

static void optimize(Compiler *C) {

    Scope *scope = C-&gt;scope;
    HymnFunction *func = scope-&gt;func;

    Optimizer optimizer = {0};
    optimizer.code = &func-&gt;code;
    optimizer.except = func-&gt;except;

    if (optimizer.code-&gt;count &lt;= 2) {
        return;
    }

    interest(&optimizer);

#define COUNT() optimizer.code-&gt;count
#define INSTRUCTION(I) optimizer.code-&gt;instructions[I]
#define CONSTANT(I) optimizer.code-&gt;constants.values[optimizer.code-&gt;instructions[I]]
#define SET(I, O) optimizer.code-&gt;instructions[I] = O
#define JUMP_IF(T, F)                        \
    if (second == OP_JUMP_IF_TRUE) {         \
        rewrite(&optimizer, one, 1);         \
        update(&optimizer, one, T);          \
        continue;                            \
    } else if (second == OP_JUMP_IF_FALSE) { \
        rewrite(&optimizer, one, 1);         \
        update(&optimizer, one, F);          \
        continue;                            \
    }

    int one = 0;

    while (one &lt; COUNT()) {

        uint8_t first = INSTRUCTION(one);
        int two = one + next(first);
        if (two &gt;= COUNT()) {
            break;
        }
        uint8_t second = INSTRUCTION(two);

        switch (first) {
        case OP_INCREMENT_LOCAL_AND_SET: {
            if (second == OP_LOOP) {
                // set to increment loop and reuse loop jump
                move(&optimizer, two, OP_INCREMENT_LOOP, one);
                // delete loop
                rewrite(&optimizer, two, 1);
                // subtract 1 to account for one less byte to jump after deleting instruction
                uint8_t *instructions = optimizer.code-&gt;instructions;
                int jump = GET_JUMP(instructions, one, 3, 4) - 1;
                UPDATE_JUMP(instructions, one, 3, 4, jump)
                continue;
            }
            break;
        }
        case OP_POP:
        case OP_POP_TWO: {
            if (second == OP_VOID) {
                rewriting(&optimizer, one, 1, false);
                continue;
            }
            break;
        }
        case OP_POP_N: {
            if (second == OP_VOID) {
                rewriting(&optimizer, one, 2, false);
                continue;
            }
            break;
        }
        default:
            break;
        }

        if (adjustable(&optimizer, two) != NULL) {
            goto next;
        }

        switch (first) {
        case OP_GET_LOCAL: {
            if (second == OP_GET_LOCAL) {
                SET(one, OP_GET_LOCALS);
                rewrite(&optimizer, one + 2, 1);
                continue;
            }
            break;
        }
        case OP_GET_LOCALS: {
            if (second == OP_LESS_EQUAL) {
                int three = two + next(second);
                uint8_t third = three &lt; COUNT() ? INSTRUCTION(three) : UINT8_MAX;
                if (third == OP_JUMP_IF_FALSE) {
                    move(&optimizer, three, OP_JUMP_IF_GREATER_LOCALS, one);
                    rewrite(&optimizer, two, 2);
                    continue;
                }
            }
            break;
        }
        case OP_POP: {
            if (second == OP_POP) {
                rewriting(&optimizer, one, 1, false);
                SET(one, OP_POP_TWO);
                continue;
            }
            break;
        }
        case OP_POP_TWO: {
            if (second == OP_POP) {
                SET(one, OP_POP_N);
                SET(one + 1, 3);
                continue;
            }
            break;
        }
        case OP_POP_N: {
            if (second == OP_POP) {
                uint8_t pop = INSTRUCTION(one + 1);
                if (pop &lt; UINT8_MAX - 1) {
                    rewriting(&optimizer, one + 1, 1, false);
                    SET(one + 1, (uint8_t)(pop + 1));
                    continue;
                }
            }
            break;
        }
        default:
            break;
        }

        if (adjustable(&optimizer, one) != NULL) {
            goto next;
        }

        switch (first) {
        case OP_RETURN: {
            if (second == OP_VOID) {
                rewrite(&optimizer, two, 1);
                continue;
            }
            break;
        }
        case OP_CALL: {
            if (second == OP_RETURN) {
                SET(one, OP_TAIL_CALL);
                continue;
            }
            break;
        }
        case OP_GET_GLOBAL: {
            if (second == OP_GET_PROPERTY) {
                SET(one, OP_GET_GLOBAL_PROPERTY);
                rewrite(&optimizer, one + 2, 1);
                continue;
            }
            break;
        }
        case OP_GET_LOCAL: {
            if (second == OP_CONSTANT) {
                int three = two + next(second);
                uint8_t third = three &lt; COUNT() ? INSTRUCTION(three) : UINT8_MAX;
                if (third == OP_ADD) {
                    HymnValue value = CONSTANT(two + 1);
                    if (hymn_is_int(value)) {
                        HymnInt add = hymn_as_int(value);
                        if (add &gt;= 0 && add &lt;= UINT8_MAX) {
                            uint8_t local = INSTRUCTION(one + 1);
                            rewrite(&optimizer, one, 2);
                            SET(one, OP_INCREMENT_LOCAL);
                            SET(one + 1, local);
                            SET(one + 2, (uint8_t)add);
                            continue;
                        }
                    }
                }
            }
            break;
        }
        case OP_GET_LOCALS: {
            if (second == OP_ADD) {
                SET(one, OP_ADD_LOCALS);
                rewrite(&optimizer, one + 3, 1);
                continue;
            } else if (second == OP_MODULO) {
                SET(one, OP_MODULO_LOCALS);
                rewrite(&optimizer, one + 3, 1);
                continue;
            } else if (second == OP_ARRAY_PUSH) {
                SET(one, OP_ARRAY_PUSH_LOCALS);
                rewrite(&optimizer, one + 3, 1);
                continue;
            }
            break;
        }
        case OP_INCREMENT_LOCAL: {
            if (second == OP_SET_LOCAL) {
                if (INSTRUCTION(one + 1) == INSTRUCTION(one + 4)) {
                    int three = two + next(second);
                    uint8_t third = three &lt; COUNT() ? INSTRUCTION(three) : UINT8_MAX;
                    if (third == OP_POP) {
                        SET(one, OP_INCREMENT_LOCAL_AND_SET);
                        rewrite(&optimizer, one + 3, 3);
                        continue;
                    }
                }
            }
            break;
        }
        case OP_CONSTANT: {
            if (second == OP_NEGATE) {
                HymnValue value = CONSTANT(one + 1);
                if (hymn_is_int(value)) {
                    value.as.i = -value.as.i;
                } else if (hymn_is_float(value)) {
                    value.as.f = -value.as.f;
                }
                uint8_t constant = byte_code_new_constant(C, value);
                SET(one + 1, constant);
                rewrite(&optimizer, one + 2, 1);
                continue;
            } else if (second == OP_ADD) {
                HymnValue value = CONSTANT(one + 1);
                if (hymn_is_int(value)) {
                    HymnInt add = hymn_as_int(value);
                    if (add &gt;= 0 && add &lt;= UINT8_MAX) {
                        SET(one, OP_INCREMENT);
                        SET(one + 1, (uint8_t)add);
                        rewrite(&optimizer, one + 2, 1);
                        continue;
                    }
                }
            }
            break;
        }
        case OP_EQUAL: {
            JUMP_IF(OP_JUMP_IF_EQUAL, OP_JUMP_IF_NOT_EQUAL)
            break;
        }
        case OP_NOT_EQUAL: {
            JUMP_IF(OP_JUMP_IF_NOT_EQUAL, OP_JUMP_IF_EQUAL)
            break;
        }
        case OP_LESS: {
            JUMP_IF(OP_JUMP_IF_LESS, OP_JUMP_IF_GREATER_EQUAL)
            break;
        }
        case OP_GREATER: {
            JUMP_IF(OP_JUMP_IF_GREATER, OP_JUMP_IF_LESS_EQUAL)
            break;
        }
        case OP_LESS_EQUAL: {
            JUMP_IF(OP_JUMP_IF_LESS_EQUAL, OP_JUMP_IF_GREATER)
            break;
        }
        case OP_GREATER_EQUAL: {
            JUMP_IF(OP_JUMP_IF_GREATER_EQUAL, OP_JUMP_IF_LESS)
            break;
        }
        case OP_TRUE: {
            if (second == OP_JUMP_IF_TRUE) {
                rewrite(&optimizer, one, 1);
                update(&optimizer, one, OP_JUMP);
                continue;
            } else if (second == OP_JUMP_IF_FALSE) {
                deletion(&optimizer, two);
                rewrite(&optimizer, one, 4);
                continue;
            }
            break;
        }
        case OP_FALSE: {
            if (second == OP_JUMP_IF_TRUE) {
                deletion(&optimizer, two);
                rewrite(&optimizer, one, 4);
                continue;
            } else if (second == OP_JUMP_IF_FALSE) {
                rewrite(&optimizer, one, 1);
                update(&optimizer, one, OP_JUMP);
                continue;
            }
            break;
        }
        case OP_NOT: {
            if (second == OP_JUMP_IF_TRUE) {
                rewrite(&optimizer, one, 1);
                update(&optimizer, one, OP_JUMP_IF_FALSE);
                continue;
            } else if (second == OP_JUMP_IF_FALSE) {
                rewrite(&optimizer, one, 1);
                update(&optimizer, one, OP_JUMP_IF_TRUE);
                continue;
            }
            break;
        }
        default:
            break;
        }

    next:
        one = two;
    }

    Instruction *important = optimizer.important;
    while (important != NULL) {
        Instruction *next = important-&gt;next;
        free(important);
        important = next;
    }
}

static void echo_if_none(Compiler *C) {
    HymnByteCode *code = &C-&gt;scope-&gt;func-&gt;code;
    int count = code-&gt;count;
    if (C-&gt;barrier == count) return;
    if (C-&gt;pop == count) code-&gt;instructions[count - 1] = OP_ECHO;
}

static HymnFunction *end_function(Compiler *C) {
    Scope *scope = C-&gt;scope;
    HymnFunction *func = scope-&gt;func;
    if (scope-&gt;type == TYPE_SCRIPT || scope-&gt;type == TYPE_REPL) echo_if_none(C);
    emit(C, OP_VOID);
#ifndef HYMN_NO_OPTIMIZE
    optimize(C);
#endif
    if (scope-&gt;type == TYPE_FUNCTION) func-&gt;source = hymn_substring(C-&gt;source, scope-&gt;begin, C-&gt;previous.start + C-&gt;previous.length);
    C-&gt;scope = scope-&gt;enclosing;
    return func;
}

static void compile_function(Compiler *C, enum FunctionType type, size_t begin) {
    Scope scope = {0};
    scope_init(C, &scope, type, begin);

    begin_scope(C);

    consume(C, TOKEN_LEFT_PAREN, &quot;expected '(' after function name&quot;);

    HymnFunction *func = C-&gt;scope-&gt;func;

    if (!check(C, TOKEN_RIGHT_PAREN)) {
        do {
            func-&gt;arity++;
            if (func-&gt;arity &gt; UINT8_MAX) {
                compile_error(C, &C-&gt;previous, &quot;too many function parameters&quot;);
            }
            uint8_t parameter = variable(C, &quot;expected parameter name&quot;);
            finalize_variable(C, parameter);
            type_declaration(C);
        } while (match(C, TOKEN_COMMA));
    }

    consume(C, TOKEN_RIGHT_PAREN, &quot;expected ')' after function parameters&quot;);
    type_declaration(C);
    consume(C, TOKEN_LEFT_CURLY, &quot;expected '{' after function parameters&quot;);

    while (!check(C, TOKEN_RIGHT_CURLY) && !check(C, TOKEN_EOF)) {
        declaration(C);
    }

    consume(C, TOKEN_RIGHT_CURLY, &quot;expected '}' at end of function body&quot;);

    end_function(C);
    emit_constant(C, hymn_new_func_value(func));
}

static void function_expression(Compiler *C, bool assign) {
    (void)assign;
    compile_function(C, TYPE_FUNCTION, C-&gt;previous.start);
}

static void declare_function(Compiler *C) {
    size_t begin = C-&gt;previous.start;
    uint8_t global = variable(C, &quot;expected function name&quot;);
    local_initialize(C);
    compile_function(C, TYPE_FUNCTION, begin);
    finalize_variable(C, global);
}

static void declaration(Compiler *C) {
    if (match(C, TOKEN_LET)) {
        define_new_variable(C);
    } else if (match(C, TOKEN_FUNCTION)) {
        declare_function(C);
    } else {
        statement(C);
    }
}

static void block(Compiler *C) {
    begin_scope(C);
    while (!check(C, TOKEN_RIGHT_CURLY) && !check(C, TOKEN_EOF)) {
        declaration(C);
    }
    end_scope(C);
}

static void if_statement(Compiler *C) {
    expression(C);
    int jump = emit_jump(C, OP_JUMP_IF_FALSE);

    free_jump_or_list(C);

    consume(C, TOKEN_LEFT_CURLY, &quot;expected '{' after if statement&quot;);
    begin_scope(C);
    while (!check(C, TOKEN_RIGHT_CURLY) && !check(C, TOKEN_EOF)) {
        declaration(C);
    }
    end_scope(C);

    consume(C, TOKEN_RIGHT_CURLY, &quot;expected '}' at end of if statement body&quot;);

    if (check(C, TOKEN_ELIF) || check(C, TOKEN_ELSE)) {
        JumpList jump_end = {0};
        jump_end.jump = emit_jump(C, OP_JUMP);
        JumpList *tail = &jump_end;

        while (match(C, TOKEN_ELIF)) {
            patch_jump(C, jump);
            free_jump_and_list(C);

            expression(C);
            jump = emit_jump(C, OP_JUMP_IF_FALSE);

            free_jump_or_list(C);

            consume(C, TOKEN_LEFT_CURLY, &quot;expected '{' after elif statement&quot;);
            begin_scope(C);
            while (!check(C, TOKEN_RIGHT_CURLY) && !check(C, TOKEN_EOF)) {
                declaration(C);
            }
            end_scope(C);
            consume(C, TOKEN_RIGHT_CURLY, &quot;expected '}' at end of elif statement body&quot;);

            JumpList *next = hymn_calloc(1, sizeof(JumpList));
            next-&gt;jump = emit_jump(C, OP_JUMP);

            tail-&gt;next = next;
            tail = next;
        }

        patch_jump(C, jump);
        free_jump_and_list(C);

        if (match(C, TOKEN_ELSE)) {
            consume(C, TOKEN_LEFT_CURLY, &quot;expected '{' after else statement&quot;);
            block(C);
            consume(C, TOKEN_RIGHT_CURLY, &quot;expected '}' at end of else statement body&quot;);
        }

        patch_jump(C, jump_end.jump);
        free_jumps(C, jump_end.next);
    } else {
        patch_jump(C, jump);
        free_jump_and_list(C);
    }
}

static void emit_loop(Compiler *C, int start) {
    emit(C, OP_LOOP);
    int offset = current(C)-&gt;count - start + 2;
    if (offset &gt; UINT16_MAX) {
        compile_error(C, &C-&gt;previous, &quot;loop is too large&quot;);
    }
    emit_short(C, (uint8_t)((offset &gt;&gt; 8) & UINT8_MAX), (uint8_t)(offset & UINT8_MAX));
}

static void patch_jump_list(Compiler *C) {
    while (C-&gt;jump != NULL) {
        int depth;
        if (C-&gt;loop == NULL) {
            depth = 1;
        } else {
            depth = C-&gt;loop-&gt;depth + 1;
        }
        if (C-&gt;jump-&gt;depth &lt; depth) {
            break;
        }
        patch_jump(C, C-&gt;jump-&gt;jump);
        JumpList *next = C-&gt;jump-&gt;next;
        free(C-&gt;jump);
        C-&gt;jump = next;
    }
}

static void patch_jump_for_list(Compiler *C) {
    while (C-&gt;jump_for != NULL) {
        int depth;
        if (C-&gt;loop == NULL) {
            depth = 1;
        } else {
            depth = C-&gt;loop-&gt;depth;
        }
        if (C-&gt;jump_for-&gt;depth &lt; depth) {
            break;
        }
        patch_jump(C, C-&gt;jump_for-&gt;jump);
        JumpList *next = C-&gt;jump_for-&gt;next;
        free(C-&gt;jump_for);
        C-&gt;jump_for = next;
    }
}

static void iterator_statement(Compiler *C, bool pair) {
    local_initialize(C);

    int index = C-&gt;scope-&gt;local_count;

    if (index &lt;= 0 || index &gt;= UINT8_MAX) {
        compile_error(C, &C-&gt;current, &quot;too many local variables in iterator&quot;);
        return;
    }

    uint8_t value = (uint8_t)(index + 1);
    uint8_t object = (uint8_t)(index - 1);

    push_hidden_local(C);

    if (pair) {
        variable(C, &quot;expected variable name in for loop&quot;);
        local_initialize(C);
        consume(C, TOKEN_IN, &quot;expected 'in' after variable name in for loop&quot;);
        C-&gt;scope-&gt;locals[index].name = C-&gt;scope-&gt;locals[object].name;
    } else {
        push_hidden_local(C);
        C-&gt;scope-&gt;locals[value].name = C-&gt;scope-&gt;locals[object].name;
    }

    C-&gt;scope-&gt;locals[object].name = (Token){0};

    // IN

    expression(C);

    emit_short(C, OP_FOR, object);
    emit_short(C, UINT8_MAX, UINT8_MAX);

    int start = current(C)-&gt;count;
    int jump = start - 2;

    LoopList loop = {.start = start, .depth = C-&gt;scope-&gt;depth + 1, .next = C-&gt;loop, .is_for = true};
    C-&gt;loop = &loop;

    // BODY

    consume(C, TOKEN_LEFT_CURLY, &quot;expected '{' after for loop declaration&quot;);
    block(C);

    // LOOP

    patch_jump_for_list(C);

    emit_short(C, OP_FOR_LOOP, object);
    int offset = current(C)-&gt;count - start + 2;
    if (offset &gt; UINT16_MAX) {
        compile_error(C, &C-&gt;previous, &quot;loop is too large&quot;);
    }
    emit_short(C, (uint8_t)((offset &gt;&gt; 8) & UINT8_MAX), (uint8_t)(offset & UINT8_MAX));

    // END

    C-&gt;loop = loop.next;

    patch_jump(C, jump);
    patch_jump_list(C);

    end_scope(C);

    consume(C, TOKEN_RIGHT_CURLY, &quot;expected '}' at end of for loop&quot;);
}

static void for_statement(Compiler *C) {
    begin_scope(C);

    // ASSIGN

    uint8_t index = (uint8_t)C-&gt;scope-&gt;local_count;

    variable(C, &quot;expected variable name in for loop&quot;);

    if (match(C, TOKEN_ASSIGN)) {
        expression(C);
        local_initialize(C);
        consume(C, TOKEN_COMMA, &quot;expected ',' in for loop after variable assignment&quot;);
    } else if (match(C, TOKEN_COMMA)) {
        iterator_statement(C, true);
        return;
    } else if (match(C, TOKEN_IN)) {
        iterator_statement(C, false);
        return;
    } else {
        compile_error(C, &C-&gt;previous, &quot;incomplete for loop declaration&quot;);
        return;
    }

    // COMPARE

    int compare = current(C)-&gt;count;

    expression(C);

    int jump = emit_jump(C, OP_JUMP_IF_FALSE);

    // INCREMENT

    int increment = current(C)-&gt;count;

    LoopList loop = {.start = increment, .depth = C-&gt;scope-&gt;depth + 1, .next = C-&gt;loop, .is_for = true};
    C-&gt;loop = &loop;

    if (match(C, TOKEN_COMMA)) {
        expression_statement(C);
    } else {
        emit_word(C, OP_INCREMENT_LOCAL_AND_SET, index, 1);
    }

    HymnByteCode *code = current(C);

    int count = code-&gt;count - increment;
    uint8_t *instructions = hymn_malloc_int(count, sizeof(uint8_t));
    int *lines = hymn_malloc_int(count, sizeof(int));
    hymn_mem_copy(instructions, &code-&gt;instructions[increment], count, sizeof(uint8_t));
    hymn_mem_copy(lines, &code-&gt;lines[increment], count, sizeof(int));
    code-&gt;count = increment;

    // BODY

    consume(C, TOKEN_LEFT_CURLY, &quot;expected '{' after for loop declaration&quot;);
    block(C);

    // INCREMENT

    patch_jump_for_list(C);

    while (code-&gt;count + count &gt; code-&gt;capacity) {
        code-&gt;capacity *= 2;
        code-&gt;instructions = hymn_realloc_int(code-&gt;instructions, code-&gt;capacity, sizeof(uint8_t));
        code-&gt;lines = hymn_realloc_int(code-&gt;lines, code-&gt;capacity, sizeof(int));
    }
    hymn_mem_copy(&code-&gt;instructions[code-&gt;count], instructions, count, sizeof(uint8_t));
    hymn_mem_copy(&code-&gt;lines[code-&gt;count], lines, count, sizeof(int));
    code-&gt;count += count;
    free(instructions);
    free(lines);

    emit_loop(C, compare);

    // END

    C-&gt;loop = loop.next;

    patch_jump(C, jump);
    patch_jump_list(C);

    end_scope(C);

    consume(C, TOKEN_RIGHT_CURLY, &quot;expected '}' at end of for loop&quot;);
}

static void while_statement(Compiler *C) {
    int start = current(C)-&gt;count;

    LoopList loop = {.start = start, .depth = C-&gt;scope-&gt;depth + 1, .next = C-&gt;loop, .is_for = false};
    C-&gt;loop = &loop;

    expression(C);

    int jump = emit_jump(C, OP_JUMP_IF_FALSE);

    consume(C, TOKEN_LEFT_CURLY, &quot;expected '{' after while loop declaration&quot;);
    block(C);
    emit_loop(C, start);

    C-&gt;loop = loop.next;

    patch_jump(C, jump);
    patch_jump_list(C);

    consume(C, TOKEN_RIGHT_CURLY, &quot;expected '}' at end of while loop&quot;);
}

static void return_statement(Compiler *C) {
    if (C-&gt;scope-&gt;type != TYPE_FUNCTION) {
        compile_error(C, &C-&gt;previous, &quot;return statement outside of function&quot;);
    }
    if (check(C, TOKEN_RIGHT_CURLY)) {
        emit(C, OP_VOID);
    } else {
        expression(C);
        emit(C, OP_RETURN);
    }
}

static void pop_stack_loop(Compiler *C) {
    int depth = C-&gt;loop-&gt;depth;
    Scope *scope = C-&gt;scope;
    for (int i = scope-&gt;local_count; i &gt; 0; i--) {
        if (scope-&gt;locals[i - 1].depth &lt; depth) {
            return;
        }
        emit_pop(C);
    }
}

static void break_statement(Compiler *C) {
    if (C-&gt;loop == NULL) {
        compile_error(C, &C-&gt;previous, &quot;break statement outside of loop&quot;);
    }
    pop_stack_loop(C);
    JumpList *jump_next = C-&gt;jump;
    JumpList *jump = hymn_malloc(sizeof(JumpList));
    jump-&gt;jump = emit_jump(C, OP_JUMP);
    jump-&gt;depth = C-&gt;loop-&gt;depth;
    jump-&gt;next = jump_next;
    C-&gt;jump = jump;
}

static void continue_statement(Compiler *C) {
    if (C-&gt;loop == NULL) {
        compile_error(C, &C-&gt;previous, &quot;continue statement outside of loop&quot;);
    }
    pop_stack_loop(C);
    if (C-&gt;loop-&gt;is_for) {
        JumpList *jump_next = C-&gt;jump_for;
        JumpList *jump = hymn_malloc(sizeof(JumpList));
        jump-&gt;jump = emit_jump(C, OP_JUMP);
        jump-&gt;depth = C-&gt;loop-&gt;depth;
        jump-&gt;next = jump_next;
        C-&gt;jump_for = jump;
    } else {
        emit_loop(C, C-&gt;loop-&gt;start);
    }
}

static void try_statement(Compiler *C) {
    HymnByteCode *code = current(C);

    HymnExceptList *except = hymn_calloc(1, sizeof(HymnExceptList));
    except-&gt;locals = C-&gt;scope-&gt;local_count;
    except-&gt;start = code-&gt;count;

    HymnFunction *func = C-&gt;scope-&gt;func;
    except-&gt;next = func-&gt;except;
    func-&gt;except = except;

    consume(C, TOKEN_LEFT_CURLY, &quot;expected '{' after try declaration&quot;);
    begin_scope(C);
    while (!check(C, TOKEN_RIGHT_CURLY) && !check(C, TOKEN_EOF)) {
        declaration(C);
    }
    end_scope(C);

    int jump = emit_jump(C, OP_JUMP);

    consume(C, TOKEN_RIGHT_CURLY, &quot;expected '}' at end of try statement&quot;);
    consume(C, TOKEN_EXCEPT, &quot;expected 'except' at end of try statement&quot;);

    except-&gt;end = code-&gt;count;

    begin_scope(C);
    uint8_t message = variable(C, &quot;expected variable name in exception declaration&quot;);
    finalize_variable(C, message);
    consume(C, TOKEN_LEFT_CURLY, &quot;expected '{' after exception declaration&quot;);
    while (!check(C, TOKEN_RIGHT_CURLY) && !check(C, TOKEN_EOF)) {
        declaration(C);
    }
    end_scope(C);

    consume(C, TOKEN_RIGHT_CURLY, &quot;expected '}' at end of exception statement&quot;);

    patch_jump(C, jump);
}

static void echo_statement(Compiler *C) {
    expression(C);
    emit(C, OP_ECHO);
}

static void print_statement(Compiler *C) {
    consume(C, TOKEN_LEFT_PAREN, &quot;expected opening '(' in call to 'print'&quot;);
    expression(C);
    consume(C, TOKEN_COMMA, &quot;not enough arguments in call to 'print' (expected 2)&quot;);
    expression(C);
    consume(C, TOKEN_RIGHT_PAREN, &quot;expected closing ')' in call to 'print'&quot;);
    emit(C, OP_PRINT);
}

static void push_statement(Compiler *C) {
    consume(C, TOKEN_LEFT_PAREN, &quot;expected opening '(' in call to 'push'&quot;);
    expression(C);
    consume(C, TOKEN_COMMA, &quot;not enough arguments in call to 'push' (expected 2)&quot;);
    expression(C);
    consume(C, TOKEN_RIGHT_PAREN, &quot;expected closing ')' in call to 'push'&quot;);
    emit(C, OP_ARRAY_PUSH);
}

static void insert_statement(Compiler *C) {
    consume(C, TOKEN_LEFT_PAREN, &quot;expected opening '(' in call to 'insert'&quot;);
    expression(C);
    consume(C, TOKEN_COMMA, &quot;not enough arguments in call to 'insert' (expected 3)&quot;);
    expression(C);
    consume(C, TOKEN_COMMA, &quot;not enough arguments in call to 'insert' (expected 3)&quot;);
    expression(C);
    consume(C, TOKEN_RIGHT_PAREN, &quot;expected closing ')' in call to 'insert'&quot;);
    emit(C, OP_INSERT);
}

static void use_statement(Compiler *C) {
    expression(C);
    emit(C, OP_USE);
}

static void throw_statement(Compiler *C) {
    expression(C);
    emit(C, OP_THROW);
}

static void statement(Compiler *C) {
    if (match(C, TOKEN_ECHO)) {
        echo_statement(C);
    } else if (match(C, TOKEN_PRINT)) {
        print_statement(C);
    } else if (match(C, TOKEN_PUSH)) {
        push_statement(C);
    } else if (match(C, TOKEN_INSERT)) {
        insert_statement(C);
    } else if (match(C, TOKEN_USE)) {
        use_statement(C);
    } else if (match(C, TOKEN_IF)) {
        if_statement(C);
    } else if (match(C, TOKEN_FOR)) {
        for_statement(C);
    } else if (match(C, TOKEN_WHILE)) {
        while_statement(C);
    } else if (match(C, TOKEN_RETURN)) {
        return_statement(C);
    } else if (match(C, TOKEN_BREAK)) {
        break_statement(C);
    } else if (match(C, TOKEN_CONTINUE)) {
        continue_statement(C);
    } else if (match(C, TOKEN_TRY)) {
        try_statement(C);
    } else if (match(C, TOKEN_THROW)) {
        throw_statement(C);
    } else if (match(C, TOKEN_LEFT_CURLY)) {
        block(C);
        consume(C, TOKEN_RIGHT_CURLY, &quot;expected '}' at end of block statement&quot;);
    } else {
        expression_statement(C);
    }
}

static void array_pop_expression(Compiler *C, bool assign) {
    (void)assign;
    consume(C, TOKEN_LEFT_PAREN, &quot;expected opening '(' in call to 'pop'&quot;);
    expression(C);
    consume(C, TOKEN_RIGHT_PAREN, &quot;expected closing ')' in call to 'pop'&quot;);
    emit(C, OP_ARRAY_POP);
}

static void delete_expression(Compiler *C, bool assign) {
    (void)assign;
    consume(C, TOKEN_LEFT_PAREN, &quot;expected opening '(' in call to 'delete'&quot;);
    expression(C);
    consume(C, TOKEN_COMMA, &quot;not enough arguments in call to 'delete' (expected 2)&quot;);
    expression(C);
    consume(C, TOKEN_RIGHT_PAREN, &quot;expected closing ')' in call to 'delete'&quot;);
    emit(C, OP_DELETE);
}

static void len_expression(Compiler *C, bool assign) {
    (void)assign;
    consume(C, TOKEN_LEFT_PAREN, &quot;expected opening '(' in call to 'len'&quot;);
    expression(C);
    consume(C, TOKEN_RIGHT_PAREN, &quot;expected closing ')' in call to 'len'&quot;);
    emit(C, OP_LEN);
}

static void cast_integer_expression(Compiler *C, bool assign) {
    (void)assign;
    consume(C, TOKEN_LEFT_PAREN, &quot;expected opening '(' in call to 'int'&quot;);
    expression(C);
    consume(C, TOKEN_RIGHT_PAREN, &quot;expected closing ')' in call to 'int'&quot;);
    emit(C, OP_INT);
}

static void cast_float_expression(Compiler *C, bool assign) {
    (void)assign;
    consume(C, TOKEN_LEFT_PAREN, &quot;expected opening '(' in call to 'float'&quot;);
    expression(C);
    consume(C, TOKEN_RIGHT_PAREN, &quot;expected closing ')' in call to 'float'&quot;);
    emit(C, OP_FLOAT);
}

static void cast_string_expression(Compiler *C, bool assign) {
    (void)assign;
    consume(C, TOKEN_LEFT_PAREN, &quot;expected opening '(' in call to 'str'&quot;);
    expression(C);
    consume(C, TOKEN_RIGHT_PAREN, &quot;expected closing ')' in call to 'str'&quot;);
    emit(C, OP_STRING);
}

static void type_expression(Compiler *C, bool assign) {
    (void)assign;
    consume(C, TOKEN_LEFT_PAREN, &quot;expected opening '(' in call to 'type'&quot;);
    expression(C);
    consume(C, TOKEN_RIGHT_PAREN, &quot;expected closing ')' in call to 'type'&quot;);
    emit(C, OP_TYPE);
}

static void clear_expression(Compiler *C, bool assign) {
    (void)assign;
    consume(C, TOKEN_LEFT_PAREN, &quot;expected opening '(' in call to 'clear'&quot;);
    expression(C);
    consume(C, TOKEN_RIGHT_PAREN, &quot;expected closing ')' in call to 'clear'&quot;);
    emit(C, OP_CLEAR);
}

static void copy_expression(Compiler *C, bool assign) {
    (void)assign;
    consume(C, TOKEN_LEFT_PAREN, &quot;expected opening '(' in call to 'copy'&quot;);
    expression(C);
    consume(C, TOKEN_RIGHT_PAREN, &quot;expected closing ')' in call to 'copy'&quot;);
    emit(C, OP_COPY);
}

static void keys_expression(Compiler *C, bool assign) {
    (void)assign;
    consume(C, TOKEN_LEFT_PAREN, &quot;expected opening '(' in call to 'keys'&quot;);
    expression(C);
    consume(C, TOKEN_RIGHT_PAREN, &quot;expected closing ')' in call to 'keys'&quot;);
    emit(C, OP_KEYS);
}

static void index_expression(Compiler *C, bool assign) {
    (void)assign;
    consume(C, TOKEN_LEFT_PAREN, &quot;expected opening '(' in call to 'index'&quot;);
    expression(C);
    consume(C, TOKEN_COMMA, &quot;not enough arguments in call to 'index' (expected 2)&quot;);
    expression(C);
    consume(C, TOKEN_RIGHT_PAREN, &quot;expected closing ')' in call to 'index'&quot;);
    emit(C, OP_INDEX);
}

static void exists_expression(Compiler *C, bool assign) {
    (void)assign;
    consume(C, TOKEN_LEFT_PAREN, &quot;expected opening '(' in call to 'exists'&quot;);
    expression(C);
    consume(C, TOKEN_COMMA, &quot;not enough arguments in call to 'exists' (expected 2)&quot;);
    expression(C);
    consume(C, TOKEN_RIGHT_PAREN, &quot;expected closing ')' in call to 'exists'&quot;);
    emit(C, OP_EXISTS);
}

static void inspect_expression(Compiler *C, bool assign) {
    (void)assign;
    consume(C, TOKEN_LEFT_PAREN, &quot;expected opening '(' in call to 'inspect'&quot;);
    expression(C);
    consume(C, TOKEN_RIGHT_PAREN, &quot;expected closing ')' in call to 'inspect'&quot;);
    emit(C, OP_INSPECT);
}

static void debug_expression(Compiler *C, bool assign) {
    (void)assign;
    consume(C, TOKEN_LEFT_PAREN, &quot;expected opening '(' in call to 'debug'&quot;);
    expression(C);
    consume(C, TOKEN_RIGHT_PAREN, &quot;expected closing ')' in call to 'debug'&quot;);
    emit(C, OP_DEBUG);
}

static void expression_statement(Compiler *C) {
    expression(C);
    emit_pop(C);
}

static void expression(Compiler *C) {
    compile_with_precedence(C, PRECEDENCE_ASSIGN);
}

static HymnFrame *parent_frame(Hymn *H, int offset) {
    int frame_count = H-&gt;frame_count;
    if (offset &gt; frame_count) return NULL;
    return &H-&gt;frames[frame_count - offset];
}

static HymnFrame *current_frame(Hymn *H) {
    return &H-&gt;frames[H-&gt;frame_count - 1];
}

static CompileResult compile(Hymn *H, const char *script, const char *source, enum FunctionType type) {
    Scope scope = {0};
    Compiler C = {0};
    C.row = 1;
    C.column = 1;
    C.script = script;
    C.source = source;
    C.interactive = type == TYPE_REPL;
    C.size = strlen(source);
    C.previous.type = TOKEN_UNDEFINED;
    C.current.type = TOKEN_UNDEFINED;
    C.string_status = STRING_STATUS_NONE;
    C.H = H;
    C.pop = -1;
    C.barrier = -1;
    scope_init(&C, &scope, type, 0);

    advance(&C);
    while (!match(&C, TOKEN_EOF)) {
        declaration(&C);
    }

    HymnFunction *func = end_function(&C);

    if (C.error != NULL) {
        char *error = string_to_chars(C.error);
        hymn_string_delete(C.error);

        HymnValuePool *constants = &func-&gt;code.constants;
        int count = constants-&gt;count;
        HymnValue *values = constants-&gt;values;

        for (int i = 0; i &lt; count; i++) {
            HymnValue value = values[i];
            if (hymn_is_func(value)) {
                function_delete(hymn_as_func(value));
            }
        }

        function_delete(func);
        return (CompileResult){.func = NULL, .error = error};
    }

    return (CompileResult){.func = func, .error = NULL};
}

HymnString *hymn_quote_string(HymnString *string) {
    size_t len = hymn_string_len(string);
    size_t extra = 2;
    for (size_t s = 0; s &lt; len; s++) {
        char c = string[s];
        if (c == '\\' || c == '\&quot;') {
            extra++;
        }
    }
    HymnString *quoted = hymn_new_string_with_capacity(len + extra);
    quoted[0] = '&quot;';
    size_t q = 1;
    for (size_t s = 0; s &lt; len; s++) {
        char c = string[s];
        if (c == '\\') {
            quoted[q++] = '\\';
            quoted[q++] = '\\';
        } else if (c == '&quot;') {
            quoted[q++] = '\\';
            quoted[q++] = '&quot;';
        } else {
            quoted[q++] = c;
        }
    }
    HymnStringHead *head = hymn_string_head(quoted);
    head-&gt;length = head-&gt;capacity;
    quoted[len + extra - 1] = '&quot;';
    quoted[len + extra] = '\0';
    return quoted;
}

struct PointerSet {
    int count;
    int capacity;
    void **items;
};

static bool pointer_set_has(struct PointerSet *set, void *pointer) {
    void **items = set-&gt;items;
    if (items) {
        int count = set-&gt;count;
        for (int i = 0; i &lt; count; i++) {
            if (pointer == items[i]) {
                return true;
            }
        }
    }
    return false;
}

static void pointer_set_add(struct PointerSet *set, void *pointer) {
    if (set-&gt;items) {
        int count = set-&gt;count;
        if (count &gt;= set-&gt;capacity) {
            set-&gt;capacity *= 2;
            set-&gt;items = hymn_realloc_int(set-&gt;items, set-&gt;capacity, sizeof(void *));
        }
        set-&gt;items[count] = pointer;
        set-&gt;count = count + 1;
    } else {
        set-&gt;count = 1;
        set-&gt;capacity = 1;
        set-&gt;items = hymn_calloc(1, sizeof(void *));
        set-&gt;items[0] = pointer;
    }
}

static HymnString *value_to_string_recusive(HymnValue value, struct PointerSet *set, bool quote) {
    switch (value.is) {
    case HYMN_VALUE_UNDEFINED: return hymn_new_string(&quot;undefined&quot;);
    case HYMN_VALUE_NONE: return hymn_new_string(&quot;none&quot;);
    case HYMN_VALUE_BOOL: return hymn_as_bool(value) ? hymn_new_string(&quot;true&quot;) : hymn_new_string(&quot;false&quot;);
    case HYMN_VALUE_INTEGER: return hymn_int_to_string(hymn_as_int(value));
    case HYMN_VALUE_FLOAT: return hymn_float_to_string(hymn_as_float(value));
    case HYMN_VALUE_STRING: {
        if (quote) return hymn_quote_string(hymn_as_string(value));
        return hymn_string_copy(hymn_as_string(value));
    }
    case HYMN_VALUE_ARRAY: {
        HymnArray *array = hymn_as_array(value);
        if (array == NULL || array-&gt;length == 0) {
            return hymn_new_string(&quot;[]&quot;);
        }
        if (pointer_set_has(set, array)) {
            return hymn_new_string(&quot;[..]&quot;);
        } else {
            pointer_set_add(set, array);
        }
        HymnString *string = hymn_new_string(&quot;[&quot;);
        for (HymnInt i = 0; i &lt; array-&gt;length; i++) {
            if (i != 0) {
                string = hymn_string_append(string, &quot;, &quot;);
            }
            HymnString *add = value_to_string_recusive(array-&gt;items[i], set, true);
            string = hymn_string_append(string, add);
            hymn_string_delete(add);
        }
        string = hymn_string_append_char(string, ']');
        return string;
    }
    case HYMN_VALUE_TABLE: {
        HymnTable *table = hymn_as_table(value);
        if (table == NULL || table-&gt;size == 0) {
            return hymn_new_string(&quot;{}&quot;);
        } else if (pointer_set_has(set, table)) {
            return hymn_new_string(&quot;{ .. }&quot;);
        } else {
            pointer_set_add(set, table);
        }
        int size = table-&gt;size;
        HymnObjectString **keys = hymn_malloc_int(size, sizeof(HymnObjectString *));
        unsigned int total = 0;
        unsigned int bins = table-&gt;bins;
        for (unsigned int i = 0; i &lt; bins; i++) {
            HymnTableItem *item = table-&gt;items[i];
            while (item != NULL) {
                HymnString *string = item-&gt;key-&gt;string;
                unsigned int insert = 0;
                while (insert != total) {
                    if (strcmp(string, keys[insert]-&gt;string) &lt; 0) {
                        for (unsigned int swap = total; swap &gt; insert; swap--) {
                            keys[swap] = keys[swap - 1];
                        }
                        break;
                    }
                    insert++;
                }
                keys[insert] = item-&gt;key;
                total++;
                item = item-&gt;next;
            }
        }
        HymnString *string = hymn_new_string(&quot;{ &quot;);
        for (int i = 0; i &lt; size; i++) {
            if (i != 0) {
                string = hymn_string_append(string, &quot;, &quot;);
            }
            HymnObjectString *key = keys[i];
            HymnValue item = table_get(table, key);
            HymnString *add = value_to_string_recusive(item, set, true);
            HymnString *quoting = hymn_quote_string(key-&gt;string);
            string = hymn_string_append(string, quoting);
            string = hymn_string_append(string, &quot;: &quot;);
            string = hymn_string_append(string, add);
            hymn_string_delete(quoting);
            hymn_string_delete(add);
        }
        string = hymn_string_append(string, &quot; }&quot;);
        free(keys);
        return string;
    }
    case HYMN_VALUE_FUNC: {
        HymnFunction *func = hymn_as_func(value);
        if (func-&gt;name) return hymn_string_copy(func-&gt;name);
        if (func-&gt;script) return hymn_string_copy(func-&gt;script);
        return hymn_new_string(&quot;script&quot;);
    }
    case HYMN_VALUE_FUNC_NATIVE: return hymn_string_copy(hymn_as_native(value)-&gt;name-&gt;string);
    case HYMN_VALUE_POINTER: return hymn_string_format(&quot;%p&quot;, hymn_as_pointer(value));
    default:
        break;
    }
    return hymn_new_string(&quot;?&quot;);
}

HymnString *hymn_value_to_string(HymnValue value) {
    struct PointerSet set = {.count = 0, .capacity = 0, .items = NULL};
    HymnString *string = value_to_string_recusive(value, &set, false);
    free(set.items);
    return string;
}

static HymnString *value_concat(HymnValue a, HymnValue b) {
    HymnString *string = hymn_value_to_string(a);
    HymnString *second = hymn_value_to_string(b);
    string = hymn_string_append(string, second);
    hymn_string_delete(second);
    return string;
}

static HymnString *debug_value_to_string(HymnValue value) {
    HymnString *string = hymn_value_to_string(value);
    HymnString *format = hymn_string_format(&quot;%s: %s&quot;, hymn_value_type(value.is), string);
    hymn_string_delete(string);
    return format;
}

static void reset_stack(Hymn *H) {
    H-&gt;stack_top = H-&gt;stack;
    H-&gt;frame_count = 0;
}

#ifdef HYMN_DEBUG_MEMORY
static void debug_value(HymnValue value) {
    HymnString *string = debug_value_to_string(value);
    printf(&quot;%s&quot;, string);
    hymn_string_delete(string);
}

static void debug_reference(HymnValue value) {
    int count;
    switch (value.is) {
    case HYMN_VALUE_STRING:
        count = hymn_as_hymn_string(value)-&gt;count;
        break;
    case HYMN_VALUE_ARRAY:
        count = hymn_as_array(value)-&gt;count;
        break;
    case HYMN_VALUE_TABLE:
        count = hymn_as_table(value)-&gt;count;
        break;
    case HYMN_VALUE_FUNC:
        count = hymn_as_func(value)-&gt;count;
        break;
    case HYMN_VALUE_FUNC_NATIVE:
        count = hymn_as_native(value)-&gt;count;
        break;
    default:
        return;
    }
    printf(&quot;REF     | [%p] [&quot;, (void *)value.as.o);
    debug_value(value);
    printf(&quot;] [%d]\n&quot;, count);
    assert(count &gt;= 0);
}

static void debug_dereference(HymnValue value) {
    int count;
    switch (value.is) {
    case HYMN_VALUE_STRING:
        count = hymn_as_hymn_string(value)-&gt;count;
        break;
    case HYMN_VALUE_ARRAY:
        count = hymn_as_array(value)-&gt;count;
        break;
    case HYMN_VALUE_TABLE:
        count = hymn_as_table(value)-&gt;count;
        break;
    case HYMN_VALUE_FUNC:
        count = hymn_as_func(value)-&gt;count;
        break;
    case HYMN_VALUE_FUNC_NATIVE:
        count = hymn_as_native(value)-&gt;count;
        break;
    default:
        return;
    }
    count--;
    if (count == 0) {
        printf(&quot;FREE    | [%p] [&quot;, (void *)object);
        debug_value(value);
        printf(&quot;]\n&quot;);
    } else if (count &lt; 0) {
        printf(&quot;BAD     | [%p] [&quot;, (void *)object);
        debug_value(value);
        printf(&quot;]\n&quot;);
    } else {
        printf(&quot;DEREF   | [%p] [&quot;, (void *)object);
        debug_value(value);
        printf(&quot;] [%d]\n&quot;, count);
    }
    assert(count &gt;= 0);
}
#endif

#ifdef HYMN_NO_MEMORY_MANAGE
void hymn_reference_string(HymnObjectString *string) {
    (void)string;
}
#else
void hymn_reference_string(HymnObjectString *string) {
    string-&gt;count++;
#ifdef HYMN_DEBUG_MEMORY
    debug_reference(hymn_new_string_value(string));
#endif
}
#endif

#ifdef HYMN_NO_MEMORY_MANAGE
void hymn_reference(HymnValue value) {
    (void)value;
}
#else
void hymn_reference(HymnValue value) {
    switch (value.is) {
    case HYMN_VALUE_STRING:
        ((HymnObjectString *)value.as.o)-&gt;count++;
#ifdef HYMN_DEBUG_MEMORY
        debug_reference(value);
#endif
        return;
    case HYMN_VALUE_ARRAY:
        ((HymnArray *)value.as.o)-&gt;count++;
#ifdef HYMN_DEBUG_MEMORY
        debug_reference(value);
#endif
        return;
    case HYMN_VALUE_TABLE:
        ((HymnTable *)value.as.o)-&gt;count++;
#ifdef HYMN_DEBUG_MEMORY
        debug_reference(value);
#endif
        return;
    case HYMN_VALUE_FUNC:
        ((HymnFunction *)value.as.o)-&gt;count++;
#ifdef HYMN_DEBUG_MEMORY
        debug_reference(value);
#endif
        return;
    case HYMN_VALUE_FUNC_NATIVE:
        ((HymnNativeFunction *)value.as.o)-&gt;count++;
#ifdef HYMN_DEBUG_MEMORY
        debug_reference(value);
#endif
        return;
    default:
        return;
    }
}
#endif

#ifdef HYMN_NO_MEMORY_MANAGE
void hymn_dereference_string(Hymn *H, HymnObjectString *string) {
    (void)H;
    (void)string;
}
#else
void hymn_dereference_string(Hymn *H, HymnObjectString *string) {
#ifdef HYMN_DEBUG_MEMORY
    debug_dereference(hymn_new_string_value(string));
#endif
    int count = --string-&gt;count;
    assert(count &gt;= 0);
    if (count == 0) {
        set_remove(&H-&gt;strings, string-&gt;string);
        hymn_string_delete(string-&gt;string);
        free(string);
    }
}
#endif

#ifdef HYMN_NO_MEMORY_MANAGE
void hymn_dereference(Hymn *H, HymnValue value) {
    (void)H;
    (void)value;
}
#else
void hymn_dereference(Hymn *H, HymnValue value) {
    switch (value.is) {
    case HYMN_VALUE_STRING: {
        HymnObjectString *string = (HymnObjectString *)value.as.o;
        hymn_dereference_string(H, string);
        return;
    }
    case HYMN_VALUE_ARRAY: {
#ifdef HYMN_DEBUG_MEMORY
        debug_dereference(value);
#endif
        HymnArray *array = (HymnArray *)value.as.o;
        int count = --array-&gt;count;
        assert(count &gt;= 0);
        if (count == 0) {
            hymn_array_delete(H, array);
        }
        return;
    }
    case HYMN_VALUE_TABLE: {
#ifdef HYMN_DEBUG_MEMORY
        debug_dereference(value);
#endif
        HymnTable *table = (HymnTable *)value.as.o;
        int count = --table-&gt;count;
        assert(count &gt;= 0);
        if (count == 0) {
            table_delete(H, table);
        }
        return;
    }
    case HYMN_VALUE_FUNC: {
#ifdef HYMN_DEBUG_MEMORY
        debug_dereference(value);
#endif
        HymnFunction *func = (HymnFunction *)value.as.o;
        int count = --func-&gt;count;
        assert(count &gt;= 0);
        if (count == 0) {
            function_delete(func);
        }
        return;
    }
    case HYMN_VALUE_FUNC_NATIVE: {
#ifdef HYMN_DEBUG_MEMORY
        debug_dereference(value);
#endif
        HymnNativeFunction *func = (HymnNativeFunction *)value.as.o;
        int count = --func-&gt;count;
        assert(count &gt;= 0);
        if (count == 0) {
            native_function_delete(H, func);
        }
        return;
    }
    default:
        return;
    }
}
#endif

static void push(Hymn *H, HymnValue value) {
    *H-&gt;stack_top = value;
    H-&gt;stack_top++;
}

static HymnValue peek(Hymn *H, int dist) {
    assert(&H-&gt;stack_top[-dist] &gt;= H-&gt;stack);
    return H-&gt;stack_top[-dist];
}

static HymnValue pop(Hymn *H) {
    assert(&H-&gt;stack_top[-1] &gt;= H-&gt;stack);
    H-&gt;stack_top--;
    return *H-&gt;stack_top;
}

static void push_string(Hymn *H, HymnString *string) {
    HymnObjectString *intern = hymn_intern_string(H, string);
    hymn_reference_string(intern);
    push(H, hymn_new_string_value(intern));
}

static HymnFrame *exception(Hymn *H) {
    HymnFrame *frame = current_frame(H);
    while (true) {
        HymnFunction *func = frame-&gt;func;
        uint8_t *instructions = func-&gt;code.instructions;
        HymnExceptList *except = NULL;
        HymnExceptList *range = func-&gt;except;
        while (range != NULL) {
            if (frame-&gt;ip &gt;= &instructions[range-&gt;start] && frame-&gt;ip &lt;= &instructions[range-&gt;end]) {
                except = range;
                break;
            }
            range = range-&gt;next;
        }
        HymnValue message = pop(H);
        if (except != NULL) {
            while (H-&gt;stack_top != &frame-&gt;stack[except-&gt;locals]) {
                hymn_dereference(H, pop(H));
            }
            frame-&gt;ip = &instructions[except-&gt;end];
            push(H, message);
            return frame;
        }
        while (H-&gt;stack_top != frame-&gt;stack) {
            hymn_dereference(H, pop(H));
        }
        H-&gt;frame_count--;
        if (H-&gt;frame_count == 0 || func-&gt;name == NULL) {
            assert(H-&gt;error == NULL);
            H-&gt;error = hymn_value_to_string(message);
            hymn_dereference(H, message);
            return NULL;
        }
        push(H, message);
        frame = current_frame(H);
    }
}

static HymnString *stacktrace(Hymn *H) {
    HymnString *trace = hymn_new_string(&quot;&quot;);
    for (int i = H-&gt;frame_count - 1; i &gt;= 0; i--) {
        HymnFrame *frame = &H-&gt;frames[i];
        HymnFunction *func = frame-&gt;func;
        int row = func-&gt;code.lines[frame-&gt;ip - func-&gt;code.instructions - 1];
        if (func-&gt;name == NULL) {
            if (func-&gt;script == NULL) {
                trace = string_append_format(trace, &quot;  at script:%d&quot;, row);
            } else {
                trace = string_append_format(trace, &quot;  at %s:%d&quot;, func-&gt;script, row);
            }
        } else if (func-&gt;script == NULL) {
            trace = string_append_format(trace, &quot;  at %s script:%d&quot;, func-&gt;name, row);
        } else {
            trace = string_append_format(trace, &quot;  at %s %s:%d&quot;, func-&gt;name, func-&gt;script, row);
        }
        if (i &gt; 0) trace = hymn_string_append_char(trace, '\n');
    }
    return trace;
}

static HymnFrame *push_error(Hymn *H, HymnString *error) {
    HymnObjectString *message = hymn_intern_string(H, error);
    hymn_reference_string(message);
    push(H, hymn_new_string_value(message));
    return exception(H);
}

static HymnFrame *throw_existing_error(Hymn *H, char *error) {
    HymnString *message = hymn_new_string(error);
    free(error);
    return push_error(H, message);
}

static HymnFrame *throw_error(Hymn *H, const char *format, ...) {
    va_list ap;
    va_start(ap, format);
    size_t len = (size_t)vsnprintf(NULL, 0, format, ap);
    va_end(ap);
    char *chars = hymn_malloc((len + 1) * sizeof(char));
    va_start(ap, format);
    len = (size_t)vsnprintf(chars, len + 1, format, ap);
    va_end(ap);

    HymnString *error = hymn_new_string_with_capacity(len + 128);
    error = hymn_string_append(error, chars);

    free(chars);

    HymnString *trace = stacktrace(H);
    error = hymn_string_append(error, &quot;\n&quot;);
    error = hymn_string_append(error, trace);
    hymn_string_delete(trace);

    return push_error(H, error);
}

static HymnFrame *throw_exception(Hymn *H, const char *name) {

    HymnString *trace = stacktrace(H);
    HymnString *error = hymn_new_string_with_capacity(hymn_string_len(H-&gt;exception) + hymn_string_len(trace) + 128);
    error = hymn_string_append(error, H-&gt;exception);

    hymn_string_delete(H-&gt;exception);
    H-&gt;exception = NULL;

    error = hymn_string_append(error, &quot;\n  in &quot;);
    error = hymn_string_append(error, name);
    HymnFrame *frame = &H-&gt;frames[H-&gt;frame_count - 1];
    HymnFunction *func = frame-&gt;func;
    int row = func-&gt;code.lines[frame-&gt;ip - func-&gt;code.instructions - 1];
    if (func-&gt;script == NULL) {
        error = string_append_format(error, &quot; script:%d\n&quot;, row);
    } else {
        error = string_append_format(error, &quot; %s:%d\n&quot;, func-&gt;script, row);
    }
    error = hymn_string_append(error, trace);
    hymn_string_delete(trace);

    return push_error(H, error);
}

static HymnFrame *throw_error_string(Hymn *H, HymnString *string) {
    HymnFrame *frame = throw_error(H, string);
    hymn_string_delete(string);
    return frame;
}

HymnValue hymn_new_exception(Hymn *H, const char *error) {
    H-&gt;exception = hymn_new_string(error);
    return hymn_new_none();
}

HymnValue hymn_arity_exception(Hymn *H, int expected, int actual) {
    H-&gt;exception = hymn_string_format(&quot;expected: %d function argument(s) but was: %d&quot;, expected, actual);
    return hymn_new_none();
}

HymnValue hymn_type_exception(Hymn *H, enum HymnValueType expected, enum HymnValueType actual) {
    H-&gt;exception = hymn_string_format(&quot;expected type: %s but was: %s&quot;, hymn_value_type(expected), hymn_value_type(actual));
    return hymn_new_none();
}

static HymnFrame *call(Hymn *H, HymnFunction *func, int count) {
    if (count != func-&gt;arity) {
        if (count &lt; func-&gt;arity) return throw_error(H, &quot;not enough arguments in call to '%s' (expected %d)&quot;, func-&gt;name, func-&gt;arity);
        return throw_error(H, &quot;too many arguments in call to '%s' (expected %d)&quot;, func-&gt;name, func-&gt;arity);
    } else if (H-&gt;frame_count == HYMN_FRAMES_MAX) {
        return throw_error(H, &quot;stack overflow&quot;);
    }

    HymnFrame *frame = &H-&gt;frames[H-&gt;frame_count++];
    frame-&gt;func = func;
    frame-&gt;ip = func-&gt;code.instructions;
    frame-&gt;stack = H-&gt;stack_top - count - 1;

    return frame;
}

static HymnFrame *call_value(Hymn *H, HymnValue value, int count) {
    switch (value.is) {
    case HYMN_VALUE_FUNC:
        return call(H, hymn_as_func(value), count);
    case HYMN_VALUE_FUNC_NATIVE: {
        HymnNativeFunction *native = hymn_as_native(value);
        HymnNativeCall func = native-&gt;func;
        HymnValue result = func(H, count, H-&gt;stack_top - count);
        HymnValue *top = H-&gt;stack_top - count - 1;
        while (H-&gt;stack_top != top) {
            hymn_dereference(H, pop(H));
        }
        if (H-&gt;exception != NULL) {
            return throw_exception(H, native-&gt;name-&gt;string);
        } else {
            hymn_reference(result);
            push(H, result);
            return current_frame(H);
        }
    }
    default: {
        const char *is = hymn_value_type(value.is);
        return throw_error(H, &quot;can't call %s (expected function)&quot;, is);
    }
    }
}

static HymnFrame *import(Hymn *H, HymnObjectString *file) {
    HymnTable *imports = H-&gt;imports;

    HymnString *script = NULL;
    int p = 1;
    while (true) {
        HymnFrame *frame = parent_frame(H, p);
        if (frame == NULL) break;
        script = frame-&gt;func-&gt;script;
        if (script) break;
        p++;
    }

    HymnString *look = hymn_path_convert(file-&gt;string);
    HymnString *parent = script ? hymn_path_parent(script) : NULL;

    HymnObjectString *module = NULL;

    HymnArray *paths = H-&gt;paths;
    HymnInt size = paths-&gt;length;
    for (HymnInt i = 0; i &lt; size; i++) {
        HymnValue value = paths-&gt;items[i];
        if (!hymn_is_string(value)) {
            continue;
        }
        HymnString *question = hymn_as_string(value);

        HymnString *replace = hymn_string_replace(question, &quot;&lt;path&gt;&quot;, look);
        HymnString *path = parent ? hymn_string_replace(replace, &quot;&lt;parent&gt;&quot;, parent) : hymn_string_copy(replace);

        HymnObjectString *use = hymn_intern_string(H, hymn_path_absolute(path));
        hymn_reference_string(use);

        hymn_string_delete(path);
        hymn_string_delete(replace);

        if (!hymn_is_undefined(table_get(imports, use))) {
            hymn_dereference_string(H, use);
            hymn_string_delete(look);
            if (parent) hymn_string_delete(parent);
            return current_frame(H);
        }

        if (hymn_file_exists(use-&gt;string)) {
            module = use;
            break;
        }

        hymn_dereference_string(H, use);
    }

    if (module == NULL) {
        HymnString *missing = hymn_string_format(&quot;import not found: %s&quot;, look);

        for (HymnInt i = 0; i &lt; size; i++) {
            HymnValue value = paths-&gt;items[i];
            if (!hymn_is_string(value)) {
                continue;
            }
            HymnString *question = hymn_as_string(value);

            HymnString *replace = hymn_string_replace(question, &quot;&lt;path&gt;&quot;, look);
            HymnString *path = parent ? hymn_string_replace(replace, &quot;&lt;parent&gt;&quot;, parent) : hymn_string_copy(replace);
            HymnString *use = hymn_path_absolute(path);

            missing = string_append_format(missing, &quot;\n  no file: %s&quot;, use);

            hymn_string_delete(path);
            hymn_string_delete(replace);
            hymn_string_delete(use);
        }

        hymn_string_delete(look);
        if (parent) hymn_string_delete(parent);

        return throw_error_string(H, missing);
    }

    hymn_string_delete(look);
    if (parent != NULL) {
        hymn_string_delete(parent);
    }

    table_put(imports, module, hymn_new_bool(true));

    HymnString *source = hymn_read_file(module-&gt;string);
    if (source == NULL) {
        HymnString *failed = hymn_string_format(&quot;error reading file: %s\n&quot;, module-&gt;string);
        return throw_error_string(H, failed);
    }

    CompileResult result = compile(H, module-&gt;string, source, TYPE_SCRIPT);

    hymn_string_delete(source);

    char *error = result.error;
    if (error != NULL) {
        return throw_existing_error(H, error);
    }

    HymnFunction *func = result.func;
    HymnValue function = hymn_new_func_value(func);
    hymn_reference(function);

    push(H, function);
    call(H, func, 0);

    error = interpret(H);
    if (error != NULL) {
        return throw_existing_error(H, error);
    }

    return current_frame(H);
}

static int debug_constant_instruction(HymnString **debug, const char *name, HymnByteCode *code, int index) {
    uint8_t constant = code-&gt;instructions[index + 1];
    HymnString *value = debug_value_to_string(code-&gt;constants.values[constant]);
    *debug = string_append_format(*debug, &quot;%s: [%d] [%s]&quot;, name, constant, value);
    hymn_string_delete(value);
    return index + 2;
}

static int debug_two_constant_instruction(HymnString **debug, const char *name, HymnByteCode *code, int index) {
    uint8_t constant = code-&gt;instructions[index + 1];
    HymnString *value = debug_value_to_string(code-&gt;constants.values[constant]);
    uint8_t constant2 = code-&gt;instructions[index + 2];
    HymnString *value2 = debug_value_to_string(code-&gt;constants.values[constant2]);
    *debug = string_append_format(*debug, &quot;%s: [%d] [%s] & [%d] [%s]&quot;, name, constant, value, constant2, value2);
    hymn_string_delete(value);
    hymn_string_delete(value2);
    return index + 3;
}

static int debug_byte_instruction(HymnString **debug, const char *name, HymnByteCode *code, int index) {
    uint8_t byte = code-&gt;instructions[index + 1];
    *debug = string_append_format(*debug, &quot;%s: [%d]&quot;, name, byte);
    return index + 2;
}

static int debug_jump_instruction(HymnString **debug, const char *name, int sign, HymnByteCode *code, int index) {
    int jump = ((int)code-&gt;instructions[index + 1] &lt;&lt; 8) | (int)code-&gt;instructions[index + 2];
    *debug = string_append_format(*debug, &quot;%s: [%zu] -&gt; [%zu]&quot;, name, index, sign &lt; 0 ? index + 3 - jump : index + 3 + jump);
    return index + 3;
}

static int debug_register_jump_instruction(HymnString **debug, const char *name, HymnByteCode *code, int index) {
    uint8_t slot_a = code-&gt;instructions[index + 1];
    uint8_t slot_b = code-&gt;instructions[index + 2];
    int jump = ((int)code-&gt;instructions[index + 3] &lt;&lt; 8) | (int)code-&gt;instructions[index + 4];
    *debug = string_append_format(*debug, &quot;%s: [%d] [%d] ? [%zu] -&gt; [%zu]&quot;, name, slot_a, slot_b, index, index + 5 + jump);
    return index + 5;
}

static int debug_three_byte_instruction(HymnString **debug, const char *name, HymnByteCode *code, int index) {
    uint8_t byte = code-&gt;instructions[index + 1];
    uint8_t next = code-&gt;instructions[index + 2];
    *debug = string_append_format(*debug, &quot;%s: [%d] [%d]&quot;, name, byte, next);
    return index + 3;
}

static int debug_for_loop_instruction(HymnString **debug, const char *name, int sign, HymnByteCode *code, int index) {
    uint8_t slot = code-&gt;instructions[index + 1];
    int jump = ((int)code-&gt;instructions[index + 2] &lt;&lt; 8) | (int)code-&gt;instructions[index + 3];
    *debug = string_append_format(*debug, &quot;%s: [%d] [%zu] -&gt; [%zu]&quot;, name, slot, index, sign &lt; 0 ? index + 4 - jump : index + 4 + jump);
    return index + 4;
}

static int debug_increment_loop_instruction(HymnString **debug, const char *name, HymnByteCode *code, int index) {
    uint8_t slot = code-&gt;instructions[index + 1];
    uint8_t increment = code-&gt;instructions[index + 2];
    int jump = ((int)code-&gt;instructions[index + 3] &lt;&lt; 8) | (int)code-&gt;instructions[index + 4];
    *debug = string_append_format(*debug, &quot;%s: [%d] [%d] & [%zu] -&gt; [%zu]&quot;, name, slot, increment, index, index + 5 - jump);
    return index + 5;
}

static int debug_instruction(HymnString **debug, const char *name, int index) {
    *debug = string_append_format(*debug, &quot;%s&quot;, name);
    return index + 1;
}

static int disassemble_instruction(HymnString **debug, HymnByteCode *code, int index) {
    *debug = string_append_format(*debug, &quot;%04zu &quot;, index);
    if (index &gt; 0 && code-&gt;lines[index] == code-&gt;lines[index - 1]) {
        *debug = hymn_string_append(*debug, &quot;   | &quot;);
    } else {
        *debug = string_append_format(*debug, &quot;%4d &quot;, code-&gt;lines[index]);
    }
    uint8_t instruction = code-&gt;instructions[index];
    switch (instruction) {
    case OP_ADD: return debug_instruction(debug, &quot;OP_ADD&quot;, index);
    case OP_ADD_LOCALS: return debug_three_byte_instruction(debug, &quot;OP_ADD_LOCALS&quot;, code, index);
    case OP_INSERT: return debug_instruction(debug, &quot;OP_INSERT&quot;, index);
    case OP_ARRAY_POP: return debug_instruction(debug, &quot;OP_ARRAY_POP&quot;, index);
    case OP_ARRAY_PUSH: return debug_instruction(debug, &quot;OP_ARRAY_PUSH&quot;, index);
    case OP_ARRAY_PUSH_LOCALS: return debug_three_byte_instruction(debug, &quot;OP_ARRAY_PUSH_LOCALS&quot;, code, index);
    case OP_BIT_AND: return debug_instruction(debug, &quot;OP_BIT_AND&quot;, index);
    case OP_BIT_LEFT_SHIFT: return debug_instruction(debug, &quot;OP_BIT_LEFT_SHIFT&quot;, index);
    case OP_BIT_NOT: return debug_instruction(debug, &quot;OP_BIT_NOT&quot;, index);
    case OP_BIT_OR: return debug_instruction(debug, &quot;OP_BIT_OR&quot;, index);
    case OP_BIT_RIGHT_SHIFT: return debug_instruction(debug, &quot;OP_BIT_RIGHT_SHIFT&quot;, index);
    case OP_BIT_XOR: return debug_instruction(debug, &quot;OP_BIT_XOR&quot;, index);
    case OP_CALL: return debug_byte_instruction(debug, &quot;OP_CALL&quot;, code, index);
    case OP_SELF: return debug_constant_instruction(debug, &quot;OP_SELF&quot;, code, index);
    case OP_CLEAR: return debug_instruction(debug, &quot;OP_CLEAR&quot;, index);
    case OP_CONSTANT: return debug_constant_instruction(debug, &quot;OP_CONSTANT&quot;, code, index);
    case OP_NEW_ARRAY: return debug_instruction(debug, &quot;OP_NEW_ARRAY&quot;, index);
    case OP_NEW_TABLE: return debug_instruction(debug, &quot;OP_NEW_TABLE&quot;, index);
    case OP_COPY: return debug_instruction(debug, &quot;OP_COPY&quot;, index);
    case OP_DEFINE_GLOBAL: return debug_constant_instruction(debug, &quot;OP_DEFINE_GLOBAL&quot;, code, index);
    case OP_DEBUG: return debug_instruction(debug, &quot;OP_DEBUG&quot;, index);
    case OP_DELETE: return debug_instruction(debug, &quot;OP_DELETE&quot;, index);
    case OP_DIVIDE: return debug_instruction(debug, &quot;OP_DIVIDE&quot;, index);
    case OP_DUPLICATE: return debug_instruction(debug, &quot;OP_DUPLICATE&quot;, index);
    case OP_EQUAL: return debug_instruction(debug, &quot;OP_EQUAL&quot;, index);
    case OP_ECHO: return debug_instruction(debug, &quot;OP_ECHO&quot;, index);
    case OP_EXISTS: return debug_instruction(debug, &quot;OP_EXISTS&quot;, index);
    case OP_FALSE: return debug_instruction(debug, &quot;OP_FALSE&quot;, index);
    case OP_FOR: return debug_for_loop_instruction(debug, &quot;OP_FOR&quot;, 1, code, index);
    case OP_FOR_LOOP: return debug_for_loop_instruction(debug, &quot;OP_FOR_LOOP&quot;, -1, code, index);
    case OP_GET_DYNAMIC: return debug_instruction(debug, &quot;OP_GET_DYNAMIC&quot;, index);
    case OP_GET_GLOBAL: return debug_constant_instruction(debug, &quot;OP_GET_GLOBAL&quot;, code, index);
    case OP_GET_GLOBAL_PROPERTY: return debug_two_constant_instruction(debug, &quot;OP_GET_GLOBAL_PROPERTY&quot;, code, index);
    case OP_GET_LOCAL: return debug_byte_instruction(debug, &quot;OP_GET_LOCAL&quot;, code, index);
    case OP_GET_PROPERTY: return debug_constant_instruction(debug, &quot;OP_GET_PROPERTY&quot;, code, index);
    case OP_GET_LOCALS: return debug_three_byte_instruction(debug, &quot;OP_GET_LOCALS&quot;, code, index);
    case OP_GREATER: return debug_instruction(debug, &quot;OP_GREATER&quot;, index);
    case OP_GREATER_EQUAL: return debug_instruction(debug, &quot;OP_GREATER_EQUAL&quot;, index);
    case OP_INCREMENT: return debug_byte_instruction(debug, &quot;OP_INCREMENT&quot;, code, index);
    case OP_INCREMENT_LOCAL: return debug_three_byte_instruction(debug, &quot;OP_INCREMENT_LOCAL&quot;, code, index);
    case OP_INCREMENT_LOCAL_AND_SET: return debug_three_byte_instruction(debug, &quot;OP_INCREMENT_LOCAL_AND_SET&quot;, code, index);
    case OP_INCREMENT_LOOP: return debug_increment_loop_instruction(debug, &quot;OP_INCREMENT_LOOP&quot;, code, index);
    case OP_INDEX: return debug_instruction(debug, &quot;OP_INDEX&quot;, index);
    case OP_INSPECT: return debug_instruction(debug, &quot;OP_INSPECT&quot;, index);
    case OP_JUMP: return debug_jump_instruction(debug, &quot;OP_JUMP&quot;, 1, code, index);
    case OP_JUMP_IF_EQUAL: return debug_jump_instruction(debug, &quot;OP_JUMP_IF_EQUAL&quot;, 1, code, index);
    case OP_JUMP_IF_FALSE: return debug_jump_instruction(debug, &quot;OP_JUMP_IF_FALSE&quot;, 1, code, index);
    case OP_JUMP_IF_GREATER: return debug_jump_instruction(debug, &quot;OP_JUMP_IF_GREATER&quot;, 1, code, index);
    case OP_JUMP_IF_GREATER_LOCALS: return debug_register_jump_instruction(debug, &quot;OP_JUMP_IF_GREATER_LOCALS&quot;, code, index);
    case OP_JUMP_IF_GREATER_EQUAL: return debug_jump_instruction(debug, &quot;OP_JUMP_IF_GREATER_EQUAL&quot;, 1, code, index);
    case OP_JUMP_IF_LESS: return debug_jump_instruction(debug, &quot;OP_JUMP_IF_LESS&quot;, 1, code, index);
    case OP_JUMP_IF_LESS_EQUAL: return debug_jump_instruction(debug, &quot;OP_JUMP_IF_LESS_EQUAL&quot;, 1, code, index);
    case OP_JUMP_IF_NOT_EQUAL: return debug_jump_instruction(debug, &quot;OP_JUMP_IF_NOT_EQUAL&quot;, 1, code, index);
    case OP_JUMP_IF_TRUE: return debug_jump_instruction(debug, &quot;OP_JUMP_IF_TRUE&quot;, 1, code, index);
    case OP_KEYS: return debug_instruction(debug, &quot;OP_KEYS&quot;, index);
    case OP_LEN: return debug_instruction(debug, &quot;OP_LEN&quot;, index);
    case OP_LESS: return debug_instruction(debug, &quot;OP_LESS&quot;, index);
    case OP_LESS_EQUAL: return debug_instruction(debug, &quot;OP_LESS_EQUAL&quot;, index);
    case OP_LOOP: return debug_jump_instruction(debug, &quot;OP_LOOP&quot;, -1, code, index);
    case OP_MODULO: return debug_instruction(debug, &quot;OP_MODULO&quot;, index);
    case OP_MODULO_LOCALS: return debug_three_byte_instruction(debug, &quot;OP_MODULO_LOCALS&quot;, code, index);
    case OP_MULTIPLY: return debug_instruction(debug, &quot;OP_MULTIPLY&quot;, index);
    case OP_NEGATE: return debug_instruction(debug, &quot;OP_NEGATE&quot;, index);
    case OP_NONE: return debug_instruction(debug, &quot;OP_NONE&quot;, index);
    case OP_NOT: return debug_instruction(debug, &quot;OP_NOT&quot;, index);
    case OP_NOT_EQUAL: return debug_instruction(debug, &quot;OP_NOT_EQUAL&quot;, index);
    case OP_POP: return debug_instruction(debug, &quot;OP_POP&quot;, index);
    case OP_POP_N: return debug_byte_instruction(debug, &quot;OP_POP_N&quot;, code, index);
    case OP_POP_TWO: return debug_instruction(debug, &quot;OP_POP_TWO&quot;, index);
    case OP_PRINT: return debug_instruction(debug, &quot;OP_PRINT&quot;, index);
    case OP_RETURN: return debug_instruction(debug, &quot;OP_RETURN&quot;, index);
    case OP_VOID: return debug_instruction(debug, &quot;OP_VOID&quot;, index);
    case OP_SET_DYNAMIC: return debug_instruction(debug, &quot;OP_SET_DYNAMIC&quot;, index);
    case OP_SET_GLOBAL: return debug_constant_instruction(debug, &quot;OP_SET_GLOBAL&quot;, code, index);
    case OP_SET_LOCAL: return debug_byte_instruction(debug, &quot;OP_SET_LOCAL&quot;, code, index);
    case OP_SET_PROPERTY: return debug_constant_instruction(debug, &quot;OP_SET_PROPERTY&quot;, code, index);
    case OP_SLICE: return debug_instruction(debug, &quot;OP_SLICE&quot;, index);
    case OP_SUBTRACT: return debug_instruction(debug, &quot;OP_SUBTRACT&quot;, index);
    case OP_TAIL_CALL: return debug_byte_instruction(debug, &quot;OP_TAIL_CALL&quot;, code, index);
    case OP_THROW: return debug_instruction(debug, &quot;OP_THROW&quot;, index);
    case OP_FLOAT: return debug_instruction(debug, &quot;OP_FLOAT&quot;, index);
    case OP_INT: return debug_instruction(debug, &quot;OP_INT&quot;, index);
    case OP_STRING: return debug_instruction(debug, &quot;OP_STRING&quot;, index);
    case OP_TRUE: return debug_instruction(debug, &quot;OP_TRUE&quot;, index);
    case OP_TYPE: return debug_instruction(debug, &quot;OP_TYPE&quot;, index);
    case OP_USE: return debug_instruction(debug, &quot;OP_USE&quot;, index);
    default: *debug = string_append_format(*debug, &quot;UNKNOWN_OPCODE %d\n&quot;, instruction); return index + 1;
    }
}

static HymnString *disassemble_byte_code(HymnByteCode *code) {
    HymnString *debug = hymn_new_string(&quot;&quot;);
    if (code-&gt;count &gt; 0) {
        int offset = disassemble_instruction(&debug, code, 0);
        while (offset &lt; code-&gt;count) {
            debug = hymn_string_append_char(debug, '\n');
            offset = disassemble_instruction(&debug, code, offset);
        }
    }
    return debug;
}

#define READ_BYTE(F) (*F-&gt;ip++)

#define READ_SHORT(F) (F-&gt;ip += 2, (((int)F-&gt;ip[-2] &lt;&lt; 8) | (int)F-&gt;ip[-1]))

#define GET_CONSTANT(F, B) (F-&gt;func-&gt;code.constants.values[B])

#define READ_CONSTANT(F) (GET_CONSTANT(F, READ_BYTE(F)))

#define THROW(...)                         \
    frame = throw_error(H, ##__VA_ARGS__); \
    if (frame == NULL) return;             \
    goto dispatch;

#define COMPARE_OP(compare)                                                                       \
    HymnValue b = pop(H);                                                                         \
    HymnValue a = pop(H);                                                                         \
    if (hymn_is_int(a)) {                                                                         \
        if (hymn_is_int(b)) {                                                                     \
            push(H, hymn_new_bool(hymn_as_int(a) compare hymn_as_int(b)));                        \
        } else if (hymn_is_float(b)) {                                                            \
            push(H, hymn_new_bool((HymnFloat)hymn_as_int(a) compare hymn_as_float(b)));           \
        } else {                                                                                  \
            const char *is_a = hymn_value_type(a.is);                                             \
            const char *is_b = hymn_value_type(b.is);                                             \
            hymn_dereference(H, a);                                                               \
            hymn_dereference(H, b);                                                               \
            THROW(&quot;comparison '&quot; #compare &quot;' can't use %s and %s (expected numbers)&quot;, is_a, is_b) \
        }                                                                                         \
    } else if (hymn_is_float(a)) {                                                                \
        if (hymn_is_int(b)) {                                                                     \
            push(H, hymn_new_bool(hymn_as_float(a) compare(HymnFloat) hymn_as_int(b)));           \
        } else if (hymn_is_float(b)) {                                                            \
            push(H, hymn_new_bool(hymn_as_float(a) compare hymn_as_float(b)));                    \
        } else {                                                                                  \
            const char *is_a = hymn_value_type(a.is);                                             \
            const char *is_b = hymn_value_type(b.is);                                             \
            hymn_dereference(H, a);                                                               \
            hymn_dereference(H, b);                                                               \
            THROW(&quot;comparison '&quot; #compare &quot;' can't use %s and %s (expected numbers)&quot;, is_a, is_b) \
        }                                                                                         \
    } else {                                                                                      \
        const char *is_a = hymn_value_type(a.is);                                                 \
        const char *is_b = hymn_value_type(b.is);                                                 \
        hymn_dereference(H, a);                                                                   \
        hymn_dereference(H, b);                                                                   \
        THROW(&quot;comparison '&quot; #compare &quot;' can't use %s and %s (expected numbers)&quot;, is_a, is_b)     \
    }

#define JUMP_COMPARE_OP(compare)                                         \
    HymnValue b = pop(H);                                                \
    HymnValue a = pop(H);                                                \
    bool answer;                                                         \
    if (hymn_is_int(a)) {                                                \
        if (hymn_is_int(b)) {                                            \
            answer = hymn_as_int(a) compare hymn_as_int(b);              \
        } else if (hymn_is_float(b)) {                                   \
            answer = (HymnFloat)hymn_as_int(a) compare hymn_as_float(b); \
        } else {                                                         \
            hymn_dereference(H, a);                                      \
            hymn_dereference(H, b);                                      \
            THROW(&quot;comparison: operands must be numbers&quot;)                \
        }                                                                \
    } else if (hymn_is_float(a)) {                                       \
        if (hymn_is_int(b)) {                                            \
            answer = hymn_as_float(a) compare(HymnFloat) hymn_as_int(b); \
        } else if (hymn_is_float(b)) {                                   \
            answer = hymn_as_float(a) compare hymn_as_float(b);          \
        } else {                                                         \
            hymn_dereference(H, a);                                      \
            hymn_dereference(H, b);                                      \
            THROW(&quot;comparison: operands must be numbers&quot;)                \
        }                                                                \
    } else {                                                             \
        hymn_dereference(H, a);                                          \
        hymn_dereference(H, b);                                          \
        THROW(&quot;comparison: operands must be numbers&quot;)                    \
    }                                                                    \
    int jump = READ_SHORT(frame);                                        \
    if (answer) {                                                        \
        frame-&gt;ip += jump;                                               \
    }

static void run(Hymn *H) {
    HymnFrame *frame = current_frame(H);

dispatch:
#ifdef HYMN_DEBUG_STACK
    if (H-&gt;stack_top != H-&gt;stack) {
        HymnString *debug = hymn_new_string(&quot;&quot;);
        for (HymnValue *i = H-&gt;stack; i != H-&gt;stack_top; i++) {
            debug = hymn_string_append_char(debug, '[');
            HymnString *stack_debug = debug_value_to_string(*i);
            debug = hymn_string_append(debug, stack_debug);
            hymn_string_delete(stack_debug);
            debug = hymn_string_append(debug, &quot;] &quot;);
        }
        printf(&quot;STACK   | %s\n&quot;, debug);
        hymn_string_delete(debug);
    }
#endif
#ifdef HYMN_DEBUG_TRACE
    {
        HymnString *debug = hymn_new_string(&quot;&quot;);
        disassemble_instruction(&debug, &frame-&gt;func-&gt;code, (int)(frame-&gt;ip - frame-&gt;func-&gt;code.instructions));
        printf(&quot;%s\n&quot;, debug);
        hymn_string_delete(debug);
    }
#endif
    switch (READ_BYTE(frame)) {
    case OP_VOID: {
        H-&gt;frame_count--;
        bool done = H-&gt;frame_count == 0 || frame-&gt;func-&gt;name == NULL;
        while (H-&gt;stack_top != frame-&gt;stack) {
            hymn_dereference(H, pop(H));
        }
        if (done) return;
        push(H, hymn_new_none());
        frame = current_frame(H);
        goto dispatch;
    }
    case OP_RETURN: {
        HymnValue result = pop(H);
        H-&gt;frame_count--;
        bool done = H-&gt;frame_count == 0 || frame-&gt;func-&gt;name == NULL;
        while (H-&gt;stack_top != frame-&gt;stack) {
            hymn_dereference(H, pop(H));
        }
        if (done) return;
        push(H, result);
        frame = current_frame(H);
        goto dispatch;
    }
    case OP_POP: {
        hymn_dereference(H, pop(H));
        goto dispatch;
    }
    case OP_POP_TWO: {
        hymn_dereference(H, pop(H));
        hymn_dereference(H, pop(H));
        goto dispatch;
    }
    case OP_POP_N: {
        int count = READ_BYTE(frame);
        while (count--) {
            hymn_dereference(H, pop(H));
        }
        goto dispatch;
    }
    case OP_TRUE: {
        push(H, hymn_new_bool(true));
        goto dispatch;
    }
    case OP_FALSE: {
        push(H, hymn_new_bool(false));
        goto dispatch;
    }
    case OP_NONE: {
        push(H, hymn_new_none());
        goto dispatch;
    }
    case OP_CALL: {
        int count = READ_BYTE(frame);
        HymnValue value = peek(H, count + 1);
        frame = call_value(H, value, count);
        if (frame == NULL) return;
        goto dispatch;
    }
    case OP_TAIL_CALL: {
        int count = READ_BYTE(frame);
        HymnValue value = peek(H, count + 1);
        if (!hymn_is_func(value)) {
            frame = call_value(H, value, count);
        } else {
            HymnFunction *func = hymn_as_func(value);
            if (count != func-&gt;arity) {
                if (count &lt; func-&gt;arity) frame = throw_error(H, &quot;not enough arguments in call to '%s' (expected %d)&quot;, func-&gt;name, func-&gt;arity);
                frame = throw_error(H, &quot;too many arguments in call to '%s' (expected %d)&quot;, func-&gt;name, func-&gt;arity);
                if (frame == NULL) return;
            } else {
                HymnValue *top = H-&gt;stack_top;
                HymnValue *start = top - count - 1;
                HymnValue *bottom = frame-&gt;stack;
                HymnValue *move = start;
                while (bottom != start) {
                    hymn_dereference(H, *bottom);
                    if (move != top) {
                        *bottom = *move;
                        move++;
                    }
                    bottom++;
                }
                while (move != top) {
                    *bottom = *move;
                    move++;
                    bottom++;
                }
                H-&gt;stack_top = start;
                frame-&gt;func = func;
                frame-&gt;ip = func-&gt;code.instructions;
            }
        }
        if (frame == NULL) return;
        goto dispatch;
    }
    case OP_SELF: {
        HymnValue table = peek(H, 1);
        if (!hymn_is_table(table)) {
            const char *is = hymn_value_type(table.is);
            THROW(&quot;can't get property of %s (expected table)&quot;, is)
        }
        HymnObjectString *name = hymn_as_hymn_string(READ_CONSTANT(frame));
        HymnValue fun = table_get(hymn_as_table(table), name);
        *(H-&gt;stack_top - 1) = fun;
        hymn_reference(fun);
        *H-&gt;stack_top = table;
        H-&gt;stack_top++;
        goto dispatch;
    }
    case OP_JUMP: {
        int jump = READ_SHORT(frame);
        frame-&gt;ip += jump;
        goto dispatch;
    }
    case OP_JUMP_IF_FALSE: {
        HymnValue a = pop(H);
        int jump = READ_SHORT(frame);
        if (hymn_value_false(a)) {
            frame-&gt;ip += jump;
        }
        hymn_dereference(H, a);
        goto dispatch;
    }
    case OP_JUMP_IF_TRUE: {
        HymnValue a = pop(H);
        int jump = READ_SHORT(frame);
        if (!hymn_value_false(a)) {
            frame-&gt;ip += jump;
        }
        hymn_dereference(H, a);
        goto dispatch;
    }
    case OP_JUMP_IF_EQUAL: {
        HymnValue b = pop(H);
        HymnValue a = pop(H);
        int jump = READ_SHORT(frame);
        if (hymn_values_equal(a, b)) {
            frame-&gt;ip += jump;
        }
        hymn_dereference(H, a);
        hymn_dereference(H, b);
        goto dispatch;
    }
    case OP_JUMP_IF_NOT_EQUAL: {
        HymnValue b = pop(H);
        HymnValue a = pop(H);
        int jump = READ_SHORT(frame);
        if (!hymn_values_equal(a, b)) {
            frame-&gt;ip += jump;
        }
        hymn_dereference(H, a);
        hymn_dereference(H, b);
        goto dispatch;
    }
    case OP_JUMP_IF_LESS: {
        JUMP_COMPARE_OP(&lt;)
        goto dispatch;
    }
    case OP_JUMP_IF_LESS_EQUAL: {
        JUMP_COMPARE_OP(&lt;=)
        goto dispatch;
    }
    case OP_JUMP_IF_GREATER: {
        JUMP_COMPARE_OP(&gt;)
        goto dispatch;
    }
    case OP_JUMP_IF_GREATER_LOCALS: {
        HymnValue a = frame-&gt;stack[READ_BYTE(frame)];
        HymnValue b = frame-&gt;stack[READ_BYTE(frame)];
        int jump = READ_SHORT(frame);
        bool answer;
        if (hymn_is_int(a)) {
            if (hymn_is_int(b)) {
                answer = hymn_as_int(a) &gt; hymn_as_int(b);
            } else if (hymn_is_float(b)) {
                answer = (HymnFloat)hymn_as_int(a) &gt; hymn_as_float(b);
            } else {
                THROW(&quot;comparison: operands must be numbers&quot;)
            }
        } else if (hymn_is_float(a)) {
            if (hymn_is_int(b)) {
                answer = hymn_as_float(a) &gt; (HymnFloat)hymn_as_int(b);
            } else if (hymn_is_float(b)) {
                answer = hymn_as_float(a) &gt; hymn_as_float(b);
            } else {
                THROW(&quot;comparison: operands must be numbers&quot;)
            }
        } else {
            THROW(&quot;comparison: operands must be numbers&quot;)
        }
        if (answer) {
            frame-&gt;ip += jump;
        }
        goto dispatch;
    }
    case OP_JUMP_IF_GREATER_EQUAL: {
        JUMP_COMPARE_OP(&gt;=)
        goto dispatch;
    }
    case OP_LOOP: {
        int jump = READ_SHORT(frame);
        frame-&gt;ip -= jump;
        goto dispatch;
    }
    case OP_INCREMENT_LOOP: {
        int slot = READ_BYTE(frame);
        int increment = READ_BYTE(frame);
        int jump = READ_SHORT(frame);
        HymnValue value = frame-&gt;stack[slot];
        if (hymn_is_int(value)) {
            value.as.i += (HymnInt)increment;
        } else if (hymn_is_float(value)) {
            value.as.f += (HymnFloat)increment;
        } else {
            const char *is = hymn_value_type(value.is);
            THROW(&quot;expected a number but was '%s'&quot;, is)
        }
        frame-&gt;stack[slot] = value;
        frame-&gt;ip -= jump;
        goto dispatch;
    }
    case OP_FOR: {
        int slot = READ_BYTE(frame);
        HymnValue object = frame-&gt;stack[slot];
        H-&gt;stack_top += 2;
        if (hymn_is_table(object)) {
            HymnTable *table = hymn_as_table(object);
            HymnTableItem *next = table_next(table, NULL);
            if (next == NULL) {
                frame-&gt;stack[slot + 1] = hymn_new_none();
                frame-&gt;stack[slot + 2] = hymn_new_none();
                int jump = READ_SHORT(frame);
                frame-&gt;ip += jump;
            } else {
                frame-&gt;stack[slot + 1] = hymn_new_string_value(next-&gt;key);
                frame-&gt;stack[slot + 2] = next-&gt;value;
                hymn_reference_string(next-&gt;key);
                hymn_reference(next-&gt;value);
                frame-&gt;ip += 2;
            }
        } else if (hymn_is_array(object)) {
            HymnArray *array = hymn_as_array(object);
            if (array-&gt;length == 0) {
                frame-&gt;stack[slot + 1] = hymn_new_none();
                frame-&gt;stack[slot + 2] = hymn_new_none();
                int jump = READ_SHORT(frame);
                frame-&gt;ip += jump;
            } else {
                HymnValue item = array-&gt;items[0];
                frame-&gt;stack[slot + 1] = hymn_new_int(0);
                frame-&gt;stack[slot + 2] = item;
                hymn_reference(item);
                frame-&gt;ip += 2;
            }
        } else {
            frame-&gt;stack[slot + 1] = hymn_new_none();
            frame-&gt;stack[slot + 2] = hymn_new_none();
            const char *is = hymn_value_type(object.is);
            THROW(&quot;can't iterate over %s (expected array or table)&quot;, is)
        }
        goto dispatch;
    }
    case OP_FOR_LOOP: {
        int slot = READ_BYTE(frame);
        HymnValue object = frame-&gt;stack[slot];
        int index = slot + 1;
        int value = slot + 2;
        if (hymn_is_table(object)) {
            HymnTable *table = hymn_as_table(object);
            HymnObjectString *key = hymn_as_hymn_string(frame-&gt;stack[index]);
            HymnTableItem *next = table_next(table, key);
            if (next == NULL) {
                frame-&gt;ip += 2;
            } else {
                hymn_dereference(H, frame-&gt;stack[index]);
                hymn_dereference(H, frame-&gt;stack[value]);
                frame-&gt;stack[index] = hymn_new_string_value(next-&gt;key);
                frame-&gt;stack[value] = next-&gt;value;
                hymn_reference_string(next-&gt;key);
                hymn_reference(next-&gt;value);
                int jump = READ_SHORT(frame);
                frame-&gt;ip -= jump;
            }
        } else {
            HymnArray *array = hymn_as_array(object);
            HymnInt key = hymn_as_int(frame-&gt;stack[index]) + 1;
            if (key &gt;= array-&gt;length) {
                frame-&gt;ip += 2;
            } else {
                hymn_dereference(H, frame-&gt;stack[value]);
                HymnValue item = array-&gt;items[key];
                frame-&gt;stack[index].as.i++;
                frame-&gt;stack[value] = item;
                hymn_reference(item);
                int jump = READ_SHORT(frame);
                frame-&gt;ip -= jump;
            }
        }
        goto dispatch;
    }
    case OP_EQUAL: {
        HymnValue b = pop(H);
        HymnValue a = pop(H);
        push(H, hymn_new_bool(hymn_values_equal(a, b)));
        hymn_dereference(H, a);
        hymn_dereference(H, b);
        goto dispatch;
    }
    case OP_NOT_EQUAL: {
        HymnValue b = pop(H);
        HymnValue a = pop(H);
        push(H, hymn_new_bool(!hymn_values_equal(a, b)));
        hymn_dereference(H, a);
        hymn_dereference(H, b);
        goto dispatch;
    }
    case OP_LESS: {
        COMPARE_OP(&lt;)
        goto dispatch;
    }
    case OP_LESS_EQUAL: {
        COMPARE_OP(&lt;=)
        goto dispatch;
    }
    case OP_GREATER: {
        COMPARE_OP(&gt;)
        goto dispatch;
    }
    case OP_GREATER_EQUAL: {
        COMPARE_OP(&gt;=)
        goto dispatch;
    }
    case OP_ADD: {
        HymnValue b = pop(H);
        HymnValue a = pop(H);
        if (hymn_is_none(a)) {
            if (hymn_is_string(b)) {
                push_string(H, value_concat(a, b));
            } else {
                goto bad_add;
            }
        } else if (hymn_is_bool(a)) {
            if (hymn_is_string(b)) {
                push_string(H, value_concat(a, b));
            } else {
                goto bad_add;
            }
        } else if (hymn_is_int(a)) {
            if (hymn_is_int(b)) {
                a.as.i += b.as.i;
                push(H, a);
            } else if (hymn_is_float(b)) {
                b.as.f += (HymnFloat)a.as.i;
                push(H, a);
            } else if (hymn_is_string(b)) {
                push_string(H, value_concat(a, b));
            } else {
                goto bad_add;
            }
        } else if (hymn_is_float(a)) {
            if (hymn_is_int(b)) {
                a.as.f += (HymnFloat)b.as.i;
                push(H, a);
            } else if (hymn_is_float(b)) {
                a.as.f += b.as.f;
                push(H, a);
            } else if (hymn_is_string(b)) {
                push_string(H, value_concat(a, b));
            } else {
                goto bad_add;
            }
        } else if (hymn_is_string(a)) {
            push_string(H, value_concat(a, b));
        } else {
            goto bad_add;
        }
        hymn_dereference(H, a);
        hymn_dereference(H, b);
        goto dispatch;
    bad_add:;
        const char *is_a = hymn_value_type(a.is);
        const char *is_b = hymn_value_type(b.is);
        hymn_dereference(H, a);
        hymn_dereference(H, b);
        THROW(&quot;can't add %s and %s&quot;, is_a, is_b)
    }
    case OP_ADD_LOCALS: {
        HymnValue a = frame-&gt;stack[READ_BYTE(frame)];
        HymnValue b = frame-&gt;stack[READ_BYTE(frame)];
        if (hymn_is_none(a)) {
            if (hymn_is_string(b)) {
                push_string(H, value_concat(a, b));
            } else {
                goto bad_add_two;
            }
        } else if (hymn_is_bool(a)) {
            if (hymn_is_string(b)) {
                push_string(H, value_concat(a, b));
            } else {
                goto bad_add_two;
            }
        } else if (hymn_is_int(a)) {
            if (hymn_is_int(b)) {
                a.as.i += b.as.i;
                push(H, a);
            } else if (hymn_is_float(b)) {
                b.as.f += (HymnFloat)a.as.i;
                push(H, a);
            } else if (hymn_is_string(b)) {
                push_string(H, value_concat(a, b));
            } else {
                goto bad_add_two;
            }
        } else if (hymn_is_float(a)) {
            if (hymn_is_int(b)) {
                a.as.f += (HymnFloat)b.as.i;
                push(H, a);
            } else if (hymn_is_float(b)) {
                a.as.f += b.as.f;
                push(H, a);
            } else if (hymn_is_string(b)) {
                push_string(H, value_concat(a, b));
            } else {
                goto bad_add_two;
            }
        } else if (hymn_is_string(a)) {
            push_string(H, value_concat(a, b));
        } else {
            goto bad_add_two;
        }
        goto dispatch;
    bad_add_two:;
        const char *is_a = hymn_value_type(a.is);
        const char *is_b = hymn_value_type(b.is);
        hymn_dereference(H, a);
        hymn_dereference(H, b);
        THROW(&quot;can't add %s and %s&quot;, is_a, is_b)
    }
    case OP_INCREMENT: {
        HymnValue a = pop(H);
        HymnInt increment = READ_BYTE(frame);
        if (hymn_is_none(a)) {
            goto bad_increment;
        } else if (hymn_is_bool(a)) {
            goto bad_increment;
        } else if (hymn_is_int(a)) {
            a.as.i += increment;
            push(H, a);
        } else if (hymn_is_float(a)) {
            a.as.f += (HymnFloat)increment;
            push(H, a);
        } else if (hymn_is_string(a)) {
            push_string(H, value_concat(a, hymn_new_int(increment)));
        } else {
            goto bad_increment;
        }
        hymn_dereference(H, a);
        goto dispatch;
    bad_increment:;
        const char *is = hymn_value_type(a.is);
        hymn_dereference(H, a);
        THROW(&quot;can't increment %s&quot;, is)
    }
    case OP_SUBTRACT: {
        HymnValue b = pop(H);
        HymnValue a = pop(H);
        if (hymn_is_int(a)) {
            if (hymn_is_int(b)) {
                a.as.i -= b.as.i;
                push(H, a);
            } else if (hymn_is_float(b)) {
                HymnValue new = hymn_new_float((HymnFloat)a.as.i);
                new.as.f -= b.as.f;
                push(H, new);
            } else {
                goto bad_subtract;
            }
        } else if (hymn_is_float(a)) {
            if (hymn_is_int(b)) {
                a.as.f -= (HymnFloat)b.as.i;
                push(H, a);
            } else if (hymn_is_float(b)) {
                a.as.f -= b.as.f;
                push(H, a);
            } else {
                goto bad_subtract;
            }
        } else {
            goto bad_subtract;
        }
        goto dispatch;
    bad_subtract:;
        const char *is_a = hymn_value_type(a.is);
        const char *is_b = hymn_value_type(b.is);
        hymn_dereference(H, a);
        hymn_dereference(H, b);
        THROW(&quot;can't subtract %s and %s (expected numbers)&quot;, is_a, is_b)
    }
    case OP_MULTIPLY: {
        HymnValue b = pop(H);
        HymnValue a = pop(H);
        if (hymn_is_int(a)) {
            if (hymn_is_int(b)) {
                a.as.i *= b.as.i;
                push(H, a);
            } else if (hymn_is_float(b)) {
                HymnValue new = hymn_new_float((HymnFloat)a.as.i);
                new.as.f *= b.as.f;
                push(H, new);
            } else {
                goto bad_multiply;
            }
        } else if (hymn_is_float(a)) {
            if (hymn_is_int(b)) {
                a.as.f *= (HymnFloat)b.as.i;
                push(H, a);
            } else if (hymn_is_float(b)) {
                a.as.f *= b.as.f;
                push(H, a);
            } else {
                goto bad_multiply;
            }
        } else {
            goto bad_multiply;
        }
        goto dispatch;
    bad_multiply:;
        const char *is_a = hymn_value_type(a.is);
        const char *is_b = hymn_value_type(b.is);
        hymn_dereference(H, a);
        hymn_dereference(H, b);
        THROW(&quot;can't multiply %s and %s (expected numbers)&quot;, is_a, is_b)
    }
    case OP_DIVIDE: {
        HymnValue b = pop(H);
        HymnValue a = pop(H);
        if (hymn_is_int(a)) {
            if (hymn_is_int(b)) {
                a.as.i /= b.as.i;
                push(H, a);
            } else if (hymn_is_float(b)) {
                HymnValue new = hymn_new_float((HymnFloat)a.as.i);
                new.as.f /= b.as.f;
                push(H, new);
            } else {
                goto bad_divide;
            }
        } else if (hymn_is_float(a)) {
            if (hymn_is_int(b)) {
                a.as.f /= (HymnFloat)b.as.i;
                push(H, a);
            } else if (hymn_is_float(b)) {
                a.as.f /= b.as.f;
                push(H, a);
            } else {
                goto bad_divide;
            }
        } else {
            goto bad_divide;
        }
        goto dispatch;
    bad_divide:;
        const char *is_a = hymn_value_type(a.is);
        const char *is_b = hymn_value_type(b.is);
        hymn_dereference(H, a);
        hymn_dereference(H, b);
        THROW(&quot;can't divide %s and %s (expected numbers)&quot;, is_a, is_b)
    }
    case OP_MODULO: {
        HymnValue b = pop(H);
        HymnValue a = pop(H);
        if (hymn_is_int(a)) {
            if (hymn_is_int(b)) {
                a.as.i %= b.as.i;
                push(H, a);
            } else {
                goto bad_modulo;
            }
        } else {
            goto bad_modulo;
        }
        goto dispatch;
    bad_modulo:;
        const char *is_a = hymn_value_type(a.is);
        const char *is_b = hymn_value_type(b.is);
        hymn_dereference(H, a);
        hymn_dereference(H, b);
        THROW(&quot;can't modulo %s and %s (expected integers)&quot;, is_a, is_b)
    }
    case OP_MODULO_LOCALS: {
        HymnValue a = frame-&gt;stack[READ_BYTE(frame)];
        HymnValue b = frame-&gt;stack[READ_BYTE(frame)];
        if (hymn_is_int(a)) {
            if (hymn_is_int(b)) {
                a.as.i %= b.as.i;
                push(H, a);
            } else {
                goto bad_modulo_locals;
            }
        } else {
            goto bad_modulo_locals;
        }
        goto dispatch;
    bad_modulo_locals:;
        const char *is_a = hymn_value_type(a.is);
        const char *is_b = hymn_value_type(b.is);
        THROW(&quot;can't modulo %s and %s (expected integers)&quot;, is_a, is_b)
    }
    case OP_BIT_NOT: {
        HymnValue value = pop(H);
        if (hymn_is_int(value)) {
            value.as.i = ~value.as.i;
            push(H, value);
        } else {
            const char *is = hymn_value_type(value.is);
            hymn_dereference(H, value);
            THROW(&quot;bitwise '~' can't use %s (expected integer)&quot;, is)
        }
        goto dispatch;
    }
    case OP_BIT_OR: {
        HymnValue b = pop(H);
        HymnValue a = pop(H);
        if (hymn_is_int(a) && hymn_is_int(b)) {
            a.as.i |= b.as.i;
            push(H, a);
        } else {
            const char *is_a = hymn_value_type(a.is);
            const char *is_b = hymn_value_type(b.is);
            hymn_dereference(H, a);
            hymn_dereference(H, b);
            THROW(&quot;bitwise '|' can't use %s and %s (expected integers)&quot;, is_a, is_b)
        }
        goto dispatch;
    }
    case OP_BIT_AND: {
        HymnValue b = pop(H);
        HymnValue a = pop(H);
        if (hymn_is_int(a) && hymn_is_int(b)) {
            a.as.i &= b.as.i;
            push(H, a);
        } else {
            const char *is_a = hymn_value_type(a.is);
            const char *is_b = hymn_value_type(b.is);
            hymn_dereference(H, a);
            hymn_dereference(H, b);
            THROW(&quot;bitwise '&' can't use %s and %s (expected integers)&quot;, is_a, is_b)
        }
        goto dispatch;
    }
    case OP_BIT_XOR: {
        HymnValue b = pop(H);
        HymnValue a = pop(H);
        if (hymn_is_int(a) && hymn_is_int(b)) {
            a.as.i ^= b.as.i;
            push(H, a);
        } else {
            const char *is_a = hymn_value_type(a.is);
            const char *is_b = hymn_value_type(b.is);
            hymn_dereference(H, a);
            hymn_dereference(H, b);
            THROW(&quot;bitwise '^' can't use %s and %s (expected integers)&quot;, is_a, is_b)
        }
        goto dispatch;
    }
    case OP_BIT_LEFT_SHIFT: {
        HymnValue b = pop(H);
        HymnValue a = pop(H);
        if (hymn_is_int(a) && hymn_is_int(b)) {
            a.as.i &lt;&lt;= b.as.i;
            push(H, a);
        } else {
            const char *is_a = hymn_value_type(a.is);
            const char *is_b = hymn_value_type(b.is);
            hymn_dereference(H, a);
            hymn_dereference(H, b);
            THROW(&quot;bitwise '&lt;&lt;' can't use %s and %s (expected integers)&quot;, is_a, is_b)
        }
        goto dispatch;
    }
    case OP_BIT_RIGHT_SHIFT: {
        HymnValue b = pop(H);
        HymnValue a = pop(H);
        if (hymn_is_int(a) && hymn_is_int(b)) {
            a.as.i &gt;&gt;= b.as.i;
            push(H, a);
        } else {
            const char *is_a = hymn_value_type(a.is);
            const char *is_b = hymn_value_type(b.is);
            hymn_dereference(H, a);
            hymn_dereference(H, b);
            THROW(&quot;bitwise '&gt;&gt;' can't use %s and %s (expected integers)&quot;, is_a, is_b)
        }
        goto dispatch;
    }
    case OP_NEGATE: {
        HymnValue value = pop(H);
        if (hymn_is_int(value)) {
            value.as.i = -value.as.i;
        } else if (hymn_is_float(value)) {
            value.as.f = -value.as.f;
        } else {
            const char *is = hymn_value_type(value.is);
            hymn_dereference(H, value);
            THROW(&quot;negation '-' can't use %s (expected number)&quot;, is)
        }
        push(H, value);
        goto dispatch;
    }
    case OP_NOT: {
        HymnValue value = pop(H);
        if (hymn_is_bool(value)) {
            value.as.b = !value.as.b;
        } else {
            const char *is = hymn_value_type(value.is);
            hymn_dereference(H, value);
            THROW(&quot;not '!' can't use %s (expected boolean)&quot;, is)
        }
        push(H, value);
        goto dispatch;
    }
    case OP_CONSTANT: {
        HymnValue constant = READ_CONSTANT(frame);
        hymn_reference(constant);
        push(H, constant);
        goto dispatch;
    }
    case OP_NEW_ARRAY: {
        HymnValue constant = hymn_new_array_value(hymn_new_array(0));
        hymn_reference(constant);
        push(H, constant);
        goto dispatch;
    }
    case OP_NEW_TABLE: {
        HymnValue constant = hymn_new_table_value(hymn_new_table());
        hymn_reference(constant);
        push(H, constant);
        goto dispatch;
    }
    case OP_DEFINE_GLOBAL: {
        HymnObjectString *name = hymn_as_hymn_string(READ_CONSTANT(frame));
        HymnValue value = pop(H);
        HymnValue previous = table_put(&H-&gt;globals, name, value);
        if (hymn_is_undefined(previous)) {
            hymn_reference_string(name);
        } else {
            table_put(&H-&gt;globals, name, previous);
            hymn_dereference(H, value);
            THROW(&quot;multiple global definitions of '%s'&quot;, name-&gt;string)
        }
        goto dispatch;
    }
    case OP_SET_GLOBAL: {
        HymnObjectString *name = hymn_as_hymn_string(READ_CONSTANT(frame));
        HymnValue value = peek(H, 1);
        HymnValue previous = table_put(&H-&gt;globals, name, value);
        if (hymn_is_undefined(previous)) {
            hymn_reference_string(name);
        } else {
            hymn_dereference(H, previous);
        }
        hymn_reference(value);
        goto dispatch;
    }
    case OP_GET_GLOBAL: {
        HymnObjectString *name = hymn_as_hymn_string(READ_CONSTANT(frame));
        HymnValue get = table_get(&H-&gt;globals, name);
        if (hymn_is_undefined(get)) {
            THROW(&quot;undefined global '%s'&quot;, name-&gt;string)
        }
        hymn_reference(get);
        push(H, get);
        goto dispatch;
    }
    case OP_GET_GLOBAL_PROPERTY: {
        HymnObjectString *name = hymn_as_hymn_string(READ_CONSTANT(frame));
        HymnObjectString *property = hymn_as_hymn_string(READ_CONSTANT(frame));
        HymnValue global = table_get(&H-&gt;globals, name);
        if (hymn_is_undefined(global)) {
            THROW(&quot;undefined global '%s'&quot;, name-&gt;string)
        } else if (!hymn_is_table(global)) {
            const char *is = hymn_value_type(global.is);
            THROW(&quot;can't get property of %s (expected table)&quot;, is)
        }
        HymnTable *table = hymn_as_table(global);
        HymnValue get = table_get(table, property);
        if (hymn_is_undefined(get)) {
            get.is = HYMN_VALUE_NONE;
        } else {
            hymn_reference(get);
        }
        push(H, get);
        goto dispatch;
    }
    case OP_SET_LOCAL: {
        int slot = READ_BYTE(frame);
        HymnValue value = peek(H, 1);
        hymn_dereference(H, frame-&gt;stack[slot]);
        frame-&gt;stack[slot] = value;
        hymn_reference(value);
        goto dispatch;
    }
    case OP_GET_LOCAL: {
        int slot = READ_BYTE(frame);
        HymnValue value = frame-&gt;stack[slot];
        hymn_reference(value);
        push(H, value);
        goto dispatch;
    }
    case OP_GET_LOCALS: {
        int slot_a = READ_BYTE(frame);
        int slot_b = READ_BYTE(frame);
        HymnValue value_a = frame-&gt;stack[slot_a];
        HymnValue value_b = frame-&gt;stack[slot_b];
        hymn_reference(value_a);
        hymn_reference(value_b);
        push(H, value_a);
        push(H, value_b);
        goto dispatch;
    }
    case OP_INCREMENT_LOCAL: {
        int slot = READ_BYTE(frame);
        int increment = READ_BYTE(frame);
        HymnValue value = frame-&gt;stack[slot];
        if (hymn_is_int(value)) {
            value.as.i += (HymnInt)increment;
        } else if (hymn_is_float(value)) {
            value.as.f += (HymnFloat)increment;
        } else {
            const char *is = hymn_value_type(value.is);
            THROW(&quot;can't increment %s (expected number)&quot;, is)
        }
        push(H, value);
        goto dispatch;
    }
    case OP_INCREMENT_LOCAL_AND_SET: {
        int slot = READ_BYTE(frame);
        int increment = READ_BYTE(frame);
        HymnValue value = frame-&gt;stack[slot];
        if (hymn_is_int(value)) {
            value.as.i += (HymnInt)increment;
        } else if (hymn_is_float(value)) {
            value.as.f += (HymnFloat)increment;
        } else {
            const char *is = hymn_value_type(value.is);
            THROW(&quot;can't increment %s (expected number)&quot;, is)
        }
        frame-&gt;stack[slot] = value;
        goto dispatch;
    }
    case OP_SET_PROPERTY: {
        HymnValue value = pop(H);
        HymnValue table_value = pop(H);
        if (!hymn_is_table(table_value)) {
            const char *is = hymn_value_type(table_value.is);
            hymn_dereference(H, value);
            hymn_dereference(H, table_value);
            THROW(&quot;can't set property of %s (expected table)&quot;, is)
        }
        HymnTable *table = hymn_as_table(table_value);
        HymnObjectString *name = hymn_as_hymn_string(READ_CONSTANT(frame));
        hymn_set_property(H, table, name, value);
        push(H, value);
        hymn_dereference(H, table_value);
        goto dispatch;
    }
    case OP_GET_PROPERTY: {
        HymnValue value = pop(H);
        if (!hymn_is_table(value)) {
            const char *is = hymn_value_type(value.is);
            hymn_dereference(H, value);
            THROW(&quot;can't get property of %s (expected table)&quot;, is)
        }
        HymnTable *table = hymn_as_table(value);
        HymnObjectString *name = hymn_as_hymn_string(READ_CONSTANT(frame));
        HymnValue get = table_get(table, name);
        if (hymn_is_undefined(get)) {
            get.is = HYMN_VALUE_NONE;
        } else {
            hymn_reference(get);
        }
        hymn_dereference(H, value);
        push(H, get);
        goto dispatch;
    }
    case OP_EXISTS: {
        HymnValue value = pop(H);
        HymnValue object = pop(H);
        if (!hymn_is_table(object)) {
            const char *is = hymn_value_type(object.is);
            hymn_dereference(H, value);
            hymn_dereference(H, object);
            THROW(&quot;call to 'exists' can't use %s for 1st argument (expected table)&quot;, is)
        }
        if (!hymn_is_string(value)) {
            const char *is = hymn_value_type(value.is);
            hymn_dereference(H, value);
            hymn_dereference(H, object);
            THROW(&quot;call to 'exists' can't use %s for 2nd argument (expected string)&quot;, is)
        }
        HymnTable *table = hymn_as_table(object);
        HymnObjectString *name = hymn_as_hymn_string(value);
        HymnValue g = table_get(table, name);
        if (hymn_is_undefined(g)) {
            push(H, hymn_new_bool(false));
        } else {
            push(H, hymn_new_bool(true));
        }
        hymn_dereference(H, value);
        hymn_dereference(H, object);
        goto dispatch;
    }
    case OP_SET_DYNAMIC: {
        HymnValue value = pop(H);
        HymnValue property = pop(H);
        HymnValue object = pop(H);
        if (hymn_is_array(object)) {
            if (!hymn_is_int(property)) {
                const char *is = hymn_value_type(property.is);
                hymn_dereference(H, value);
                hymn_dereference(H, property);
                hymn_dereference(H, object);
                THROW(&quot;array assignment index can't be %s (expected integer)&quot;, is)
            }
            HymnArray *array = hymn_as_array(object);
            HymnInt size = array-&gt;length;
            HymnInt index = hymn_as_int(property);
            if (index &gt; size) {
                hymn_dereference(H, value);
                hymn_dereference(H, property);
                hymn_dereference(H, object);
                THROW(&quot;array assignment index out of bounds: %d &gt; %d&quot;, index, size)
            }
            if (index &lt; 0) {
                index = size + index;
                if (index &lt; 0) {
                    hymn_dereference(H, value);
                    hymn_dereference(H, property);
                    hymn_dereference(H, object);
                    THROW(&quot;negative array assignment index: %d&quot;, index)
                }
            }
            if (index == size) {
                hymn_array_push(array, value);
            } else {
                hymn_dereference(H, array-&gt;items[index]);
                array-&gt;items[index] = value;
            }
        } else if (hymn_is_table(object)) {
            if (!hymn_is_string(property)) {
                const char *is = hymn_value_type(property.is);
                hymn_dereference(H, value);
                hymn_dereference(H, property);
                hymn_dereference(H, object);
                THROW(&quot;table assignment key can't be %s (expected string)&quot;, is)
            }
            HymnTable *table = hymn_as_table(object);
            HymnObjectString *name = hymn_as_hymn_string(property);
            HymnValue previous = table_put(table, name, value);
            if (hymn_is_undefined(previous)) {
                hymn_reference_string(name);
            } else {
                hymn_dereference(H, previous);
            }
        } else {
            const char *is = hymn_value_type(object.is);
            hymn_dereference(H, value);
            hymn_dereference(H, property);
            hymn_dereference(H, object);
            THROW(&quot;can't assign value to %s (expected array or table)&quot;, is)
        }
        push(H, value);
        hymn_dereference(H, object);
        hymn_reference(value);
        goto dispatch;
    }
    case OP_GET_DYNAMIC: {
        HymnValue i = pop(H);
        HymnValue v = pop(H);
        switch (v.is) {
        case HYMN_VALUE_STRING: {
            if (!hymn_is_int(i)) {
                const char *is = hymn_value_type(i.is);
                hymn_dereference(H, i);
                hymn_dereference(H, v);
                THROW(&quot;string index can't be %s (expected integer)&quot;, is)
            }
            HymnString *string = hymn_as_string(v);
            HymnInt size = (HymnInt)hymn_string_len(string);
            HymnInt index = hymn_as_int(i);
            if (index &gt;= size) {
                hymn_dereference(H, i);
                hymn_dereference(H, v);
                THROW(&quot;string index out of bounds: %d &gt;= %d&quot;, index, size)
            }
            if (index &lt; 0) {
                index = size + index;
                if (index &lt; 0) {
                    hymn_dereference(H, i);
                    hymn_dereference(H, v);
                    THROW(&quot;negative string index: %d&quot;, index)
                }
            }
            char c = string[index];
            push_string(H, char_to_string(c));
            hymn_dereference(H, v);
            break;
        }
        case HYMN_VALUE_ARRAY: {
            if (!hymn_is_int(i)) {
                const char *is = hymn_value_type(i.is);
                hymn_dereference(H, i);
                hymn_dereference(H, v);
                THROW(&quot;array index can't be %s (expected integer)&quot;, is)
            }
            HymnArray *array = hymn_as_array(v);
            HymnInt size = array-&gt;length;
            HymnInt index = hymn_as_int(i);
            if (index &gt;= size) {
                hymn_dereference(H, i);
                hymn_dereference(H, v);
                THROW(&quot;array index out of bounds: %d &gt;= %d&quot;, index, size)
            }
            if (index &lt; 0) {
                index = size + index;
                if (index &lt; 0) {
                    hymn_dereference(H, i);
                    hymn_dereference(H, v);
                    THROW(&quot;negative array index: %d&quot;, index)
                }
            }
            HymnValue g = hymn_array_get(array, index);
            hymn_reference(g);
            push(H, g);
            hymn_dereference(H, v);
            break;
        }
        case HYMN_VALUE_TABLE: {
            if (!hymn_is_string(i)) {
                const char *is = hymn_value_type(i.is);
                hymn_dereference(H, i);
                hymn_dereference(H, v);
                THROW(&quot;table key can't be %s (expected string)&quot;, is)
            }
            HymnTable *table = hymn_as_table(v);
            HymnObjectString *name = hymn_as_hymn_string(i);
            HymnValue g = table_get(table, name);
            if (hymn_is_undefined(g)) {
                g.is = HYMN_VALUE_NONE;
            } else {
                hymn_reference(g);
            }
            push(H, g);
            hymn_dereference(H, i);
            hymn_dereference(H, v);
            break;
        }
        default: {
            const char *is = hymn_value_type(v.is);
            hymn_dereference(H, i);
            hymn_dereference(H, v);
            THROW(&quot;can't get value from %s (expected array, table, or string)&quot;, is)
        }
        }
        goto dispatch;
    }
    case OP_LEN: {
        HymnValue value = pop(H);
        switch (value.is) {
        case HYMN_VALUE_STRING: {
            HymnInt len = (HymnInt)hymn_string_len(hymn_as_string(value));
            push(H, hymn_new_int(len));
            break;
        }
        case HYMN_VALUE_ARRAY: {
            HymnInt len = hymn_as_array(value)-&gt;length;
            push(H, hymn_new_int(len));
            break;
        }
        case HYMN_VALUE_TABLE: {
            HymnInt len = (HymnInt)hymn_as_table(value)-&gt;size;
            push(H, hymn_new_int(len));
            break;
        }
        default: {
            const char *is = hymn_value_type(value.is);
            hymn_dereference(H, value);
            THROW(&quot;call to 'len' can't use %s (expected array, string, or table)&quot;, is)
        }
        }
        hymn_dereference(H, value);
        goto dispatch;
    }
    case OP_ARRAY_POP: {
        HymnValue a = pop(H);
        if (!hymn_is_array(a)) {
            const char *is = hymn_value_type(a.is);
            hymn_dereference(H, a);
            THROW(&quot;call to 'pop' can't use %s (expected array)&quot;, is)
        } else {
            HymnValue value = hymn_array_pop(hymn_as_array(a));
            push(H, value);
            hymn_dereference(H, a);
        }
        goto dispatch;
    }
    case OP_ARRAY_PUSH: {
        HymnValue value = pop(H);
        HymnValue array = pop(H);
        if (!hymn_is_array(array)) {
            const char *is = hymn_value_type(array.is);
            hymn_dereference(H, array);
            hymn_dereference(H, value);
            THROW(&quot;call to 'push' can't use %s for 1st argument (expected array)&quot;, is)
        } else {
            hymn_array_push(hymn_as_array(array), value);
            hymn_dereference(H, array);
        }
        goto dispatch;
    }
    case OP_ARRAY_PUSH_LOCALS: {
        HymnValue array = frame-&gt;stack[READ_BYTE(frame)];
        if (!hymn_is_array(array)) {
            const char *is = hymn_value_type(array.is);
            THROW(&quot;call to 'push' can't use %s for 1st argument (expected array)&quot;, is)
        } else {
            HymnValue value = frame-&gt;stack[READ_BYTE(frame)];
            hymn_array_push(hymn_as_array(array), value);
        }
        goto dispatch;
    }
    case OP_INSERT: {
        HymnValue p = pop(H);
        HymnValue i = pop(H);
        HymnValue v = pop(H);
        if (hymn_is_array(v)) {
            if (!hymn_is_int(i)) {
                const char *is = hymn_value_type(i.is);
                hymn_dereference(H, p);
                hymn_dereference(H, i);
                hymn_dereference(H, v);
                THROW(&quot;call to 'insert' can't use %s for 2nd argument (expected integer)&quot;, is)
            }
            HymnArray *array = hymn_as_array(v);
            HymnInt size = array-&gt;length;
            HymnInt index = hymn_as_int(i);
            if (index &gt; size) {
                hymn_dereference(H, p);
                hymn_dereference(H, i);
                hymn_dereference(H, v);
                THROW(&quot;index out of bounds in call to 'insert': %d &gt; %d&quot;, index, size)
            }
            if (index &lt; 0) {
                index = size + index;
                if (index &lt; 0) {
                    hymn_dereference(H, p);
                    hymn_dereference(H, i);
                    hymn_dereference(H, v);
                    THROW(&quot;negative index in 'insert' call: %d&quot;, index)
                }
            }
            if (index == size) {
                hymn_array_push(array, p);
            } else {
                hymn_array_insert(array, index, p);
            }
            hymn_dereference(H, v);
        } else {
            const char *is = hymn_value_type(v.is);
            hymn_dereference(H, p);
            hymn_dereference(H, i);
            hymn_dereference(H, v);
            THROW(&quot;call to 'insert' can't use %s for 1st argument (expected array)&quot;, is)
        }
        goto dispatch;
    }
    case OP_DELETE: {
        HymnValue i = pop(H);
        HymnValue v = pop(H);
        if (hymn_is_array(v)) {
            if (!hymn_is_int(i)) {
                const char *is = hymn_value_type(i.is);
                hymn_dereference(H, i);
                hymn_dereference(H, v);
                THROW(&quot;call to 'delete' can't use %s for 2nd argument (expected integer)&quot;, is)
            }
            HymnArray *array = hymn_as_array(v);
            HymnInt size = array-&gt;length;
            HymnInt index = hymn_as_int(i);
            if (index &gt;= size) {
                hymn_dereference(H, i);
                hymn_dereference(H, v);
                THROW(&quot;index out of bounds in call to 'delete': %d &gt;= %d.&quot;, index, size)
            }
            if (index &lt; 0) {
                index = size + index;
                if (index &lt; 0) {
                    hymn_dereference(H, i);
                    hymn_dereference(H, v);
                    THROW(&quot;negative index in 'delete' call: %d&quot;, index)
                }
            }
            HymnValue value = hymn_array_remove_index(array, index);
            push(H, value);
            hymn_dereference(H, v);
        } else if (hymn_is_table(v)) {
            if (!hymn_is_string(i)) {
                const char *is = hymn_value_type(i.is);
                hymn_dereference(H, i);
                hymn_dereference(H, v);
                THROW(&quot;call to 'delete' can't use %s for 2nd argument (expected string)&quot;, is)
            }
            HymnTable *table = hymn_as_table(v);
            HymnObjectString *name = hymn_as_hymn_string(i);
            HymnValue value = table_remove(table, name);
            if (hymn_is_undefined(value)) {
                value.is = HYMN_VALUE_NONE;
            } else {
                hymn_dereference_string(H, name);
            }
            push(H, value);
            hymn_dereference(H, v);
            hymn_dereference_string(H, name);
        } else {
            const char *is = hymn_value_type(v.is);
            hymn_dereference(H, i);
            hymn_dereference(H, v);
            THROW(&quot;call to 'delete' can't use %s for 1st argument (expected array or table)&quot;, is)
        }
        goto dispatch;
    }
    case OP_COPY: {
        HymnValue value = pop(H);
        switch (value.is) {
        case HYMN_VALUE_NONE:
        case HYMN_VALUE_BOOL:
        case HYMN_VALUE_INTEGER:
        case HYMN_VALUE_FLOAT:
        case HYMN_VALUE_STRING:
        case HYMN_VALUE_FUNC:
        case HYMN_VALUE_FUNC_NATIVE:
            push(H, value);
            break;
        case HYMN_VALUE_ARRAY: {
            HymnArray *copy = new_array_copy(hymn_as_array(value));
            HymnValue new = hymn_new_array_value(copy);
            push(H, new);
            hymn_reference(new);
            hymn_dereference(H, value);
            break;
        }
        case HYMN_VALUE_TABLE: {
            HymnTable *copy = new_table_copy(hymn_as_table(value));
            HymnValue new = hymn_new_table_value(copy);
            push(H, new);
            hymn_reference(new);
            hymn_dereference(H, value);
            break;
        }
        default:
            push(H, hymn_new_none());
        }
        goto dispatch;
    }
    case OP_SLICE: {
        HymnValue b = pop(H);
        HymnValue a = pop(H);
        HymnValue v = pop(H);
        if (!hymn_is_int(a)) {
            const char *is = hymn_value_type(a.is);
            hymn_dereference(H, a);
            hymn_dereference(H, b);
            hymn_dereference(H, v);
            THROW(&quot;slice can't use %s (expected integer)&quot;, is)
        }
        HymnInt start = hymn_as_int(a);
        if (start &lt; 0) {
            hymn_dereference(H, a);
            hymn_dereference(H, b);
            hymn_dereference(H, v);
            THROW(&quot;negative slice start: %d&quot;, start)
        }
        if (hymn_is_string(v)) {
            HymnString *original = hymn_as_string(v);
            HymnInt size = (HymnInt)hymn_string_len(original);
            HymnInt end;
            if (hymn_is_int(b)) {
                end = hymn_as_int(b);
            } else if (hymn_is_none(b)) {
                end = size;
            } else {
                const char *is = hymn_value_type(b.is);
                hymn_dereference(H, a);
                hymn_dereference(H, b);
                hymn_dereference(H, v);
                THROW(&quot;slice can't use %s (expected integer)&quot;, is)
            }
            if (end &gt; size) {
                hymn_dereference(H, a);
                hymn_dereference(H, b);
                hymn_dereference(H, v);
                THROW(&quot;slice out of bounds: %d &gt; %d&quot;, end, size)
            }
            if (end &lt; 0) {
                end = size + end;
                if (end &lt; 0) {
                    hymn_dereference(H, a);
                    hymn_dereference(H, b);
                    hymn_dereference(H, v);
                    THROW(&quot;negative slice end: %d&quot;, end)
                }
            }
            if (start &gt;= end) {
                hymn_dereference(H, a);
                hymn_dereference(H, b);
                hymn_dereference(H, v);
                THROW(&quot;slice out of range: %d &gt;= %d&quot;, start, end)
            }
            HymnString *sub = hymn_substring(original, (size_t)start, (size_t)end);
            push_string(H, sub);
        } else if (hymn_is_array(v)) {
            HymnArray *array = hymn_as_array(v);
            HymnInt size = array-&gt;length;
            HymnInt end;
            if (hymn_is_int(b)) {
                end = hymn_as_int(b);
            } else if (hymn_is_none(b)) {
                end = size;
            } else {
                const char *is = hymn_value_type(b.is);
                hymn_dereference(H, a);
                hymn_dereference(H, b);
                hymn_dereference(H, v);
                THROW(&quot;slice can't use %s (expected integer)&quot;, is)
            }
            if (end &gt; size) {
                hymn_dereference(H, a);
                hymn_dereference(H, b);
                hymn_dereference(H, v);
                THROW(&quot;slice out of bounds: %d &gt; %d&quot;, end, size)
            }
            if (end &lt; 0) {
                end = size + end;
                if (end &lt; 0) {
                    hymn_dereference(H, a);
                    hymn_dereference(H, b);
                    hymn_dereference(H, v);
                    THROW(&quot;negative slice end: %d&quot;, end)
                }
            }
            if (start &gt;= end) {
                hymn_dereference(H, a);
                hymn_dereference(H, b);
                hymn_dereference(H, v);
                THROW(&quot;slice out of range: %d &gt;= %d&quot;, start, end)
            }
            HymnArray *copy = new_array_slice(array, start, end);
            HymnValue new = hymn_new_array_value(copy);
            hymn_reference(new);
            push(H, new);
        } else {
            const char *is = hymn_value_type(v.is);
            hymn_dereference(H, a);
            hymn_dereference(H, b);
            hymn_dereference(H, v);
            THROW(&quot;can't slice %s (expected string or array)&quot;, is)
        }
        hymn_dereference(H, v);
        goto dispatch;
    }
    case OP_CLEAR: {
        HymnValue value = pop(H);
        switch (value.is) {
        case HYMN_VALUE_BOOL:
            push(H, hymn_new_bool(false));
            break;
        case HYMN_VALUE_INTEGER:
            push(H, hymn_new_int(0));
            break;
        case HYMN_VALUE_FLOAT:
            push(H, hymn_new_float(0.0));
            break;
        case HYMN_VALUE_STRING:
            push_string(H, hymn_new_string(&quot;&quot;));
            break;
        case HYMN_VALUE_ARRAY: {
            HymnArray *array = hymn_as_array(value);
            hymn_array_clear(H, array);
            push(H, value);
            break;
        }
        case HYMN_VALUE_TABLE: {
            HymnTable *table = hymn_as_table(value);
            table_clear(H, table);
            push(H, value);
            break;
        }
        case HYMN_VALUE_UNDEFINED:
        case HYMN_VALUE_NONE:
        case HYMN_VALUE_FUNC:
        case HYMN_VALUE_FUNC_NATIVE:
        case HYMN_VALUE_POINTER:
            push(H, hymn_new_none());
            break;
        default:
            break;
        }
        goto dispatch;
    }
    case OP_KEYS: {
        HymnValue value = pop(H);
        if (!hymn_is_table(value)) {
            const char *is = hymn_value_type(value.is);
            hymn_dereference(H, value);
            THROW(&quot;call to 'keys' can't use %s (expected table)&quot;, is)
        } else {
            HymnTable *table = hymn_as_table(value);
            HymnArray *array = table_keys(table);
            HymnValue keys = hymn_new_array_value(array);
            hymn_reference(keys);
            push(H, keys);
            hymn_dereference(H, value);
        }
        goto dispatch;
    }
    case OP_INDEX: {
        HymnValue b = pop(H);
        HymnValue a = pop(H);
        switch (a.is) {
        case HYMN_VALUE_STRING: {
            if (!hymn_is_string(b)) {
                const char *is = hymn_value_type(b.is);
                hymn_dereference(H, a);
                hymn_dereference(H, b);
                THROW(&quot;call to 'index' can't use %s for 2nd argument (expected string)&quot;, is)
            }
            size_t index = 0;
            bool found = string_find(hymn_as_string(a), hymn_as_string(b), &index);
            if (found) {
                push(H, hymn_new_int((HymnInt)index));
            } else {
                push(H, hymn_new_int(-1));
            }
            hymn_dereference(H, a);
            hymn_dereference(H, b);
            break;
        }
        case HYMN_VALUE_ARRAY:
            push(H, hymn_new_int(hymn_array_index_of(hymn_as_array(a), b)));
            hymn_dereference(H, a);
            hymn_dereference(H, b);
            break;
        case HYMN_VALUE_TABLE: {
            HymnObjectString *key = table_key_of(hymn_as_table(a), b);
            if (key == NULL) {
                push(H, hymn_new_none());
            } else {
                push(H, hymn_new_string_value(key));
            }
            hymn_dereference(H, a);
            hymn_dereference(H, b);
            break;
        }
        default: {
            const char *is = hymn_value_type(a.is);
            hymn_dereference(H, a);
            hymn_dereference(H, b);
            THROW(&quot;call to 'index' can't use %s for 1st argument (expected string, array, or table)&quot;, is)
        }
        }
        goto dispatch;
    }
    case OP_TYPE: {
        HymnValue value = pop(H);
        const char *is = hymn_value_type(value.is);
        push_string(H, hymn_new_string(is));
        hymn_dereference(H, value);
        goto dispatch;
    }
    case OP_INT: {
        HymnValue value = pop(H);
        if (hymn_is_int(value)) {
            push(H, value);
        } else if (hymn_is_float(value)) {
            HymnInt number = (HymnInt)hymn_as_float(value);
            push(H, hymn_new_int(number));
        } else if (hymn_is_string(value)) {
            HymnString *string = hymn_as_string(value);
            char *end = NULL;
            double number = strtod(string, &end);
            if (string == end) {
                push(H, hymn_new_none());
            } else {
                push(H, hymn_new_int((HymnInt)number));
            }
            hymn_dereference(H, value);
        } else {
            const char *is = hymn_value_type(value.is);
            hymn_dereference(H, value);
            THROW(&quot;can't cast %s to integer&quot;, is)
        }
        goto dispatch;
    }
    case OP_FLOAT: {
        HymnValue value = pop(H);
        if (hymn_is_int(value)) {
            HymnFloat number = (HymnFloat)hymn_as_int(value);
            push(H, hymn_new_float(number));
        } else if (hymn_is_float(value)) {
            push(H, value);
        } else if (hymn_is_string(value)) {
            HymnString *string = hymn_as_string(value);
            char *end = NULL;
            double number = strtod(string, &end);
            if (string == end) {
                push(H, hymn_new_none());
            } else {
                push(H, hymn_new_float(number));
            }
            hymn_dereference(H, value);
        } else {
            const char *is = hymn_value_type(value.is);
            hymn_dereference(H, value);
            THROW(&quot;can't cast %s to float&quot;, is)
        }
        goto dispatch;
    }
    case OP_STRING: {
        HymnValue value = pop(H);
        push_string(H, hymn_value_to_string(value));
        hymn_dereference(H, value);
        goto dispatch;
    }
    case OP_ECHO: {
        HymnValue value = pop(H);
        HymnString *string = hymn_value_to_string(value);
        H-&gt;print(&quot;%s\n&quot;, string);
        hymn_string_delete(string);
        hymn_dereference(H, value);
        goto dispatch;
    }
    case OP_PRINT: {
        HymnValue value = pop(H);
        HymnValue route = pop(H);
        HymnString *string = hymn_value_to_string(value);
        if (hymn_value_false(route)) {
            H-&gt;print(&quot;%s&quot;, string);
        } else {
            H-&gt;print_error(&quot;%s&quot;, string);
        }
        hymn_string_delete(string);
        hymn_dereference(H, value);
        hymn_dereference(H, route);
        goto dispatch;
    }
    case OP_INSPECT: {
        HymnValue value = pop(H);
        HymnString *inspect = NULL;
        if (hymn_is_func(value)) {
            HymnFunction *func = hymn_as_func(value);
            if (func-&gt;source != NULL) inspect = hymn_string_copy(func-&gt;source);
        }
        if (inspect == NULL) inspect = hymn_value_to_string(value);
        push_string(H, inspect);
        hymn_dereference(H, value);
        goto dispatch;
    }
    case OP_DEBUG: {
        HymnValue value = pop(H);
        HymnString *debug = NULL;
        if (hymn_is_func(value)) {
            HymnFunction *func = hymn_as_func(value);
            debug = disassemble_byte_code(&func-&gt;code);
        }
        if (debug == NULL) debug = hymn_value_to_string(value);
        push_string(H, debug);
        hymn_dereference(H, value);
        goto dispatch;
    }
    case OP_THROW: {
        frame = exception(H);
        if (frame == NULL) return;
        goto dispatch;
    }
    case OP_DUPLICATE: {
        HymnValue top = peek(H, 1);
        push(H, top);
        hymn_reference(top);
        goto dispatch;
    }
    case OP_USE: {
        HymnValue file = pop(H);
        if (hymn_is_string(file)) {
            frame = import(H, hymn_as_hymn_string(file));
            hymn_dereference(H, file);
            if (frame == NULL) return;
        } else {
            const char *is = hymn_value_type(file.is);
            hymn_dereference(H, file);
            THROW(&quot;import can't use %s (expected string)&quot;, is)
        }
        goto dispatch;
    }
    default:
        UNREACHABLE();
    }
}

static char *interpret(Hymn *H) {
    run(H);
    char *error = NULL;
    if (H-&gt;error) {
        error = string_to_chars(H-&gt;error);
        hymn_string_delete(H-&gt;error);
        H-&gt;error = NULL;
    }
    return error;
}

static void print_stdout(const char *format, ...) {
    va_list args;

    va_start(args, format);
    vprintf(format, args);
    va_end(args);
}

static void print_stderr(const char *format, ...) {
    va_list args;

    va_start(args, format);
    vfprintf(stderr, format, args);
    va_end(args);
}

Hymn *new_hymn(void) {
    Hymn *H = hymn_calloc(1, sizeof(Hymn));
    reset_stack(H);

    // STRINGS

    set_init(&H-&gt;strings);

    HymnObjectString *search_this = hymn_new_intern_string(H, &quot;&lt;parent&gt;&quot; PATH_SEP_STRING &quot;&lt;path&gt;.hm&quot;);
    hymn_reference_string(search_this);

    HymnObjectString *search_relative = hymn_new_intern_string(H, &quot;.&quot; PATH_SEP_STRING &quot;&lt;path&gt;.hm&quot;);
    hymn_reference_string(search_relative);

    HymnObjectString *search_libs = hymn_new_intern_string(H, &quot;.&quot; PATH_SEP_STRING &quot;libs&quot; PATH_SEP_STRING &quot;&lt;path&gt;.hm&quot;);
    hymn_reference_string(search_libs);

    // GLOBALS

    table_init(&H-&gt;globals);

    HymnObjectString *globals = hymn_new_intern_string(H, &quot;GLOBALS&quot;);
    hymn_reference_string(globals);

    HymnValue globals_value = hymn_new_table_value(&H-&gt;globals);
    table_put(&H-&gt;globals, globals, globals_value);
    hymn_reference_string(globals);
    hymn_reference(globals_value);
    hymn_reference(globals_value);

    // PATHS

    H-&gt;paths = hymn_new_array(3);

    HymnObjectString *paths = hymn_new_intern_string(H, &quot;PATHS&quot;);
    hymn_reference_string(paths);

    H-&gt;paths-&gt;items[0] = hymn_new_string_value(search_this);
    H-&gt;paths-&gt;items[1] = hymn_new_string_value(search_relative);
    H-&gt;paths-&gt;items[2] = hymn_new_string_value(search_libs);

    HymnValue paths_value = hymn_new_array_value(H-&gt;paths);
    table_put(&H-&gt;globals, paths, paths_value);
    hymn_reference_string(paths);
    hymn_reference(paths_value);
    hymn_reference(paths_value);

    // IMPORTS

    H-&gt;imports = hymn_new_table();

    HymnObjectString *imports = hymn_new_intern_string(H, &quot;IMPORTS&quot;);
    hymn_reference_string(imports);

    HymnValue imports_value = hymn_new_table_value(H-&gt;imports);
    table_put(&H-&gt;globals, imports, imports_value);
    hymn_reference_string(imports);
    hymn_reference(imports_value);
    hymn_reference(imports_value);

    H-&gt;print = print_stdout;
    H-&gt;print_error = print_stderr;

    return H;
}

void hymn_delete(Hymn *H) {
    {
        HymnTable *globals_table = &H-&gt;globals;
        HymnObjectString *globals = hymn_new_intern_string(H, &quot;GLOBALS&quot;);
        table_remove(globals_table, globals);
        hymn_dereference_string(H, globals);

        table_release(H, globals_table);
        assert(globals_table-&gt;size == 0);
    }

    hymn_array_delete(H, H-&gt;paths);
    table_delete(H, H-&gt;imports);

    HymnSet *strings = &H-&gt;strings;
    {
        unsigned int bins = strings-&gt;bins;
        for (unsigned int i = 0; i &lt; bins; i++) {
            HymnSetItem *item = strings-&gt;items[i];
            while (item != NULL) {
                HymnSetItem *next = item-&gt;next;
                hymn_dereference_string(H, item-&gt;string);
                item = next;
            }
        }
    }
#ifdef HYMN_DEBUG_MEMORY
    {
        unsigned int bins = strings-&gt;bins;
        for (unsigned int i = 0; i &lt; bins; i++) {
            HymnSetItem *item = strings-&gt;items[i];
            while (item != NULL) {
                fprintf(stderr, &quot;ENDING STRING REFERENCE: %s\n&quot;, item-&gt;string-&gt;string);
                item = item-&gt;next;
            }
        }
    }
#endif
    assert(strings-&gt;size == 0);
    free(strings-&gt;items);

    hymn_string_delete(H-&gt;error);

#ifndef HYMN_NO_DYNAMIC_LIBS
    HymnLibList *lib = H-&gt;libraries;
    while (lib != NULL) {
        hymn_close_dlib(lib-&gt;lib);
        HymnLibList *next = lib-&gt;next;
        free(lib);
        lib = next;
    }
#endif

    free(H);
}

HymnValue hymn_get(Hymn *H, const char *name) {
    return hymn_table_get(&H-&gt;globals, name);
}

void hymn_add(Hymn *H, const char *name, HymnValue value) {
    HymnObjectString *string = hymn_new_intern_string(H, name);
    HymnValue previous = table_put(&H-&gt;globals, string, value);
    if (hymn_is_undefined(previous)) {
        hymn_reference_string(string);
    } else {
        hymn_dereference(H, previous);
    }
    hymn_reference(value);
}

void hymn_add_string(Hymn *H, const char *name, const char *string) {
    HymnObjectString *object = hymn_new_intern_string(H, string);
    hymn_add(H, name, hymn_new_string_value(object));
}

void hymn_add_table(Hymn *H, const char *name, HymnTable *table) {
    hymn_add(H, name, hymn_new_table_value(table));
}

void hymn_add_pointer(Hymn *H, const char *name, void *pointer) {
    hymn_add(H, name, hymn_new_pointer(pointer));
}

void hymn_add_string_to_table(Hymn *H, HymnTable *table, const char *name, const char *string) {
    HymnObjectString *object = hymn_new_intern_string(H, string);
    hymn_set_property_const(H, table, name, hymn_new_string_value(object));
}

void hymn_add_function_to_table(Hymn *H, HymnTable *table, const char *name, HymnNativeCall func) {
    HymnObjectString *string = hymn_new_intern_string(H, name);
    HymnNativeFunction *native = new_native_function(string, func);
    HymnValue value = hymn_new_native(native);
    hymn_set_property(H, table, string, value);
}

void hymn_add_function(Hymn *H, const char *name, HymnNativeCall func) {
    hymn_add_function_to_table(H, &H-&gt;globals, name, func);
}

char *hymn_call(Hymn *H, const char *name, int arguments) {
    HymnValue function = hymn_table_get(&H-&gt;globals, name);
    if (hymn_is_undefined(function)) {
        return NULL;
    }
    hymn_reference(function);

    push(H, function);
    call_value(H, function, arguments);

    char *error = interpret(H);
    if (error) {
        return error;
    }

    assert(H-&gt;stack_top == H-&gt;stack);
    reset_stack(H);

    return NULL;
}

char *hymn_debug(Hymn *H, const char *script, const char *source) {
    HymnString *code = NULL;
    if (source == NULL) {
        code = hymn_read_file(script);
        if (code == NULL) {
            HymnString *format = hymn_string_format(&quot;file not found: %s\n&quot;, script);
            char *error = string_to_chars(format);
            hymn_string_delete(format);
            return error;
        }
    } else {
        code = hymn_new_string(source);
    }

    CompileResult result = compile(H, script, code, TYPE_SCRIPT);

    char *error = result.error;
    if (error) {
        hymn_string_delete(code);
        return error;
    }

    HymnFunction *main = result.func;

    HymnString *debug = disassemble_byte_code(&main-&gt;code);
    printf(&quot;\n-- %s --\n%s\n&quot;, script != NULL ? script : &quot;script&quot;, debug);
    hymn_string_delete(debug);

    HymnValuePool *constants = &main-&gt;code.constants;
    int count = constants-&gt;count;
    HymnValue *values = constants-&gt;values;

    for (int i = 0; i &lt; count; i++) {
        HymnValue value = values[i];
        if (hymn_is_func(value)) {
            HymnFunction *func = hymn_as_func(value);
            debug = disassemble_byte_code(&func-&gt;code);
            printf(&quot;\n-- %s --\n%s\n&quot;, func-&gt;name != NULL ? func-&gt;name : &quot;script&quot;, debug);
            hymn_string_delete(debug);
        }
    }

    for (int i = 0; i &lt; count; i++) {
        HymnValue value = values[i];
        if (hymn_is_func(value)) {
            HymnFunction *func = hymn_as_func(value);
            function_delete(func);
        }
    }

    function_delete(main);
    hymn_string_delete(code);

    assert(H-&gt;stack_top == H-&gt;stack);
    reset_stack(H);

    return NULL;
}

static char *exec(Hymn *H, const char *script, const char *source, enum FunctionType type) {
    CompileResult result = compile(H, script, source, type);

    char *error = result.error;
    if (error) {
        return error;
    }

    HymnFunction *func = result.func;
    HymnValue function = hymn_new_func_value(func);
    hymn_reference(function);

    push(H, function);
    call(H, func, 0);

    error = interpret(H);
    if (error) {
        return error;
    }

    assert(H-&gt;stack_top == H-&gt;stack);
    reset_stack(H);

    return NULL;
}

char *hymn_run(Hymn *H, const char *script, const char *source) {
    return exec(H, script, source, TYPE_SCRIPT);
}

char *hymn_do(Hymn *H, const char *source) {
    return exec(H, NULL, source, TYPE_DO);
}

char *hymn_script(Hymn *H, const char *script) {
    HymnString *source = hymn_read_file(script);
    if (source == NULL) {
        HymnString *format = hymn_string_format(&quot;file not found: %s\n&quot;, script);
        char *error = string_to_chars(format);
        hymn_string_delete(format);
        return error;
    }
    char *error = exec(H, script, source, TYPE_SCRIPT);
    hymn_string_delete(source);
    return error;
}

#ifndef HYMN_NO_REPL

#include &lt;ctype.h&gt;

#define INPUT_LIMIT 256

typedef struct History History;

struct History {
    HymnString *input;
    History *previous;
    History *next;
};

#ifndef _MSC_VER
#include &lt;termios.h&gt;

#define CURSOR_RESET &quot;\033[2K\r&quot;

#define cursor_backspace() printf(&quot;\b \b&quot;)
#define cursor_forward() printf(&quot;\033[1C&quot;)
#define cursor_backward() printf(&quot;\033[1D&quot;)
#define cursor_clear() printf(&quot;\033[s\033[K&quot;)
#define cursor_erase() printf(&quot;\033[1D\033[s\033[K&quot;)
#define cursor_unsave() printf(&quot;\033[u&quot;)
#define cursor_reset() printf(CURSOR_RESET)

enum Keyboard {
    ARROW_UP = 1000,
    ARROW_DOWN,
    ARROW_LEFT,
    ARROW_RIGHT,
    PAGE_UP,
    PAGE_DOWN,
    HOME_KEY,
    END_KEY,
    DELETE_KEY
};

static char letters[] =
    &quot;0123456789&quot;
    &quot;abcdefghijklmnopqrstuvwxyz&quot;
    &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;

static struct termios save_termios;

static int read_key(void) {
    do {
        char c;
        ssize_t e = read(STDIN_FILENO, &c, 1);
        if (e == 1) {
            if (c == '\x1b') {
                char sequence[3];
                if (read(STDIN_FILENO, &sequence[0], 1) != 1) {
                    return '\x1b';
                }
                if (read(STDIN_FILENO, &sequence[1], 1) != 1) {
                    return '\x1b';
                }
                if (sequence[0] == '[') {
                    if (sequence[1] &gt;= '0' && sequence[1] &lt;= '9') {
                        if (read(STDIN_FILENO, &sequence[2], 1) != 1) {
                            return '\x1b';
                        }
                        if (sequence[2] == '~') {
                            switch (sequence[1]) {
                            case '1': return HOME_KEY;
                            case '3': return DELETE_KEY;
                            case '4': return END_KEY;
                            case '5': return PAGE_UP;
                            case '6': return PAGE_DOWN;
                            case '7': return HOME_KEY;
                            case '8': return END_KEY;
                            default: break;
                            }
                        }
                    } else {
                        switch (sequence[1]) {
                        case 'A': return ARROW_UP;
                        case 'B': return ARROW_DOWN;
                        case 'D': return ARROW_LEFT;
                        case 'C': return ARROW_RIGHT;
                        case 'H': return HOME_KEY;
                        case 'F': return END_KEY;
                        default: break;
                        }
                    }
                } else if (sequence[0] == 'O') {
                    switch (sequence[1]) {
                    case 'H': return HOME_KEY;
                    case 'F': return END_KEY;
                    default: break;
                    }
                }
                return '\x1b';
            } else {
                return c;
            }
        } else if (e == -1 && errno != EAGAIN) {
            printf(&quot;\nuser interrupt&quot;);
            return EOF;
        }
    } while (true);
}

static void reset_terminal(void) {
    if (tcsetattr(STDIN_FILENO, TCSANOW, &save_termios) == -1) {
        perror(&quot;tcsetattr&quot;);
    }
}
#else
static void remove_newline(char *line) {
    size_t i = 0;
    while (line[i] != '\0') {
        i++;
    }
    while (i &gt; 0) {
        i--;
        if (line[i] != '\n') return;
        line[i] = '\0';
    }
}
#endif

static void call_function(Hymn *H, HymnFunction *func) {
    HymnValue function = hymn_new_func_value(func);
    hymn_reference(function);
    push(H, function);
    call(H, func, 0);
    char *error = interpret(H);
    if (error != NULL) {
        fprintf(stderr, &quot;%s\n&quot;, error);
        fflush(stderr);
        free(error);
    }
    assert(H-&gt;stack_top == H-&gt;stack);
    reset_stack(H);
}

void hymn_repl(Hymn *H) {

    printf(&quot;welcome to hymn v&quot; HYMN_VERSION &quot;\ntype .help for more information\n&quot;);

#ifdef _MSC_VER
    char temp_dir[MAX_PATH];
    GetTempPath(MAX_PATH, temp_dir);
#else
    if (tcgetattr(STDIN_FILENO, &save_termios) == -1) {
        perror(&quot;tcgetattr&quot;);
        return;
    }
    struct termios new_term = save_termios;
    new_term.c_lflag &= ~(0U | ECHO | ICANON);
    new_term.c_cc[VMIN] = 1;
    new_term.c_cc[VTIME] = 0;
    if (tcsetattr(STDIN_FILENO, TCSANOW, &new_term) == -1) {
        perror(&quot;tcsetattr&quot;);
        return;
    }
    atexit(reset_terminal);

    int index = 0;
    int count = 0;

    History *lines = NULL;
    History *cursor = NULL;
#endif

    char line[INPUT_LIMIT];
    HymnString *input = hymn_new_string_with_capacity(INPUT_LIMIT);

    History *history = NULL;
    bool open_editor = false;

    while (true) {
        printf(input[0] == '\0' ? &quot;&gt; &quot; : &quot;... &quot;);
        fflush(stdout);

#ifdef _MSC_VER
        if (fgets(line, sizeof(line), stdin) == NULL) {
            break;
        }
        remove_newline(line);
#else
#define CONTROL_KEY(c) ((c)&0x1f)

        index = 0;
        count = 0;

        while (true) {
            int c = read_key();
            switch (c) {
            case CONTROL_KEY('d'):
                printf(&quot;\n&quot;);
                goto quit;
            case CONTROL_KEY('e'):
                open_editor = true;
                goto scan;
            case PAGE_UP:
            case ARROW_UP:
                if (lines != NULL) {
                    if (cursor == NULL) {
                        cursor = lines;
                    } else if (cursor-&gt;previous == NULL) {
                        continue;
                    } else {
                        cursor = cursor-&gt;previous;
                    }
                    size_t len = hymn_string_len(cursor-&gt;input);
                    memcpy(line, cursor-&gt;input, len + 1);
                    index = (int)len;
                    count = index;
                    printf(CURSOR_RESET &quot;%s %s&quot;, input[0] == '\0' ? &quot;&gt;&quot; : &quot;...&quot;, line);
                    fflush(stdout);
                }
                continue;
            case PAGE_DOWN:
            case ARROW_DOWN:
                if (cursor != NULL) {
                    cursor = cursor-&gt;next;
                    if (cursor != NULL) {
                        size_t len = hymn_string_len(cursor-&gt;input);
                        memcpy(line, cursor-&gt;input, len + 1);
                        index = (int)len;
                        count = index;
                    } else {
                        line[0] = '\0';
                        index = 0;
                        count = 0;
                    }
                    printf(CURSOR_RESET &quot;%s %s&quot;, input[0] == '\0' ? &quot;&gt;&quot; : &quot;...&quot;, line);
                    fflush(stdout);
                }
                continue;
            case HOME_KEY:
            case ARROW_LEFT:
                if (index &gt; 0) {
                    index--;
                    cursor_backward();
                    fflush(stdout);
                }
                continue;
            case END_KEY:
            case ARROW_RIGHT:
                if (index &lt; count) {
                    index++;
                    cursor_forward();
                    fflush(stdout);
                }
                continue;
            case DELETE_KEY:
                if (index &lt; count) {
                    count--;
                    for (int i = index; i &lt; count; i++) {
                        line[i] = line[i + 1];
                    }
                    cursor_clear();
                    line[count] = '\0';
                    printf(&quot;%s&quot;, &line[index]);
                    cursor_unsave();
                    fflush(stdout);
                }
                continue;
            case EOF:
                hymn_string_zero(input);
                count = 0;
                goto scan;
            case '\n':
            case '\r':
                goto scan;
            default:
                if (iscntrl(c)) {
                    if (c == 8 || c == 127) {
                        // delete or backspace
                        if (index &gt; 0) {
                            index--;
                            for (int i = index; i &lt; count - 1; i++) {
                                line[i] = line[i + 1];
                            }
                            count--;
                            if (index == count) {
                                cursor_backspace();
                            } else {
                                cursor_erase();
                                line[count] = '\0';
                                printf(&quot;%s&quot;, &line[index]);
                                cursor_unsave();
                            }
                            fflush(stdout);
                        }
                    } else {
                        printf(&quot;&lt;%d&gt;&quot;, c);
                        fflush(stdout);
                    }
                } else if (c != '\0') {
                    if (count &lt; INPUT_LIMIT) {
                        count++;
                        for (int i = count - 1; i &gt; index; i--) {
                            line[i] = line[i - 1];
                        }
                        line[index] = (char)c;
                        index++;
                        if (index == count) {
                            printf(&quot;%c&quot;, c);
                        } else {
                            cursor_clear();
                            line[count] = '\0';
                            printf(&quot;%s&quot;, &line[index - 1]);
                            cursor_unsave();
                            cursor_forward();
                        }
                        fflush(stdout);
                    }
                }
            }
        }

    scan:
        line[count] = '\0';
        printf(&quot;\n&quot;);
        cursor = NULL;
#endif

        if (line[0] == '.') {
            if (hymn_string_equal(line, &quot;.exit&quot;) || hymn_string_equal(line, &quot;.quit&quot;)) {
                goto quit;
            } else if (hymn_string_equal(line, &quot;.edit&quot;)) {
                line[0] = '\0';
                open_editor = true;
                goto editing;
            } else if (hymn_string_equal(line, &quot;.help&quot;)) {
                printf(&quot;.exit   Exit interactive mode\n&quot;
                       &quot;.quit   Alias for .exit\n&quot;
                       &quot;.edit   Edit input using $EDITOR\n&quot;
                       &quot;.save   Save history to [FILE]\n&quot;
                       &quot;.load   Read history from [FILE]\n&quot;
                       &quot;.help   Print this help message\n&quot;
                       &quot;press ^E to use $EDITOR\n&quot;
                       &quot;press ^C to cancel expression\n&quot;
                       &quot;press ^D to exit interactive mode\n&quot;);
            } else if (string_starts_with(line, &quot;.save &quot;)) {
                char path[PATH_MAX];
                strcpy(path, &line[6]);
                if (path[0] == '\0') {
                    printf(&quot;bad file path\n&quot;);
                } else if (history == NULL) {
                    printf(&quot;no history to save\n&quot;);
                } else if (hymn_file_exists(path)) {
                    printf(&quot;history can't overwrite an existing file: %s\n&quot;, path);
                } else {
                    FILE *open = fopen(path, &quot;w&quot;);
                    if (open == NULL) {
                        printf(&quot;failed to write history: %s\n&quot;, path);
                    } else {
                        History *head = history;
                        while (head-&gt;previous != NULL) {
                            head = head-&gt;previous;
                        }
                        while (head != NULL) {
                            fprintf(open, &quot;%s\n&quot;, head-&gt;input);
                            head = head-&gt;next;
                        }
                        fclose(open);
                        printf(&quot;history saved to: %s\n&quot;, path);
                    }
                }
            } else if (string_starts_with(line, &quot;.load &quot;)) {
                char path[PATH_MAX];
                strcpy(path, &line[6]);
                if (path[0] == '\0') {
                    printf(&quot;bad file path\n&quot;);
                } else if (hymn_file_exists(path)) {
                    HymnString *source = hymn_read_file(path);
                    if (source == NULL) {
                        printf(&quot;failed to read history: %s\n&quot;, path);
                    } else {
                        char *error = hymn_do(H, source);
                        hymn_string_delete(source);
                        if (error != NULL) {
                            fprintf(stderr, &quot;%s\n&quot;, error);
                            fflush(stderr);
                            free(error);
                        }
                    }
                } else {
                    printf(&quot;history file not found: %s\n&quot;, path);
                }
            } else if (hymn_string_equal(line, &quot;.save&quot;)) {
                printf(&quot;specify a path\n&quot;);
            } else if (hymn_string_equal(line, &quot;.load&quot;)) {
                printf(&quot;specify a path\n&quot;);
            } else {
                printf(&quot;invalid interactive command\n&quot;);
            }
            continue;
        }

    editing:
        if (line[0] != '\0') {
#ifndef _MSC_VER
            History *save = hymn_calloc(1, sizeof(History));
            save-&gt;input = hymn_new_string(line);
            if (lines == NULL) {
                lines = save;
            } else {
                lines-&gt;next = save;
                save-&gt;previous = lines;
                lines = save;
            }
#endif
            if (input[0] != '\0') input = hymn_string_append_char(input, '\n');
            input = hymn_string_append(input, line);
            hymn_string_trim(input);
        }

        if (open_editor) {
            open_editor = false;

            char *editor = getenv(&quot;EDITOR&quot;);
            if (editor == NULL) {
#ifdef _MSC_VER
                editor = &quot;notepad&quot;;
#else
                printf(&quot;no EDITOR set\n&quot;);
                continue;
#endif
            }

            FILE *temp = NULL;

#ifdef _MSC_VER
            char path[MAX_PATH];
            GetTempFileName(temp_dir, &quot;hymn&quot;, 0, path);
            temp = fopen(path, &quot;w&quot;);
#else
            char path[] = &quot;/tmp/hymn.XXXXXX&quot;;
            for (int a = 0; a &lt; 64; a++) {
                for (int x = 0; x &lt; 6; x++) {
                    path[10 + x] = letters[(size_t)((double)rand() / RAND_MAX * (sizeof(letters) - 1))];
                }
                temp = fopen(path, &quot;wx&quot;);
                if (temp != NULL) {
                    break;
                }
            }
#endif

            if (temp == NULL) {
                printf(&quot;failed to create temporary file\n&quot;);
                continue;
            }

            hymn_string_trim(input);
            if (hymn_string_len(input) &gt; 0) {
                fprintf(temp, &quot;%s&quot;, input);
                hymn_string_zero(input);
            }

            fclose(temp);

            HymnString *edit = hymn_string_format(&quot;%s %s&quot;, editor, path);
            int result = system(edit);
            if (result == -1) {
                printf(&quot;failed edit: %d\n&quot;, result);
            }
            hymn_string_delete(edit);

            HymnString *content = hymn_read_file(path);
            unlink(path);

            if (content == NULL) {
                printf(&quot;failed to read temporary file\n&quot;);
                continue;
            }

            input = hymn_string_append(input, content);
            hymn_string_delete(content);
            hymn_string_trim(input);
            if (input[0] == '\0') {
                continue;
            }
            printf(&quot;%s\n&quot;, input);
        }

        if (input[0] == '\0') continue;

        CompileResult result = compile(H, NULL, input, TYPE_REPL);
        char *error = result.error;
        if (error != NULL) {
            if (!hymn_string_equal(error, &quot;&lt;eof&gt;&quot;)) {
                hymn_string_zero(input);
                fprintf(stderr, &quot;%s\n&quot;, error);
                fflush(stderr);
                free(error);
            }
            continue;
        }
        HymnFunction *func = result.func;

        History *save = hymn_calloc(1, sizeof(History));
        save-&gt;input = hymn_new_string(input);
        if (history == NULL) {
            history = save;
        } else {
            history-&gt;next = save;
            save-&gt;previous = history;
            history = save;
        }
        hymn_string_zero(input);

        call_function(H, func);
    }

quit:
    hymn_string_delete(input);
#ifndef _MSC_VER
    while (lines != NULL) {
        hymn_string_delete(lines-&gt;input);
        History *previous = lines-&gt;previous;
        free(lines);
        lines = previous;
    }
#endif
    while (history != NULL) {
        hymn_string_delete(history-&gt;input);
        History *previous = history-&gt;previous;
        free(history);
        history = previous;
    }
}
#endif

#ifndef HYMN_NO_DYNAMIC_LIBS

void hymn_add_dlib(Hymn *H, void *library) {
    HymnLibList *tail = H-&gt;libraries;
    HymnLibList *head = hymn_calloc(1, sizeof(HymnLibList));
    head-&gt;lib = library;
    head-&gt;next = tail;
    H-&gt;libraries = head;
}

#ifdef _MSC_VER
typedef void (*HymnDynamicLib)(Hymn *H);

void hymn_close_dlib(void *library) {
    FreeLibrary(library);
}

HymnString *hymn_use_dlib(Hymn *H, const char *path, const char *func) {
    HINSTANCE lib = LoadLibrary(path);
    if (lib != NULL) {
        HymnDynamicLib proc = (HymnDynamicLib)GetProcAddress(lib, func);
        if (proc != NULL) {
            proc(H);
            hymn_add_dlib(H, lib);
            return NULL;
        }
    }

    HymnString *message = NULL;
    int error = GetLastError();
    char buffer[128];
    if (FormatMessage(FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM, 0, error, 0, buffer, sizeof(buffer), 0)) {
        message = hymn_new_string(buffer);
    } else {
        message = hymn_string_format(&quot;windows error: %d\n&quot;, error);
    }
    if (lib != NULL) {
        hymn_close_dlib(lib);
    }
    return message;
}

#else
#include &lt;dlfcn.h&gt;

void hymn_close_dlib(void *library) {
    dlclose(library);
}

HymnString *hymn_use_dlib(Hymn *H, const char *path, const char *func) {
    void *lib = dlopen(path, RTLD_NOW);
    if (lib != NULL) {
        void *(*proc)(Hymn *);
        *(void **)(&proc) = dlsym(lib, func);
        if (proc != NULL) {
            proc(H);
            hymn_add_dlib(H, lib);
            return NULL;
        }
    }

    HymnString *message = hymn_new_string(dlerror());
    if (lib != NULL) {
        hymn_close_dlib(lib);
    }
    return message;
}
#endif

#endif
</code></pre></div>
      </section>
    </main>
    <footer>
      <p>
        Made with  by <a href="https://nathanmcmillan.github.io/">Nathan McMillan</a>. You can find the website source code
        <a href="https://github.com/nathanmcmillan/hymn-website">here</a>.
      </p>
    </footer>
  </body>
</html>