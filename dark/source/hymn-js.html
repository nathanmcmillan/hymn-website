<!DOCTYPE html>
<html>
  <head>
    <title>hymn.js</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" type="text/css" href="/dark/css/index.css" />
  </head>

  <body>
    <header>
      <div class="header">
        <div class="header-left">Hymn Script</div>
        <div>
          <a href="/dark/index.html">Home</a>
          <a href="/dark/learn.html">Learn</a>
          <a href="/dark/play.html">Play</a>
          <a href="https://github.com/nathanmcmillan/hymn-lang/tags">Download</a>
          <a href="/dark/source">Source</a>
          <a href="/source/hymn-js.html">Light</a>
        </div>
      </div>
    </header>
    <main id="index">
      <h1 class="centered-header">hymn.js</h1>
      <section>
        <hr class="padding" />
        <div class="code"><pre><code><comment>/* This Source Code Form is subject to the terms of the Mozilla Public</comment>
<comment> * License, v. 2.0. If a copy of the MPL was not distributed with this</comment>
<comment> * file, You can obtain one at https://mozilla.org/MPL/2.0/. */</comment>

<keyword>const</keyword> HYMN_VERSION <keyword>=</keyword> <string>'0.10.0'</string>

<keyword>const</keyword> UINT8_MAX <keyword>=</keyword> <constant>255</constant>
<keyword>const</keyword> UINT16_MAX <keyword>=</keyword> <constant>65535</constant>
<keyword>const</keyword> HYMN_UINT8_COUNT <keyword>=</keyword> UINT8_MAX <keyword>+</keyword> <constant>1</constant>
<keyword>const</keyword> HYMN_FRAMES_MAX <keyword>=</keyword> <constant>64</constant>

<keyword>const</keyword> HYMN_VALUE_NONE <keyword>=</keyword> <constant>1</constant>
<keyword>const</keyword> HYMN_VALUE_BOOL <keyword>=</keyword> <constant>2</constant>
<keyword>const</keyword> HYMN_VALUE_INTEGER <keyword>=</keyword> <constant>3</constant>
<keyword>const</keyword> HYMN_VALUE_FLOAT <keyword>=</keyword> <constant>4</constant>
<keyword>const</keyword> HYMN_VALUE_STRING <keyword>=</keyword> <constant>5</constant>
<keyword>const</keyword> HYMN_VALUE_ARRAY <keyword>=</keyword> <constant>6</constant>
<keyword>const</keyword> HYMN_VALUE_TABLE <keyword>=</keyword> <constant>7</constant>
<keyword>const</keyword> HYMN_VALUE_FUNC <keyword>=</keyword> <constant>8</constant>
<keyword>const</keyword> HYMN_VALUE_FUNC_NATIVE <keyword>=</keyword> <constant>9</constant>
<keyword>const</keyword> HYMN_VALUE_POINTER <keyword>=</keyword> <constant>10</constant>

<keyword>const</keyword> node <keyword>=</keyword> typeof window <keyword>==</keyword><keyword>=</keyword> <string>'undefined'</string>
<keyword>const</keyword> nodeFs <keyword>=</keyword> node ? require(<string>'fs'</string>) : null
<keyword>const</keyword> nodePath <keyword>=</keyword> node ? require(<string>'path'</string>) : null
<keyword>const</keyword> nodeProcess <keyword>=</keyword> node ? require(<string>'process'</string>) : null

<keyword>const</keyword> LOAD_FACTOR <keyword>=</keyword> <constant>0.8</constant>
<keyword>const</keyword> INITIAL_BINS <keyword>=</keyword> <constant>1</constant> <keyword>&lt;&lt;</keyword> <constant>3</constant>
<keyword>const</keyword> MAXIMUM_BINS <keyword>=</keyword> <constant>1</constant> <keyword>&lt;&lt;</keyword> <constant>30</constant>

class HymnValue {
  constructor(is, value) {
    this.is <keyword>=</keyword> is
    this.value <keyword>=</keyword> value
  }
}

function copyValueToFrom(to, from) {
  to.is <keyword>=</keyword> from.is
  to.value <keyword>=</keyword> from.value
}

function copyValue(original) {
  <keyword>const</keyword> value <keyword>=</keyword> new HymnValue()
  copyValueToFrom(value, original)
  <keyword>return</keyword> value
}

class HymnTableItem {
  constructor(hash, key, value) {
    this.hash <keyword>=</keyword> hash
    this.key <keyword>=</keyword> key
    this.value <keyword>=</keyword> value
    this.next <keyword>=</keyword> null
  }
}

class HymnTable {
  constructor() {
    this.size <keyword>=</keyword> <constant>0</constant>
    this.bins <keyword>=</keyword> INITIAL_BINS
    this.items <keyword>=</keyword> new Array(this.bins).fill(null)
  }
}

class HymnNativeFunction {
  constructor(name, func) {
    this.name <keyword>=</keyword> name
    this.func <keyword>=</keyword> func
  }
}

class HymnByteCode {
  constructor() {
    this.count <keyword>=</keyword> <constant>0</constant>
    this.instructions <keyword>=</keyword> new Uint8Array(128)
    this.lines <keyword>=</keyword> new Uint32Array(128)
    this.constants <keyword>=</keyword> []
  }
}

class ExceptList {
  constructor() {
    this.start <keyword>=</keyword> <constant>0</constant>
    this.end <keyword>=</keyword> <constant>0</constant>
    this.stack <keyword>=</keyword> <constant>0</constant>
    this.next <keyword>=</keyword> null
  }
}

class HymnFunction {
  constructor() {
    this.count <keyword>=</keyword> <constant>0</constant>
    this.name <keyword>=</keyword> null
    this.script <keyword>=</keyword> null
    this.source <keyword>=</keyword> null
    this.arity <keyword>=</keyword> <constant>0</constant>
    this.code <keyword>=</keyword> null
    this.except <keyword>=</keyword> null
  }
}

class HymnFrame {
  constructor() {
    this.func <keyword>=</keyword> null
    this.ip <keyword>=</keyword> <constant>0</constant>
    this.stack <keyword>=</keyword> <constant>0</constant>
  }
}

function printOut(text) {
  <keyword>if</keyword> (node) nodeProcess.stdout.write(text)
  <keyword>else</keyword> console.log(text)
}

function printError(text) {
  <keyword>if</keyword> (node) nodeProcess.stderr.write(text)
  <keyword>else</keyword> console.error(text)
}

function printLine(text) {
  console.log(text)
}

class Hymn {
  constructor() {
    this.stack <keyword>=</keyword> []
    this.stackTop <keyword>=</keyword> <constant>0</constant>
    this.frames <keyword>=</keyword> []
    this.frameCount <keyword>=</keyword> <constant>0</constant>
    this.globals <keyword>=</keyword> new HymnTable()
    this.paths <keyword>=</keyword> []
    this.imports <keyword>=</keyword> new HymnTable()
    this.error <keyword>=</keyword> null
    this.print <keyword>=</keyword> printOut
    this.printError <keyword>=</keyword> printError
    this.printLine <keyword>=</keyword> printLine
  }
}

<keyword>const</keyword> TOKEN_ADD <keyword>=</keyword> <constant>0</constant>
<keyword>const</keyword> TOKEN_AND <keyword>=</keyword> <constant>1</constant>
<keyword>const</keyword> TOKEN_ASSIGN <keyword>=</keyword> <constant>2</constant>
<keyword>const</keyword> TOKEN_ASSIGN_ADD <keyword>=</keyword> <constant>3</constant>
<keyword>const</keyword> TOKEN_ASSIGN_BIT_AND <keyword>=</keyword> <constant>4</constant>
<keyword>const</keyword> TOKEN_ASSIGN_BIT_LEFT_SHIFT <keyword>=</keyword> <constant>5</constant>
<keyword>const</keyword> TOKEN_ASSIGN_BIT_OR <keyword>=</keyword> <constant>6</constant>
<keyword>const</keyword> TOKEN_ASSIGN_BIT_RIGHT_SHIFT <keyword>=</keyword> <constant>7</constant>
<keyword>const</keyword> TOKEN_ASSIGN_BIT_XOR <keyword>=</keyword> <constant>8</constant>
<keyword>const</keyword> TOKEN_ASSIGN_DIVIDE <keyword>=</keyword> <constant>9</constant>
<keyword>const</keyword> TOKEN_ASSIGN_MODULO <keyword>=</keyword> <constant>10</constant>
<keyword>const</keyword> TOKEN_ASSIGN_MULTIPLY <keyword>=</keyword> <constant>11</constant>
<keyword>const</keyword> TOKEN_ASSIGN_SUBTRACT <keyword>=</keyword> <constant>12</constant>
<keyword>const</keyword> TOKEN_BIT_AND <keyword>=</keyword> <constant>13</constant>
<keyword>const</keyword> TOKEN_BIT_LEFT_SHIFT <keyword>=</keyword> <constant>14</constant>
<keyword>const</keyword> TOKEN_BIT_NOT <keyword>=</keyword> <constant>15</constant>
<keyword>const</keyword> TOKEN_BIT_OR <keyword>=</keyword> <constant>16</constant>
<keyword>const</keyword> TOKEN_BIT_RIGHT_SHIFT <keyword>=</keyword> <constant>17</constant>
<keyword>const</keyword> TOKEN_BIT_XOR <keyword>=</keyword> <constant>18</constant>
<keyword>const</keyword> TOKEN_BREAK <keyword>=</keyword> <constant>19</constant>
<keyword>const</keyword> TOKEN_CLEAR <keyword>=</keyword> <constant>20</constant>
<keyword>const</keyword> TOKEN_COLON <keyword>=</keyword> <constant>21</constant>
<keyword>const</keyword> TOKEN_COMMA <keyword>=</keyword> <constant>22</constant>
<keyword>const</keyword> TOKEN_CONTINUE <keyword>=</keyword> <constant>23</constant>
<keyword>const</keyword> TOKEN_COPY <keyword>=</keyword> <constant>24</constant>
<keyword>const</keyword> TOKEN_DELETE <keyword>=</keyword> <constant>25</constant>
<keyword>const</keyword> TOKEN_DIVIDE <keyword>=</keyword> <constant>26</constant>
<keyword>const</keyword> TOKEN_DOT <keyword>=</keyword> <constant>27</constant>
<keyword>const</keyword> TOKEN_ECHO <keyword>=</keyword> <constant>28</constant>
<keyword>const</keyword> TOKEN_ELIF <keyword>=</keyword> <constant>29</constant>
<keyword>const</keyword> TOKEN_ELSE <keyword>=</keyword> <constant>30</constant>
<keyword>const</keyword> TOKEN_EOF <keyword>=</keyword> <constant>31</constant>
<keyword>const</keyword> TOKEN_EQUAL <keyword>=</keyword> <constant>32</constant>
<keyword>const</keyword> TOKEN_ERROR <keyword>=</keyword> <constant>33</constant>
<keyword>const</keyword> TOKEN_EXCEPT <keyword>=</keyword> <constant>34</constant>
<keyword>const</keyword> TOKEN_EXISTS <keyword>=</keyword> <constant>35</constant>
<keyword>const</keyword> TOKEN_FALSE <keyword>=</keyword> <constant>36</constant>
<keyword>const</keyword> TOKEN_FLOAT <keyword>=</keyword> <constant>37</constant>
<keyword>const</keyword> TOKEN_FOR <keyword>=</keyword> <constant>38</constant>
<keyword>const</keyword> TOKEN_FUNCTION <keyword>=</keyword> <constant>39</constant>
<keyword>const</keyword> TOKEN_GREATER <keyword>=</keyword> <constant>40</constant>
<keyword>const</keyword> TOKEN_GREATER_EQUAL <keyword>=</keyword> <constant>41</constant>
<keyword>const</keyword> TOKEN_IDENT <keyword>=</keyword> <constant>42</constant>
<keyword>const</keyword> TOKEN_IF <keyword>=</keyword> <constant>43</constant>
<keyword>const</keyword> TOKEN_IN <keyword>=</keyword> <constant>44</constant>
<keyword>const</keyword> TOKEN_INDEX <keyword>=</keyword> <constant>45</constant>
<keyword>const</keyword> TOKEN_INSERT <keyword>=</keyword> <constant>46</constant>
<keyword>const</keyword> TOKEN_SRC <keyword>=</keyword> <constant>47</constant>
<keyword>const</keyword> TOKEN_INTEGER <keyword>=</keyword> <constant>48</constant>
<keyword>const</keyword> TOKEN_KEYS <keyword>=</keyword> <constant>49</constant>
<keyword>const</keyword> TOKEN_LEFT_CURLY <keyword>=</keyword> <constant>50</constant>
<keyword>const</keyword> TOKEN_LEFT_PAREN <keyword>=</keyword> <constant>51</constant>
<keyword>const</keyword> TOKEN_LEFT_SQUARE <keyword>=</keyword> <constant>52</constant>
<keyword>const</keyword> TOKEN_LEN <keyword>=</keyword> <constant>53</constant>
<keyword>const</keyword> TOKEN_LESS <keyword>=</keyword> <constant>54</constant>
<keyword>const</keyword> TOKEN_LESS_EQUAL <keyword>=</keyword> <constant>55</constant>
<keyword>const</keyword> TOKEN_SET <keyword>=</keyword> <constant>56</constant>
<keyword>const</keyword> TOKEN_MODULO <keyword>=</keyword> <constant>57</constant>
<keyword>const</keyword> TOKEN_MULTIPLY <keyword>=</keyword> <constant>58</constant>
<keyword>const</keyword> TOKEN_NONE <keyword>=</keyword> <constant>59</constant>
<keyword>const</keyword> TOKEN_NOT <keyword>=</keyword> <constant>60</constant>
<keyword>const</keyword> TOKEN_NOT_EQUAL <keyword>=</keyword> <constant>61</constant>
<keyword>const</keyword> TOKEN_OR <keyword>=</keyword> <constant>62</constant>
<keyword>const</keyword> TOKEN_POINTER <keyword>=</keyword> <constant>63</constant>
<keyword>const</keyword> TOKEN_POP <keyword>=</keyword> <constant>64</constant>
<keyword>const</keyword> TOKEN_PRINT <keyword>=</keyword> <constant>65</constant>
<keyword>const</keyword> TOKEN_PUSH <keyword>=</keyword> <constant>66</constant>
<keyword>const</keyword> TOKEN_RETURN <keyword>=</keyword> <constant>67</constant>
<keyword>const</keyword> TOKEN_RIGHT_CURLY <keyword>=</keyword> <constant>68</constant>
<keyword>const</keyword> TOKEN_RIGHT_PAREN <keyword>=</keyword> <constant>69</constant>
<keyword>const</keyword> TOKEN_RIGHT_SQUARE <keyword>=</keyword> <constant>70</constant>
<keyword>const</keyword> TOKEN_STRING <keyword>=</keyword> <constant>71</constant>
<keyword>const</keyword> TOKEN_SUBTRACT <keyword>=</keyword> <constant>72</constant>
<keyword>const</keyword> TOKEN_THROW <keyword>=</keyword> <constant>73</constant>
<keyword>const</keyword> TOKEN_TO_FLOAT <keyword>=</keyword> <constant>74</constant>
<keyword>const</keyword> TOKEN_TO_INTEGER <keyword>=</keyword> <constant>75</constant>
<keyword>const</keyword> TOKEN_TO_STRING <keyword>=</keyword> <constant>76</constant>
<keyword>const</keyword> TOKEN_TRUE <keyword>=</keyword> <constant>77</constant>
<keyword>const</keyword> TOKEN_TRY <keyword>=</keyword> <constant>78</constant>
<keyword>const</keyword> TOKEN_TYPE_FUNC <keyword>=</keyword> <constant>79</constant>
<keyword>const</keyword> TOKEN_UNDEFINED <keyword>=</keyword> <constant>80</constant>
<keyword>const</keyword> TOKEN_USE <keyword>=</keyword> <constant>81</constant>
<keyword>const</keyword> TOKEN_VALUE <keyword>=</keyword> <constant>82</constant>
<keyword>const</keyword> TOKEN_WHILE <keyword>=</keyword> <constant>83</constant>
<keyword>const</keyword> TOKEN_OPCODES <keyword>=</keyword> <constant>84</constant>
<keyword>const</keyword> TOKEN_STACK <keyword>=</keyword> <constant>85</constant>
<keyword>const</keyword> TOKEN_REFERENCE <keyword>=</keyword> <constant>86</constant>

<keyword>const</keyword> PRECEDENCE_NONE <keyword>=</keyword> <constant>0</constant>
<keyword>const</keyword> PRECEDENCE_ASSIGN <keyword>=</keyword> <constant>1</constant>
<keyword>const</keyword> PRECEDENCE_BITS <keyword>=</keyword> <constant>2</constant>
<keyword>const</keyword> PRECEDENCE_OR <keyword>=</keyword> <constant>3</constant>
<keyword>const</keyword> PRECEDENCE_AND <keyword>=</keyword> <constant>4</constant>
<keyword>const</keyword> PRECEDENCE_EQUALITY <keyword>=</keyword> <constant>5</constant>
<keyword>const</keyword> PRECEDENCE_COMPARE <keyword>=</keyword> <constant>6</constant>
<keyword>const</keyword> PRECEDENCE_TERM <keyword>=</keyword> <constant>7</constant>
<keyword>const</keyword> PRECEDENCE_FACTOR <keyword>=</keyword> <constant>8</constant>
<keyword>const</keyword> PRECEDENCE_UNARY <keyword>=</keyword> <constant>9</constant>
<keyword>const</keyword> PRECEDENCE_CALL <keyword>=</keyword> <constant>10</constant>

<keyword>const</keyword> STRING_STATUS_NONE <keyword>=</keyword> <constant>0</constant>
<keyword>const</keyword> STRING_STATUS_BEGIN <keyword>=</keyword> <constant>1</constant>
<keyword>const</keyword> STRING_STATUS_ADD <keyword>=</keyword> <constant>2</constant>
<keyword>const</keyword> STRING_STATUS_CLOSE <keyword>=</keyword> <constant>3</constant>
<keyword>const</keyword> STRING_STATUS_CONTINUE <keyword>=</keyword> <constant>4</constant>

<keyword>const</keyword> OP_ADD <keyword>=</keyword> <constant>0</constant>
<keyword>const</keyword> OP_INSERT <keyword>=</keyword> <constant>1</constant>
<keyword>const</keyword> OP_ARRAY_POP <keyword>=</keyword> <constant>2</constant>
<keyword>const</keyword> OP_ARRAY_PUSH <keyword>=</keyword> <constant>3</constant>
<keyword>const</keyword> OP_BIT_AND <keyword>=</keyword> <constant>4</constant>
<keyword>const</keyword> OP_BIT_LEFT_SHIFT <keyword>=</keyword> <constant>5</constant>
<keyword>const</keyword> OP_BIT_NOT <keyword>=</keyword> <constant>6</constant>
<keyword>const</keyword> OP_BIT_OR <keyword>=</keyword> <constant>7</constant>
<keyword>const</keyword> OP_BIT_RIGHT_SHIFT <keyword>=</keyword> <constant>8</constant>
<keyword>const</keyword> OP_BIT_XOR <keyword>=</keyword> <constant>9</constant>
<keyword>const</keyword> OP_CALL <keyword>=</keyword> <constant>10</constant>
<keyword>const</keyword> OP_CLEAR <keyword>=</keyword> <constant>11</constant>
<keyword>const</keyword> OP_CONSTANT <keyword>=</keyword> <constant>12</constant>
<keyword>const</keyword> OP_COPY <keyword>=</keyword> <constant>13</constant>
<keyword>const</keyword> OP_DEFINE_GLOBAL <keyword>=</keyword> <constant>14</constant>
<keyword>const</keyword> OP_DELETE <keyword>=</keyword> <constant>15</constant>
<keyword>const</keyword> OP_DIVIDE <keyword>=</keyword> <constant>16</constant>
<keyword>const</keyword> OP_DUPLICATE <keyword>=</keyword> <constant>17</constant>
<keyword>const</keyword> OP_ECHO <keyword>=</keyword> <constant>18</constant>
<keyword>const</keyword> OP_EQUAL <keyword>=</keyword> <constant>19</constant>
<keyword>const</keyword> OP_EXISTS <keyword>=</keyword> <constant>20</constant>
<keyword>const</keyword> OP_FALSE <keyword>=</keyword> <constant>21</constant>
<keyword>const</keyword> OP_FLOAT <keyword>=</keyword> <constant>22</constant>
<keyword>const</keyword> OP_FOR <keyword>=</keyword> <constant>23</constant>
<keyword>const</keyword> OP_FOR_LOOP <keyword>=</keyword> <constant>24</constant>
<keyword>const</keyword> OP_GET_DYNAMIC <keyword>=</keyword> <constant>25</constant>
<keyword>const</keyword> OP_GET_GLOBAL <keyword>=</keyword> <constant>26</constant>
<keyword>const</keyword> OP_GET_LOCAL <keyword>=</keyword> <constant>27</constant>
<keyword>const</keyword> OP_GET_PROPERTY <keyword>=</keyword> <constant>28</constant>
<keyword>const</keyword> OP_GREATER <keyword>=</keyword> <constant>29</constant>
<keyword>const</keyword> OP_GREATER_EQUAL <keyword>=</keyword> <constant>30</constant>
<keyword>const</keyword> OP_INCREMENT_LOCAL_AND_SET <keyword>=</keyword> <constant>31</constant>
<keyword>const</keyword> OP_INDEX <keyword>=</keyword> <constant>32</constant>
<keyword>const</keyword> OP_SOURCE <keyword>=</keyword> <constant>33</constant>
<keyword>const</keyword> OP_INT <keyword>=</keyword> <constant>34</constant>
<keyword>const</keyword> OP_JUMP <keyword>=</keyword> <constant>35</constant>
<keyword>const</keyword> OP_JUMP_IF_FALSE <keyword>=</keyword> <constant>36</constant>
<keyword>const</keyword> OP_JUMP_IF_TRUE <keyword>=</keyword> <constant>37</constant>
<keyword>const</keyword> OP_KEYS <keyword>=</keyword> <constant>38</constant>
<keyword>const</keyword> OP_LEN <keyword>=</keyword> <constant>39</constant>
<keyword>const</keyword> OP_LESS <keyword>=</keyword> <constant>40</constant>
<keyword>const</keyword> OP_LESS_EQUAL <keyword>=</keyword> <constant>41</constant>
<keyword>const</keyword> OP_LOOP <keyword>=</keyword> <constant>42</constant>
<keyword>const</keyword> OP_MODULO <keyword>=</keyword> <constant>43</constant>
<keyword>const</keyword> OP_MULTIPLY <keyword>=</keyword> <constant>44</constant>
<keyword>const</keyword> OP_NEGATE <keyword>=</keyword> <constant>45</constant>
<keyword>const</keyword> OP_NEW_ARRAY <keyword>=</keyword> <constant>46</constant>
<keyword>const</keyword> OP_NEW_TABLE <keyword>=</keyword> <constant>47</constant>
<keyword>const</keyword> OP_NONE <keyword>=</keyword> <constant>48</constant>
<keyword>const</keyword> OP_NOT <keyword>=</keyword> <constant>49</constant>
<keyword>const</keyword> OP_NOT_EQUAL <keyword>=</keyword> <constant>50</constant>
<keyword>const</keyword> OP_POP <keyword>=</keyword> <constant>51</constant>
<keyword>const</keyword> OP_PRINT <keyword>=</keyword> <constant>52</constant>
<keyword>const</keyword> OP_RETURN <keyword>=</keyword> <constant>53</constant>
<keyword>const</keyword> OP_SELF <keyword>=</keyword> <constant>54</constant>
<keyword>const</keyword> OP_SET_DYNAMIC <keyword>=</keyword> <constant>55</constant>
<keyword>const</keyword> OP_SET_GLOBAL <keyword>=</keyword> <constant>56</constant>
<keyword>const</keyword> OP_SET_LOCAL <keyword>=</keyword> <constant>57</constant>
<keyword>const</keyword> OP_SET_PROPERTY <keyword>=</keyword> <constant>58</constant>
<keyword>const</keyword> OP_SLICE <keyword>=</keyword> <constant>59</constant>
<keyword>const</keyword> OP_STRING <keyword>=</keyword> <constant>60</constant>
<keyword>const</keyword> OP_SUBTRACT <keyword>=</keyword> <constant>61</constant>
<keyword>const</keyword> OP_THROW <keyword>=</keyword> <constant>62</constant>
<keyword>const</keyword> OP_TRUE <keyword>=</keyword> <constant>63</constant>
<keyword>const</keyword> OP_TYPE <keyword>=</keyword> <constant>64</constant>
<keyword>const</keyword> OP_USE <keyword>=</keyword> <constant>65</constant>
<keyword>const</keyword> OP_CODES <keyword>=</keyword> <constant>66</constant>
<keyword>const</keyword> OP_STACK <keyword>=</keyword> <constant>67</constant>
<keyword>const</keyword> OP_REFERENCE <keyword>=</keyword> <constant>68</constant>

<keyword>const</keyword> TYPE_FUNCTION <keyword>=</keyword> <constant>0</constant>
<keyword>const</keyword> TYPE_SCRIPT <keyword>=</keyword> <constant>1</constant>
<keyword>const</keyword> TYPE_DIRECT <keyword>=</keyword> <constant>2</constant>

class Token {
  constructor() {
    this.type <keyword>=</keyword> TOKEN_UNDEFINED
    this.row <keyword>=</keyword> <constant>0</constant>
    this.column <keyword>=</keyword> <constant>0</constant>
    this.start <keyword>=</keyword> <constant>0</constant>
    this.length <keyword>=</keyword> <constant>0</constant>
    this.number <keyword>=</keyword> <constant>0</constant>
  }
}

function copyToken(dest, src) {
  dest.type <keyword>=</keyword> src.type
  dest.row <keyword>=</keyword> src.row
  dest.column <keyword>=</keyword> src.column
  dest.start <keyword>=</keyword> src.start
  dest.length <keyword>=</keyword> src.length
}

class Local {
  constructor() {
    this.name <keyword>=</keyword> null
    this.depth <keyword>=</keyword> <constant>0</constant>
  }
}

class Rule {
  constructor(prefix, infix, precedence) {
    this.prefix <keyword>=</keyword> prefix
    this.infix <keyword>=</keyword> infix
    this.precedence <keyword>=</keyword> precedence
  }
}

class Scope {
  constructor() {
    this.enclosing <keyword>=</keyword> null
    this.func <keyword>=</keyword> null
    this.type <keyword>=</keyword> TYPE_FUNCTION
    this.begin <keyword>=</keyword> <constant>0</constant>
    this.locals <keyword>=</keyword> []
    this.localCount <keyword>=</keyword> <constant>0</constant>
    this.depth <keyword>=</keyword> <constant>0</constant>
  }
}

class Compiler {
  constructor(script, source, H) {
    this.pos <keyword>=</keyword> <constant>0</constant>
    this.row <keyword>=</keyword> <constant>1</constant>
    this.column <keyword>=</keyword> <constant>1</constant>
    this.script <keyword>=</keyword> script
    this.source <keyword>=</keyword> source
    this.previous <keyword>=</keyword> new Token()
    this.current <keyword>=</keyword> new Token()
    this.stringFormat <keyword>=</keyword> <constant>0</constant>
    this.stringStatus <keyword>=</keyword> STRING_STATUS_NONE
    this.H <keyword>=</keyword> H
    this.scope <keyword>=</keyword> null
    this.pop <keyword>=</keyword> <keyword>-</keyword><constant>1</constant>
    this.barrier <keyword>=</keyword> <keyword>-</keyword><constant>1</constant>
    this.loop <keyword>=</keyword> null
    this.jump <keyword>=</keyword> null
    this.jumpOr <keyword>=</keyword> null
    this.jumpAnd <keyword>=</keyword> null
    this.jumpFor <keyword>=</keyword> null
    this.error <keyword>=</keyword> null
  }
}

class JumpList {
  constructor() {
    this.jump <keyword>=</keyword> <constant>0</constant>
    this.depth <keyword>=</keyword> <constant>0</constant>
    this.next <keyword>=</keyword> null
  }
}

class LoopList {
  constructor(start, depth, next, isFor) {
    this.start <keyword>=</keyword> start
    this.depth <keyword>=</keyword> depth
    this.next <keyword>=</keyword> next
    this.isFor <keyword>=</keyword> isFor
  }
}

<keyword>const</keyword> rules <keyword>=</keyword> []
rules[TOKEN_ADD] <keyword>=</keyword> new Rule(null, compileBinary, PRECEDENCE_TERM)
rules[TOKEN_AND] <keyword>=</keyword> new Rule(null, compileAnd, PRECEDENCE_AND)
rules[TOKEN_ASSIGN] <keyword>=</keyword> new Rule(null, null, PRECEDENCE_NONE)
rules[TOKEN_ASSIGN_ADD] <keyword>=</keyword> new Rule(null, null, PRECEDENCE_NONE)
rules[TOKEN_ASSIGN_BIT_AND] <keyword>=</keyword> new Rule(null, null, PRECEDENCE_NONE)
rules[TOKEN_ASSIGN_BIT_LEFT_SHIFT] <keyword>=</keyword> new Rule(null, null, PRECEDENCE_NONE)
rules[TOKEN_ASSIGN_BIT_OR] <keyword>=</keyword> new Rule(null, null, PRECEDENCE_NONE)
rules[TOKEN_ASSIGN_BIT_RIGHT_SHIFT] <keyword>=</keyword> new Rule(null, null, PRECEDENCE_NONE)
rules[TOKEN_ASSIGN_BIT_XOR] <keyword>=</keyword> new Rule(null, null, PRECEDENCE_NONE)
rules[TOKEN_ASSIGN_DIVIDE] <keyword>=</keyword> new Rule(null, null, PRECEDENCE_NONE)
rules[TOKEN_ASSIGN_MODULO] <keyword>=</keyword> new Rule(null, null, PRECEDENCE_NONE)
rules[TOKEN_ASSIGN_MULTIPLY] <keyword>=</keyword> new Rule(null, null, PRECEDENCE_NONE)
rules[TOKEN_ASSIGN_SUBTRACT] <keyword>=</keyword> new Rule(null, null, PRECEDENCE_NONE)
rules[TOKEN_BIT_AND] <keyword>=</keyword> new Rule(null, compileBinary, PRECEDENCE_BITS)
rules[TOKEN_BIT_LEFT_SHIFT] <keyword>=</keyword> new Rule(null, compileBinary, PRECEDENCE_BITS)
rules[TOKEN_BIT_NOT] <keyword>=</keyword> new Rule(compileUnary, null, PRECEDENCE_NONE)
rules[TOKEN_BIT_OR] <keyword>=</keyword> new Rule(null, compileBinary, PRECEDENCE_BITS)
rules[TOKEN_BIT_RIGHT_SHIFT] <keyword>=</keyword> new Rule(null, compileBinary, PRECEDENCE_BITS)
rules[TOKEN_BIT_XOR] <keyword>=</keyword> new Rule(null, compileBinary, PRECEDENCE_BITS)
rules[TOKEN_BREAK] <keyword>=</keyword> new Rule(null, null, PRECEDENCE_NONE)
rules[TOKEN_CLEAR] <keyword>=</keyword> new Rule(clearExpression, null, PRECEDENCE_NONE)
rules[TOKEN_COLON] <keyword>=</keyword> new Rule(null, null, PRECEDENCE_NONE)
rules[TOKEN_COMMA] <keyword>=</keyword> new Rule(null, null, PRECEDENCE_NONE)
rules[TOKEN_CONTINUE] <keyword>=</keyword> new Rule(null, null, PRECEDENCE_NONE)
rules[TOKEN_COPY] <keyword>=</keyword> new Rule(copyExpression, null, PRECEDENCE_NONE)
rules[TOKEN_OPCODES] <keyword>=</keyword> new Rule(opCodesExpression, null, PRECEDENCE_NONE)
rules[TOKEN_STACK] <keyword>=</keyword> new Rule(stackExpression, null, PRECEDENCE_NONE)
rules[TOKEN_REFERENCE] <keyword>=</keyword> new Rule(referenceExpression, null, PRECEDENCE_NONE)
rules[TOKEN_DELETE] <keyword>=</keyword> new Rule(deleteExpression, null, PRECEDENCE_NONE)
rules[TOKEN_DIVIDE] <keyword>=</keyword> new Rule(null, compileBinary, PRECEDENCE_FACTOR)
rules[TOKEN_DOT] <keyword>=</keyword> new Rule(null, compileDot, PRECEDENCE_CALL)
rules[TOKEN_ECHO] <keyword>=</keyword> new Rule(null, null, PRECEDENCE_NONE)
rules[TOKEN_ELIF] <keyword>=</keyword> new Rule(null, null, PRECEDENCE_NONE)
rules[TOKEN_ELSE] <keyword>=</keyword> new Rule(null, null, PRECEDENCE_NONE)
rules[TOKEN_EOF] <keyword>=</keyword> new Rule(null, null, PRECEDENCE_NONE)
rules[TOKEN_EQUAL] <keyword>=</keyword> new Rule(null, compileBinary, PRECEDENCE_EQUALITY)
rules[TOKEN_ERROR] <keyword>=</keyword> new Rule(null, null, PRECEDENCE_NONE)
rules[TOKEN_EXCEPT] <keyword>=</keyword> new Rule(null, null, PRECEDENCE_NONE)
rules[TOKEN_EXISTS] <keyword>=</keyword> new Rule(existsExpression, null, PRECEDENCE_NONE)
rules[TOKEN_FALSE] <keyword>=</keyword> new Rule(compileFalse, null, PRECEDENCE_NONE)
rules[TOKEN_FLOAT] <keyword>=</keyword> new Rule(compileFloat, null, PRECEDENCE_NONE)
rules[TOKEN_FOR] <keyword>=</keyword> new Rule(null, null, PRECEDENCE_NONE)
rules[TOKEN_FUNCTION] <keyword>=</keyword> new Rule(functionExpression, null, PRECEDENCE_NONE)
rules[TOKEN_GREATER] <keyword>=</keyword> new Rule(null, compileBinary, PRECEDENCE_COMPARE)
rules[TOKEN_GREATER_EQUAL] <keyword>=</keyword> new Rule(null, compileBinary, PRECEDENCE_COMPARE)
rules[TOKEN_IDENT] <keyword>=</keyword> new Rule(compileVariable, null, PRECEDENCE_NONE)
rules[TOKEN_IF] <keyword>=</keyword> new Rule(null, null, PRECEDENCE_NONE)
rules[TOKEN_IN] <keyword>=</keyword> new Rule(null, null, PRECEDENCE_NONE)
rules[TOKEN_INDEX] <keyword>=</keyword> new Rule(indexExpression, null, PRECEDENCE_NONE)
rules[TOKEN_INSERT] <keyword>=</keyword> new Rule(arrayInsertExpression, null, PRECEDENCE_NONE)
rules[TOKEN_SRC] <keyword>=</keyword> new Rule(sourceExpression, null, PRECEDENCE_NONE)
rules[TOKEN_INTEGER] <keyword>=</keyword> new Rule(compileInteger, null, PRECEDENCE_NONE)
rules[TOKEN_KEYS] <keyword>=</keyword> new Rule(keysExpression, null, PRECEDENCE_NONE)
rules[TOKEN_LEFT_CURLY] <keyword>=</keyword> new Rule(compileTable, null, PRECEDENCE_NONE)
rules[TOKEN_LEFT_PAREN] <keyword>=</keyword> new Rule(compileGroup, compileCall, PRECEDENCE_CALL)
rules[TOKEN_LEFT_SQUARE] <keyword>=</keyword> new Rule(compileArray, compileSquare, PRECEDENCE_CALL)
rules[TOKEN_LEN] <keyword>=</keyword> new Rule(lenExpression, null, PRECEDENCE_NONE)
rules[TOKEN_LESS] <keyword>=</keyword> new Rule(null, compileBinary, PRECEDENCE_COMPARE)
rules[TOKEN_LESS_EQUAL] <keyword>=</keyword> new Rule(null, compileBinary, PRECEDENCE_COMPARE)
rules[TOKEN_SET] <keyword>=</keyword> new Rule(null, null, PRECEDENCE_NONE)
rules[TOKEN_MODULO] <keyword>=</keyword> new Rule(null, compileBinary, PRECEDENCE_FACTOR)
rules[TOKEN_MULTIPLY] <keyword>=</keyword> new Rule(null, compileBinary, PRECEDENCE_FACTOR)
rules[TOKEN_NONE] <keyword>=</keyword> new Rule(compileNone, null, PRECEDENCE_NONE)
rules[TOKEN_NOT] <keyword>=</keyword> new Rule(compileUnary, null, PRECEDENCE_NONE)
rules[TOKEN_NOT_EQUAL] <keyword>=</keyword> new Rule(null, compileBinary, PRECEDENCE_EQUALITY)
rules[TOKEN_OR] <keyword>=</keyword> new Rule(null, compileOr, PRECEDENCE_OR)
rules[TOKEN_POINTER] <keyword>=</keyword> new Rule(null, compilePointer, PRECEDENCE_CALL)
rules[TOKEN_POP] <keyword>=</keyword> new Rule(arrayPopExpression, null, PRECEDENCE_NONE)
rules[TOKEN_PRINT] <keyword>=</keyword> new Rule(null, null, PRECEDENCE_NONE)
rules[TOKEN_PUSH] <keyword>=</keyword> new Rule(arrayPushExpression, null, PRECEDENCE_NONE)
rules[TOKEN_RETURN] <keyword>=</keyword> new Rule(null, null, PRECEDENCE_NONE)
rules[TOKEN_RIGHT_CURLY] <keyword>=</keyword> new Rule(null, null, PRECEDENCE_NONE)
rules[TOKEN_RIGHT_PAREN] <keyword>=</keyword> new Rule(null, null, PRECEDENCE_NONE)
rules[TOKEN_RIGHT_SQUARE] <keyword>=</keyword> new Rule(null, null, PRECEDENCE_NONE)
rules[TOKEN_STRING] <keyword>=</keyword> new Rule(compileString, null, PRECEDENCE_NONE)
rules[TOKEN_SUBTRACT] <keyword>=</keyword> new Rule(compileUnary, compileBinary, PRECEDENCE_TERM)
rules[TOKEN_THROW] <keyword>=</keyword> new Rule(null, null, PRECEDENCE_NONE)
rules[TOKEN_TO_FLOAT] <keyword>=</keyword> new Rule(castFloatExpression, null, PRECEDENCE_NONE)
rules[TOKEN_TO_INTEGER] <keyword>=</keyword> new Rule(castIntegerExpression, null, PRECEDENCE_NONE)
rules[TOKEN_TO_STRING] <keyword>=</keyword> new Rule(castStringExpression, null, PRECEDENCE_NONE)
rules[TOKEN_TRUE] <keyword>=</keyword> new Rule(compileTrue, null, PRECEDENCE_NONE)
rules[TOKEN_TRY] <keyword>=</keyword> new Rule(null, null, PRECEDENCE_NONE)
rules[TOKEN_TYPE_FUNC] <keyword>=</keyword> new Rule(typeExpression, null, PRECEDENCE_NONE)
rules[TOKEN_UNDEFINED] <keyword>=</keyword> new Rule(null, null, PRECEDENCE_NONE)
rules[TOKEN_USE] <keyword>=</keyword> new Rule(null, null, PRECEDENCE_NONE)
rules[TOKEN_VALUE] <keyword>=</keyword> new Rule(null, null, PRECEDENCE_NONE)
rules[TOKEN_WHILE] <keyword>=</keyword> new Rule(null, null, PRECEDENCE_NONE)

function valueType(type) {
  <keyword>switch</keyword> (type) {
    <keyword>case</keyword> HYMN_VALUE_NONE:
      <keyword>return</keyword> <string>'none'</string>
    <keyword>case</keyword> HYMN_VALUE_BOOL:
      <keyword>return</keyword> <string>'boolean'</string>
    <keyword>case</keyword> HYMN_VALUE_INTEGER:
      <keyword>return</keyword> <string>'integer'</string>
    <keyword>case</keyword> HYMN_VALUE_FLOAT:
      <keyword>return</keyword> <string>'float'</string>
    <keyword>case</keyword> HYMN_VALUE_STRING:
      <keyword>return</keyword> <string>'string'</string>
    <keyword>case</keyword> HYMN_VALUE_ARRAY:
      <keyword>return</keyword> <string>'array'</string>
    <keyword>case</keyword> HYMN_VALUE_TABLE:
      <keyword>return</keyword> <string>'table'</string>
    <keyword>case</keyword> HYMN_VALUE_FUNC:
      <keyword>return</keyword> <string>'function'</string>
    <keyword>case</keyword> HYMN_VALUE_FUNC_NATIVE:
      <keyword>return</keyword> <string>'native'</string>
    <keyword>case</keyword> HYMN_VALUE_POINTER:
      <keyword>return</keyword> <string>'pointer'</string>
    <keyword>default</keyword>:
      <keyword>return</keyword> <string>'?'</string>
  }
}

function stringMixHashCode(key) {
  <keyword>const</keyword> length <keyword>=</keyword> key.length
  let hash <keyword>=</keyword> <constant>0</constant>
  <keyword>for</keyword> (let i <keyword>=</keyword> <constant>0</constant>; i <keyword>&lt;</keyword> length; i++) {
    hash <keyword>=</keyword> <constant>31</constant><comment> * hash + key.charCodeAt(i)</comment>
    hash |<keyword>=</keyword> <constant>0</constant>
  }
  <keyword>return</keyword> hash <keyword>^</keyword> (hash <keyword>&gt;&gt;</keyword> <constant>16</constant>)
}

function tableGetBin(table, hash) {
  <keyword>return</keyword> (table.bins <keyword>-</keyword> <constant>1</constant>) <keyword>&</keyword> hash
}

function tableResize(table) {
  <keyword>const</keyword> binsOld <keyword>=</keyword> table.bins
  <keyword>const</keyword> bins <keyword>=</keyword> binsOld <keyword>&lt;&lt;</keyword> <constant>1</constant>

  <keyword>if</keyword> (bins <keyword>&gt;</keyword> MAXIMUM_BINS) return

  <keyword>const</keyword> itemsOld <keyword>=</keyword> table.items
  <keyword>const</keyword> items <keyword>=</keyword> new Array(bins).fill(null)

  <keyword>for</keyword> (let i <keyword>=</keyword> <constant>0</constant>; i <keyword>&lt;</keyword> binsOld; i++) {
    let item <keyword>=</keyword> itemsOld[i]
    <keyword>if</keyword> (item <keyword>==</keyword><keyword>=</keyword> null) continue
    <keyword>if</keyword> (item.next <keyword>==</keyword><keyword>=</keyword> null) {
      items[(bins <keyword>-</keyword> <constant>1</constant>) <keyword>&</keyword> item.hash] <keyword>=</keyword> item
    } <keyword>else</keyword> {
      let lowHead <keyword>=</keyword> null
      let lowTail <keyword>=</keyword> null
      let highHead <keyword>=</keyword> null
      let highTail <keyword>=</keyword> null
      do {
        <keyword>if</keyword> ((binsOld <keyword>&</keyword> item.hash) <keyword>==</keyword><keyword>=</keyword> <constant>0</constant>) {
          <keyword>if</keyword> (lowTail <keyword>==</keyword><keyword>=</keyword> null) lowHead <keyword>=</keyword> item
          <keyword>else</keyword> lowTail.next <keyword>=</keyword> item
          lowTail <keyword>=</keyword> item
        } <keyword>else</keyword> {
          <keyword>if</keyword> (highTail <keyword>==</keyword><keyword>=</keyword> null) highHead <keyword>=</keyword> item
          <keyword>else</keyword> highTail.next <keyword>=</keyword> item
          highTail <keyword>=</keyword> item
        }
        item <keyword>=</keyword> item.next
      } <keyword>while</keyword> (item <keyword>!=</keyword><keyword>=</keyword> null)

      <keyword>if</keyword> (lowTail <keyword>!=</keyword><keyword>=</keyword> null) {
        lowTail.next <keyword>=</keyword> null
        items[i] <keyword>=</keyword> lowHead
      }

      <keyword>if</keyword> (highTail <keyword>!=</keyword><keyword>=</keyword> null) {
        highTail.next <keyword>=</keyword> null
        items[i <keyword>+</keyword> binsOld] <keyword>=</keyword> highHead
      }
    }
  }

  table.bins <keyword>=</keyword> bins
  table.items <keyword>=</keyword> items
}

function tablePut(table, key, value) {
  <keyword>const</keyword> hash <keyword>=</keyword> stringMixHashCode(key)
  <keyword>const</keyword> bin <keyword>=</keyword> tableGetBin(table, hash)
  let item <keyword>=</keyword> table.items[bin]
  let previous <keyword>=</keyword> null
  <keyword>while</keyword> (item <keyword>!=</keyword><keyword>=</keyword> null) {
    <keyword>if</keyword> (key <keyword>==</keyword><keyword>=</keyword> item.key) {
      <keyword>const</keyword> old <keyword>=</keyword> item.value
      item.value <keyword>=</keyword> value
      <keyword>return</keyword> old
    }
    previous <keyword>=</keyword> item
    item <keyword>=</keyword> item.next
  }
  item <keyword>=</keyword> new HymnTableItem(hash, key, value)
  <keyword>if</keyword> (previous <keyword>==</keyword><keyword>=</keyword> null) table.items[bin] <keyword>=</keyword> item
  <keyword>else</keyword> previous.next <keyword>=</keyword> item
  table.size++
  <keyword>if</keyword> (table.size <keyword>&gt;</keyword> table.bins <keyword>*</keyword> LOAD_FACTOR) tableResize(table)
  <keyword>return</keyword> null
}

function tableGet(table, key) {
  <keyword>const</keyword> hash <keyword>=</keyword> stringMixHashCode(key)
  <keyword>const</keyword> bin <keyword>=</keyword> tableGetBin(table, hash)
  let item <keyword>=</keyword> table.items[bin]
  <keyword>while</keyword> (item <keyword>!=</keyword><keyword>=</keyword> null) {
    <keyword>if</keyword> (key <keyword>==</keyword><keyword>=</keyword> item.key) <keyword>return</keyword> item.value
    item <keyword>=</keyword> item.next
  }
  <keyword>return</keyword> null
}

function tableNext(table, key) {
  <keyword>const</keyword> bins <keyword>=</keyword> table.bins
  <keyword>if</keyword> (key <keyword>==</keyword><keyword>=</keyword> null) {
    <keyword>for</keyword> (let i <keyword>=</keyword> <constant>0</constant>; i <keyword>&lt;</keyword> bins; i++) {
      <keyword>const</keyword> item <keyword>=</keyword> table.items[i]
      <keyword>if</keyword> (item <keyword>!=</keyword><keyword>=</keyword> null) <keyword>return</keyword> item
    }
    <keyword>return</keyword> null
  }
  <keyword>const</keyword> hash <keyword>=</keyword> stringMixHashCode(key)
  <keyword>const</keyword> bin <keyword>=</keyword> tableGetBin(table, hash)
  {
    let item <keyword>=</keyword> table.items[bin]
    <keyword>while</keyword> (item <keyword>!=</keyword><keyword>=</keyword> null) {
      <keyword>const</keyword> next <keyword>=</keyword> item.next
      <keyword>if</keyword> (key <keyword>==</keyword><keyword>=</keyword> item.key) {
        <keyword>if</keyword> (next <keyword>!=</keyword><keyword>=</keyword> null) <keyword>return</keyword> next
      }
      item <keyword>=</keyword> next
    }
  }
  <keyword>for</keyword> (let i <keyword>=</keyword> bin <keyword>+</keyword> <constant>1</constant>; i <keyword>&lt;</keyword> bins; i++) {
    <keyword>const</keyword> item <keyword>=</keyword> table.items[i]
    <keyword>if</keyword> (item <keyword>!=</keyword><keyword>=</keyword> null) <keyword>return</keyword> item
  }
  <keyword>return</keyword> null
}

function tableRemove(table, key) {
  <keyword>const</keyword> hash <keyword>=</keyword> stringMixHashCode(key)
  <keyword>const</keyword> bin <keyword>=</keyword> tableGetBin(table, hash)
  let item <keyword>=</keyword> table.items[bin]
  let previous <keyword>=</keyword> null
  <keyword>while</keyword> (item <keyword>!=</keyword><keyword>=</keyword> null) {
    <keyword>if</keyword> (key <keyword>==</keyword><keyword>=</keyword> item.key) {
      <keyword>if</keyword> (previous <keyword>==</keyword><keyword>=</keyword> null) table.items[bin] <keyword>=</keyword> item.next
      <keyword>else</keyword> previous.next <keyword>=</keyword> item.next
      <keyword>const</keyword> value <keyword>=</keyword> item.value
      table.size--
      <keyword>return</keyword> value
    }
    previous <keyword>=</keyword> item
    item <keyword>=</keyword> item.next
  }
  <keyword>return</keyword> null
}

function tableClear(table) {
  table.size <keyword>=</keyword> <constant>0</constant>
  <keyword>const</keyword> bins <keyword>=</keyword> table.bins
  <keyword>for</keyword> (let i <keyword>=</keyword> <constant>0</constant>; i <keyword>&lt;</keyword> bins; i++) {
    let item <keyword>=</keyword> table.items[i]
    <keyword>while</keyword> (item <keyword>!=</keyword><keyword>=</keyword> null) {
      <keyword>const</keyword> next <keyword>=</keyword> item.next
      item.next <keyword>=</keyword> null
      item <keyword>=</keyword> next
    }
    table.items[i] <keyword>=</keyword> null
  }
}

function newTableCopy(from) {
  <keyword>const</keyword> copy <keyword>=</keyword> new HymnTable()
  <keyword>const</keyword> bins <keyword>=</keyword> from.bins
  <keyword>for</keyword> (let i <keyword>=</keyword> <constant>0</constant>; i <keyword>&lt;</keyword> bins; i++) {
    let item <keyword>=</keyword> from.items[i]
    <keyword>while</keyword> (item <keyword>!=</keyword><keyword>=</keyword> null) {
      tablePut(copy, item.key, copyValue(item.value))
      item <keyword>=</keyword> item.next
    }
  }
  <keyword>return</keyword> copy
}

function stringCompare(a, b) {
  <keyword>return</keyword> a <keyword>==</keyword><keyword>=</keyword> b ? <constant>0</constant> : a <keyword>&gt;</keyword> b ? <constant>1</constant> : <keyword>-</keyword><constant>1</constant>
}

function tableKeys(table) {
  <keyword>const</keyword> size <keyword>=</keyword> table.size
  <keyword>const</keyword> keys <keyword>=</keyword> new Array(size)
  <keyword>if</keyword> (size <keyword>==</keyword><keyword>=</keyword> <constant>0</constant>) <keyword>return</keyword> keys
  let total <keyword>=</keyword> <constant>0</constant>
  <keyword>const</keyword> bins <keyword>=</keyword> table.bins
  <keyword>for</keyword> (let i <keyword>=</keyword> <constant>0</constant>; i <keyword>&lt;</keyword> bins; i++) {
    let item <keyword>=</keyword> table.items[i]
    <keyword>while</keyword> (item <keyword>!=</keyword><keyword>=</keyword> null) {
      <keyword>const</keyword> key <keyword>=</keyword> item.key
      let insert <keyword>=</keyword> <constant>0</constant>
      <keyword>while</keyword> (insert <keyword>!=</keyword><keyword>=</keyword> total) {
        <keyword>if</keyword> (stringCompare(key, keys[insert].value) <keyword>&lt;</keyword> <constant>0</constant>) {
          <keyword>for</keyword> (let swap <keyword>=</keyword> total; swap <keyword>&gt;</keyword> insert; swap--) {
            keys[swap] <keyword>=</keyword> keys[swap <keyword>-</keyword> <constant>1</constant>]
          }
          break
        }
        insert++
      }
      keys[insert] <keyword>=</keyword> newString(item.key)
      total++
      item <keyword>=</keyword> item.next
    }
  }
  <keyword>return</keyword> keys
}

function tableKeyOf(table, input) {
  let bin <keyword>=</keyword> <constant>0</constant>
  let item <keyword>=</keyword> null

  <keyword>const</keyword> bins <keyword>=</keyword> table.bins
  <keyword>for</keyword> (let i <keyword>=</keyword> <constant>0</constant>; i <keyword>&lt;</keyword> bins; i++) {
    <keyword>const</keyword> start <keyword>=</keyword> table.items[i]
    <keyword>if</keyword> (start) {
      bin <keyword>=</keyword> i
      item <keyword>=</keyword> start
      break
    }
  }

  <keyword>if</keyword> (item <keyword>==</keyword><keyword>=</keyword> null) <keyword>return</keyword> null
  <keyword>if</keyword> (matchValues(input, item.value)) <keyword>return</keyword> item.key

  <keyword>while</keyword> (<constant>true</constant>) {
    item <keyword>=</keyword> item.next
    <keyword>if</keyword> (item <keyword>==</keyword><keyword>=</keyword> null) {
      <keyword>for</keyword> (bin <keyword>=</keyword> bin <keyword>+</keyword> <constant>1</constant>; bin <keyword>&lt;</keyword> bins; bin++) {
        <keyword>const</keyword> start <keyword>=</keyword> table.items[bin]
        <keyword>if</keyword> (start) {
          item <keyword>=</keyword> start
          break
        }
      }
      <keyword>if</keyword> (item <keyword>==</keyword><keyword>=</keyword> null) <keyword>return</keyword> null
    }
    <keyword>if</keyword> (matchValues(input, item.value)) <keyword>return</keyword> item.key
  }
}

function sourceSubstring(C, len, start) {
  <keyword>return</keyword> C.source.substring(start, start <keyword>+</keyword> len)
}

function newNone() {
  <keyword>return</keyword> new HymnValue(HYMN_VALUE_NONE, null)
}

function newBool(boolean) {
  <keyword>return</keyword> new HymnValue(HYMN_VALUE_BOOL, boolean)
}

function newInt(number) {
  <keyword>return</keyword> new HymnValue(HYMN_VALUE_INTEGER, number)
}

function newFloat(number) {
  <keyword>return</keyword> new HymnValue(HYMN_VALUE_FLOAT, number)
}

function newString(string) {
  <keyword>return</keyword> new HymnValue(HYMN_VALUE_STRING, string)
}

function newArrayValue(array) {
  <keyword>return</keyword> new HymnValue(HYMN_VALUE_ARRAY, array)
}

function newTableValue(table) {
  <keyword>return</keyword> new HymnValue(HYMN_VALUE_TABLE, table)
}

function newFuncValue(func) {
  <keyword>return</keyword> new HymnValue(HYMN_VALUE_FUNC, func)
}

function newFuncNativeValue(func) {
  <keyword>return</keyword> new HymnValue(HYMN_VALUE_FUNC_NATIVE, func)
}

function newPointerValue(pointer) {
  <keyword>return</keyword> new HymnValue(HYMN_VALUE_POINTER, pointer)
}

function newFunction(script) {
  <keyword>const</keyword> func <keyword>=</keyword> new HymnFunction()
  func.code <keyword>=</keyword> new HymnByteCode()
  <keyword>if</keyword> (script) func.script <keyword>=</keyword> script
  <keyword>return</keyword> func
}

function newNativeFunction(name, func) {
  <keyword>return</keyword> new HymnNativeFunction(name, func)
}

function isNone(value) {
  <keyword>return</keyword> value.is <keyword>==</keyword><keyword>=</keyword> HYMN_VALUE_NONE
}

function isBool(value) {
  <keyword>return</keyword> value.is <keyword>==</keyword><keyword>=</keyword> HYMN_VALUE_BOOL
}

function isInt(value) {
  <keyword>return</keyword> value.is <keyword>==</keyword><keyword>=</keyword> HYMN_VALUE_INTEGER
}

function isFloat(value) {
  <keyword>return</keyword> value.is <keyword>==</keyword><keyword>=</keyword> HYMN_VALUE_FLOAT
}

function isString(value) {
  <keyword>return</keyword> value.is <keyword>==</keyword><keyword>=</keyword> HYMN_VALUE_STRING
}

function isArray(value) {
  <keyword>return</keyword> value.is <keyword>==</keyword><keyword>=</keyword> HYMN_VALUE_ARRAY
}

function isTable(value) {
  <keyword>return</keyword> value.is <keyword>==</keyword><keyword>=</keyword> HYMN_VALUE_TABLE
}

function isFunc(value) {
  <keyword>return</keyword> value.is <keyword>==</keyword><keyword>=</keyword> HYMN_VALUE_FUNC
}

function isFuncNative(value) {
  <keyword>return</keyword> value.is <keyword>==</keyword><keyword>=</keyword> HYMN_VALUE_FUNC_NATIVE
}

function isPointer(value) {
  <keyword>return</keyword> value.is <keyword>==</keyword><keyword>=</keyword> HYMN_VALUE_POINTER
}

function current(C) {
  <keyword>return</keyword> C.scope.func.code
}

function compileError(C, token, format) {
  <keyword>if</keyword> (C.error <keyword>!=</keyword><keyword>=</keyword> null) return

  let error <keyword>=</keyword> format

  <keyword>if</keyword> (token.type <keyword>!=</keyword><keyword>=</keyword> TOKEN_EOF <keyword>&</keyword><keyword>&</keyword> token.length <keyword>&gt;</keyword> <constant>0</constant>) {
    <keyword>const</keyword> source <keyword>=</keyword> C.source

    let begin <keyword>=</keyword> token.start
    <keyword>while</keyword> (<constant>true</constant>) {
      <keyword>if</keyword> (source[begin] <keyword>==</keyword><keyword>=</keyword> <string>'\n'</string>) {
        begin++
        break
      }
      <keyword>if</keyword> (begin <keyword>==</keyword><keyword>=</keyword> <constant>0</constant>) break
      begin--
    }

    <keyword>while</keyword> (<constant>true</constant>) {
      <keyword>if</keyword> (source[begin] <keyword>!=</keyword><keyword>=</keyword> <string>' '</string> || begin <keyword>==</keyword><keyword>=</keyword> source.length) break
      begin++
    }

    let end <keyword>=</keyword> token.start
    <keyword>while</keyword> (<constant>true</constant>) {
      <keyword>if</keyword> (source[end] <keyword>==</keyword><keyword>=</keyword> <string>'\n'</string> || end <keyword>==</keyword><keyword>=</keyword> source.length) break
      end++
    }

    <keyword>if</keyword> (begin <keyword>&lt;</keyword> end) {
      error <keyword>+</keyword><keyword>=</keyword> <string>'\n  '</string> <keyword>+</keyword> source.substring(begin, end) <keyword>+</keyword> <string>'\n  '</string>
      <keyword>const</keyword> spaces <keyword>=</keyword> token.start <keyword>-</keyword> begin
      <keyword>if</keyword> (spaces <keyword>&gt;</keyword> <constant>0</constant>) <keyword>for</keyword> (let i <keyword>=</keyword> <constant>0</constant>; i <keyword>&lt;</keyword> spaces; i++) error += <string>' '</string>
      <keyword>for</keyword> (let i <keyword>=</keyword> <constant>0</constant>; i <keyword>&lt;</keyword> token.length; i++) error += <string>'^'</string>
    }
  }

  error <keyword>+</keyword><keyword>=</keyword> <string>'\n  at '</string> <keyword>+</keyword> (C.script <keyword>==</keyword><keyword>=</keyword> null ? <string>'script'</string> : C.script) <keyword>+</keyword> <string>':'</string> <keyword>+</keyword> token.row

  C.error <keyword>=</keyword> error

  C.previous.type <keyword>=</keyword> TOKEN_EOF
  C.current.type <keyword>=</keyword> TOKEN_EOF
}

function nextChar(C) {
  <keyword>const</keyword> pos <keyword>=</keyword> C.pos
  <keyword>if</keyword> (pos <keyword>==</keyword><keyword>=</keyword> C.source.length) <keyword>return</keyword> <string>'\0'</string>
  <keyword>const</keyword> c <keyword>=</keyword> C.source[pos]
  C.pos <keyword>=</keyword> pos <keyword>+</keyword> <constant>1</constant>
  <keyword>if</keyword> (c <keyword>==</keyword><keyword>=</keyword> <string>'\n'</string>) {
    C.row++
    C.column <keyword>=</keyword> <constant>0</constant>
  } <keyword>else</keyword> {
    C.column++
  }
  <keyword>return</keyword> c
}

function peekChar(C) {
  <keyword>if</keyword> (C.pos <keyword>==</keyword><keyword>=</keyword> C.source.length) <keyword>return</keyword> <string>'\0'</string>
  <keyword>return</keyword> C.source[C.pos]
}

function peekTwoChar(C) {
  <keyword>if</keyword> (C.pos <keyword>+</keyword> <constant>1</constant> <keyword>&gt;</keyword><keyword>=</keyword> C.source.length) <keyword>return</keyword> <string>'\0'</string>
  <keyword>return</keyword> C.source[C.pos <keyword>+</keyword> <constant>1</constant>]
}

function token(C, type) {
  <keyword>const</keyword> token <keyword>=</keyword> C.current
  token.type <keyword>=</keyword> type
  token.row <keyword>=</keyword> C.row
  token.column <keyword>=</keyword> C.column
  token.start <keyword>=</keyword> C.pos <keyword>-</keyword> <constant>1</constant>
  token.length <keyword>=</keyword> <constant>1</constant>
}

function tokenSpecial(C, type, offset, len) {
  <keyword>const</keyword> token <keyword>=</keyword> C.current
  token.type <keyword>=</keyword> type
  token.row <keyword>=</keyword> C.row
  token.column <keyword>=</keyword> C.column
  token.start <keyword>=</keyword> C.pos <keyword>-</keyword> offset
  token.length <keyword>=</keyword> len
}

function valueToken(C, type, start, end) {
  <keyword>const</keyword> token <keyword>=</keyword> C.current
  token.type <keyword>=</keyword> type
  token.row <keyword>=</keyword> C.row
  token.column <keyword>=</keyword> C.column
  token.start <keyword>=</keyword> start
  token.length <keyword>=</keyword> end <keyword>-</keyword> start
}

function numberToken(C, type, start, end, value) {
  <keyword>const</keyword> token <keyword>=</keyword> C.current
  token.type <keyword>=</keyword> type
  token.row <keyword>=</keyword> C.row
  token.column <keyword>=</keyword> C.column
  token.start <keyword>=</keyword> start
  token.length <keyword>=</keyword> end <keyword>-</keyword> start
  token.number <keyword>=</keyword> value
}

function identTrie(ident, offset, rest, type) {
  <keyword>for</keyword> (let i <keyword>=</keyword> <constant>0</constant>; i <keyword>&lt;</keyword> rest.length; i++) {
    <keyword>if</keyword> (ident[offset <keyword>+</keyword> i] <keyword>!=</keyword><keyword>=</keyword> rest[i]) {
      <keyword>return</keyword> TOKEN_UNDEFINED
    }
  }
  <keyword>return</keyword> type
}

function identKey(ident, size) {
  <keyword>switch</keyword> (ident[<constant>0</constant>]) {
    <keyword>case</keyword> <string>'o'</string>:
      <keyword>if</keyword> (size <keyword>==</keyword><keyword>=</keyword> <constant>2</constant>) <keyword>return</keyword> identTrie(ident, <constant>1</constant>, <string>'r'</string>, TOKEN_OR)
      break
    <keyword>case</keyword> <string>'u'</string>:
      <keyword>if</keyword> (size <keyword>==</keyword><keyword>=</keyword> <constant>3</constant>) <keyword>return</keyword> identTrie(ident, <constant>1</constant>, <string>'se'</string>, TOKEN_USE)
      break
    <keyword>case</keyword> <string>'a'</string>:
      <keyword>if</keyword> (size <keyword>==</keyword><keyword>=</keyword> <constant>3</constant>) <keyword>return</keyword> identTrie(ident, <constant>1</constant>, <string>'nd'</string>, TOKEN_AND)
      break
    <keyword>case</keyword> <string>'n'</string>:
      <keyword>if</keyword> (size <keyword>==</keyword><keyword>=</keyword> <constant>4</constant>) <keyword>return</keyword> identTrie(ident, <constant>1</constant>, <string>'one'</string>, TOKEN_NONE)
      break
    <keyword>case</keyword> <string>'w'</string>:
      <keyword>if</keyword> (size <keyword>==</keyword><keyword>=</keyword> <constant>5</constant>) <keyword>return</keyword> identTrie(ident, <constant>1</constant>, <string>'hile'</string>, TOKEN_WHILE)
      break
    <keyword>case</keyword> <string>'b'</string>:
      <keyword>if</keyword> (size <keyword>==</keyword><keyword>=</keyword> <constant>5</constant>) <keyword>return</keyword> identTrie(ident, <constant>1</constant>, <string>'reak'</string>, TOKEN_BREAK)
      break
    <keyword>case</keyword> <string>'d'</string>:
      <keyword>if</keyword> (size <keyword>==</keyword><keyword>=</keyword> <constant>6</constant>) <keyword>return</keyword> identTrie(ident, <constant>1</constant>, <string>'elete'</string>, TOKEN_DELETE)
      break
    <keyword>case</keyword> <string>'r'</string>:
      <keyword>if</keyword> (size <keyword>==</keyword><keyword>=</keyword> <constant>6</constant>) <keyword>return</keyword> identTrie(ident, <constant>1</constant>, <string>'eturn'</string>, TOKEN_RETURN)
      break
    <keyword>case</keyword> <string>'s'</string>:
      <keyword>if</keyword> (size <keyword>==</keyword><keyword>=</keyword> <constant>3</constant>) {
        <keyword>if</keyword> (ident[<constant>1</constant>] <keyword>==</keyword><keyword>=</keyword> <string>'e'</string> <keyword>&</keyword><keyword>&</keyword> ident[<constant>2</constant>] <keyword>==</keyword><keyword>=</keyword> <string>'t'</string>) <keyword>return</keyword> TOKEN_SET
        <keyword>if</keyword> (ident[<constant>1</constant>] <keyword>==</keyword><keyword>=</keyword> <string>'t'</string> <keyword>&</keyword><keyword>&</keyword> ident[<constant>2</constant>] <keyword>==</keyword><keyword>=</keyword> <string>'r'</string>) <keyword>return</keyword> TOKEN_TO_STRING
      }
      break
    <keyword>case</keyword> <string>'k'</string>:
      <keyword>if</keyword> (size <keyword>==</keyword><keyword>=</keyword> <constant>4</constant>) <keyword>return</keyword> identTrie(ident, <constant>1</constant>, <string>'eys'</string>, TOKEN_KEYS)
      break
    <keyword>case</keyword> <string>'c'</string>:
      <keyword>if</keyword> (size <keyword>==</keyword><keyword>=</keyword> <constant>4</constant>) <keyword>return</keyword> identTrie(ident, <constant>1</constant>, <string>'opy'</string>, TOKEN_COPY)
      <keyword>if</keyword> (size <keyword>==</keyword><keyword>=</keyword> <constant>5</constant>) <keyword>return</keyword> identTrie(ident, <constant>1</constant>, <string>'lear'</string>, TOKEN_CLEAR)
      <keyword>if</keyword> (size <keyword>==</keyword><keyword>=</keyword> <constant>8</constant>) <keyword>return</keyword> identTrie(ident, <constant>1</constant>, <string>'ontinue'</string>, TOKEN_CONTINUE)
      break
    <keyword>case</keyword> <string>'l'</string>:
      <keyword>if</keyword> (size <keyword>==</keyword><keyword>=</keyword> <constant>3</constant>) <keyword>return</keyword> identTrie(ident, <constant>1</constant>, <string>'en'</string>, TOKEN_LEN)
      break
    <keyword>case</keyword> <string>'t'</string>:
      <keyword>if</keyword> (size <keyword>==</keyword><keyword>=</keyword> <constant>3</constant>) <keyword>return</keyword> identTrie(ident, <constant>1</constant>, <string>'ry'</string>, TOKEN_TRY)
      <keyword>if</keyword> (size <keyword>==</keyword><keyword>=</keyword> <constant>5</constant>) <keyword>return</keyword> identTrie(ident, <constant>1</constant>, <string>'hrow'</string>, TOKEN_THROW)
      <keyword>if</keyword> (size <keyword>==</keyword><keyword>=</keyword> <constant>4</constant>) {
        <keyword>if</keyword> (ident[<constant>1</constant>] <keyword>==</keyword><keyword>=</keyword> <string>'r'</string>) <keyword>return</keyword> identTrie(ident, <constant>2</constant>, <string>'ue'</string>, TOKEN_TRUE)
        <keyword>if</keyword> (ident[<constant>1</constant>] <keyword>==</keyword><keyword>=</keyword> <string>'y'</string>) <keyword>return</keyword> identTrie(ident, <constant>2</constant>, <string>'pe'</string>, TOKEN_TYPE_FUNC)
      }
      break
    <keyword>case</keyword> <string>'i'</string>:
      <keyword>if</keyword> (size <keyword>==</keyword><keyword>=</keyword> <constant>3</constant>) <keyword>return</keyword> identTrie(ident, <constant>1</constant>, <string>'nt'</string>, TOKEN_TO_INTEGER)
      <keyword>if</keyword> (size <keyword>==</keyword><keyword>=</keyword> <constant>5</constant>) <keyword>return</keyword> identTrie(ident, <constant>1</constant>, <string>'ndex'</string>, TOKEN_INDEX)
      <keyword>if</keyword> (size <keyword>==</keyword><keyword>=</keyword> <constant>6</constant>) <keyword>return</keyword> identTrie(ident, <constant>1</constant>, <string>'nsert'</string>, TOKEN_INSERT)
      <keyword>if</keyword> (size <keyword>==</keyword><keyword>=</keyword> <constant>2</constant>) {
        <keyword>if</keyword> (ident[<constant>1</constant>] <keyword>==</keyword><keyword>=</keyword> <string>'f'</string>) <keyword>return</keyword> TOKEN_IF
        <keyword>if</keyword> (ident[<constant>1</constant>] <keyword>==</keyword><keyword>=</keyword> <string>'n'</string>) <keyword>return</keyword> TOKEN_IN
      }
      break
    <keyword>case</keyword> <string>'p'</string>:
      <keyword>if</keyword> (size <keyword>==</keyword><keyword>=</keyword> <constant>3</constant>) <keyword>return</keyword> identTrie(ident, <constant>1</constant>, <string>'op'</string>, TOKEN_POP)
      <keyword>if</keyword> (size <keyword>==</keyword><keyword>=</keyword> <constant>5</constant>) <keyword>return</keyword> identTrie(ident, <constant>1</constant>, <string>'rint'</string>, TOKEN_PRINT)
      <keyword>if</keyword> (size <keyword>==</keyword><keyword>=</keyword> <constant>4</constant>) <keyword>return</keyword> identTrie(ident, <constant>1</constant>, <string>'ush'</string>, TOKEN_PUSH)
      break
    <keyword>case</keyword> <string>'e'</string>:
      <keyword>if</keyword> (size <keyword>==</keyword><keyword>=</keyword> <constant>6</constant>) {
        <keyword>if</keyword> (ident[<constant>1</constant>] <keyword>==</keyword><keyword>=</keyword> <string>'x'</string>) {
          <keyword>if</keyword> (ident[<constant>2</constant>] <keyword>==</keyword><keyword>=</keyword> <string>'c'</string>) <keyword>return</keyword> identTrie(ident, <constant>3</constant>, <string>'ept'</string>, TOKEN_EXCEPT)
          <keyword>if</keyword> (ident[<constant>2</constant>] <keyword>==</keyword><keyword>=</keyword> <string>'i'</string>) <keyword>return</keyword> identTrie(ident, <constant>3</constant>, <string>'sts'</string>, TOKEN_EXISTS)
        }
      } <keyword>else</keyword> <keyword>if</keyword> (size <keyword>==</keyword><keyword>=</keyword> <constant>4</constant>) {
        <keyword>if</keyword> (ident[<constant>1</constant>] <keyword>==</keyword><keyword>=</keyword> <string>'l'</string>) {
          <keyword>if</keyword> (ident[<constant>2</constant>] <keyword>==</keyword><keyword>=</keyword> <string>'s'</string>) {
            <keyword>if</keyword> (ident[<constant>3</constant>] <keyword>==</keyword><keyword>=</keyword> <string>'e'</string>) {
              <keyword>return</keyword> TOKEN_ELSE
            }
          } <keyword>else</keyword> <keyword>if</keyword> (ident[<constant>2</constant>] <keyword>==</keyword><keyword>=</keyword> <string>'i'</string> <keyword>&</keyword><keyword>&</keyword> ident[<constant>3</constant>] <keyword>==</keyword><keyword>=</keyword> <string>'f'</string>) {
            <keyword>return</keyword> TOKEN_ELIF
          }
        } <keyword>else</keyword> <keyword>if</keyword> (ident[<constant>1</constant>] <keyword>==</keyword><keyword>=</keyword> <string>'c'</string>) {
          <keyword>return</keyword> identTrie(ident, <constant>2</constant>, <string>'ho'</string>, TOKEN_ECHO)
        }
      }
      break
    <keyword>case</keyword> <string>'f'</string>:
      <keyword>if</keyword> (size <keyword>==</keyword><keyword>=</keyword> <constant>3</constant>) <keyword>return</keyword> identTrie(ident, <constant>1</constant>, <string>'or'</string>, TOKEN_FOR)
      <keyword>if</keyword> (size <keyword>==</keyword><keyword>=</keyword> <constant>4</constant>) <keyword>return</keyword> identTrie(ident, <constant>1</constant>, <string>'unc'</string>, TOKEN_FUNCTION)
      <keyword>if</keyword> (size <keyword>==</keyword><keyword>=</keyword> <constant>5</constant>) {
        <keyword>if</keyword> (ident[<constant>1</constant>] <keyword>==</keyword><keyword>=</keyword> <string>'a'</string>) <keyword>return</keyword> identTrie(ident, <constant>2</constant>, <string>'lse'</string>, TOKEN_FALSE)
        <keyword>if</keyword> (ident[<constant>1</constant>] <keyword>==</keyword><keyword>=</keyword> <string>'l'</string>) <keyword>return</keyword> identTrie(ident, <constant>2</constant>, <string>'oat'</string>, TOKEN_TO_FLOAT)
      }
      break
    <keyword>case</keyword> <string>'_'</string>:
      <keyword>if</keyword> (size <keyword>==</keyword><keyword>=</keyword> <constant>6</constant>) <keyword>return</keyword> identTrie(ident, <constant>1</constant>, <string>'stack'</string>, TOKEN_STACK)
      <keyword>if</keyword> (size <keyword>==</keyword><keyword>=</keyword> <constant>7</constant>) <keyword>return</keyword> identTrie(ident, <constant>1</constant>, <string>'source'</string>, TOKEN_SRC)
      <keyword>if</keyword> (size <keyword>==</keyword><keyword>=</keyword> <constant>8</constant>) <keyword>return</keyword> identTrie(ident, <constant>1</constant>, <string>'opcodes'</string>, TOKEN_OPCODES)
      <keyword>if</keyword> (size <keyword>==</keyword><keyword>=</keyword> <constant>10</constant>) <keyword>return</keyword> identTrie(ident, <constant>1</constant>, <string>'reference'</string>, TOKEN_REFERENCE)
      break
  }
  <keyword>return</keyword> TOKEN_UNDEFINED
}

function pushIdentToken(C, start, end) {
  <keyword>const</keyword> ident <keyword>=</keyword> C.source.substring(start, end)
  <keyword>const</keyword> keyword <keyword>=</keyword> identKey(ident, end <keyword>-</keyword> start)
  <keyword>if</keyword> (keyword <keyword>!=</keyword><keyword>=</keyword> TOKEN_UNDEFINED) {
    valueToken(C, keyword, start, end)
  } <keyword>else</keyword> {
    valueToken(C, TOKEN_IDENT, start, end)
  }
}

function isDigit(c) {
  <keyword>return</keyword> c <keyword>&gt;</keyword><keyword>=</keyword> <string>'0'</string> <keyword>&</keyword><keyword>&</keyword> c <keyword>&lt;</keyword><keyword>=</keyword> <string>'9'</string>
}

function isIdent(c) {
  <keyword>return</keyword> (c <keyword>&gt;</keyword><keyword>=</keyword> <string>'a'</string> <keyword>&</keyword><keyword>&</keyword> c <keyword>&lt;</keyword><keyword>=</keyword> <string>'z'</string>) || (c <keyword>&gt;</keyword><keyword>=</keyword> <string>'A'</string> <keyword>&</keyword><keyword>&</keyword> c <keyword>&lt;</keyword><keyword>=</keyword> <string>'Z'</string>) || (c <keyword>&gt;</keyword><keyword>=</keyword> <string>'0'</string> <keyword>&</keyword><keyword>&</keyword> c <keyword>&lt;</keyword><keyword>=</keyword> <string>'9'</string>) || c <keyword>==</keyword><keyword>=</keyword> <string>'_'</string>
}

function stringStatus(C) {
  let i <keyword>=</keyword> C.pos
  <keyword>const</keyword> source <keyword>=</keyword> C.source
  <keyword>const</keyword> size <keyword>=</keyword> source.length
  let expression <keyword>=</keyword> false
  let brackets <keyword>=</keyword> <constant>1</constant>
  <keyword>while</keyword> (<constant>true</constant>) {
    <keyword>if</keyword> (i <keyword>&gt;</keyword><keyword>=</keyword> size) <keyword>return</keyword> false
    <keyword>switch</keyword> (source[i]) {
      <keyword>case</keyword> <string>'}'</string>:
        <keyword>if</keyword> (brackets <keyword>&gt;</keyword> <constant>1</constant>) {
          expression <keyword>=</keyword> true
          i++
          brackets--
          continue
        }
        <keyword>return</keyword> expression ? STRING_STATUS_BEGIN : STRING_STATUS_CONTINUE
      <keyword>case</keyword> <string>'&quot;'</string>:
        <keyword>return</keyword> STRING_STATUS_NONE
      <keyword>case</keyword> <string>' '</string>:
      <keyword>case</keyword> <string>'\t'</string>:
      <keyword>case</keyword> <string>'\r'</string>:
      <keyword>case</keyword> <string>'\n'</string>:
        i++
        continue
      <keyword>case</keyword> <string>'{'</string>:
        expression <keyword>=</keyword> true
        i++
        brackets++
        continue
      <keyword>default</keyword>:
        expression <keyword>=</keyword> true
        i++
        continue
    }
  }
}

function parseString(C, start) {
  <keyword>while</keyword> (<constant>true</constant>) {
    <keyword>const</keyword> c <keyword>=</keyword> nextChar(C)
    <keyword>if</keyword> (c <keyword>==</keyword><keyword>=</keyword> <string>'\\'</string>) {
      nextChar(C)
    } <keyword>else</keyword> <keyword>if</keyword> (c <keyword>==</keyword><keyword>=</keyword> <string>'$'</string>) {
      <keyword>if</keyword> (peekChar(C) <keyword>==</keyword><keyword>=</keyword> <string>'{'</string>) {
        nextChar(C)
        <keyword>const</keyword> status <keyword>=</keyword> stringStatus(C)
        <keyword>if</keyword> (status <keyword>==</keyword><keyword>=</keyword> STRING_STATUS_BEGIN) {
          C.stringFormat <keyword>=</keyword> <constant>1</constant>
          C.stringStatus <keyword>=</keyword> STRING_STATUS_BEGIN
          <keyword>const</keyword> end <keyword>=</keyword> C.pos <keyword>-</keyword> <constant>2</constant>
          valueToken(C, TOKEN_STRING, start, end)
          return
        } <keyword>else</keyword> <keyword>if</keyword> (status <keyword>==</keyword><keyword>=</keyword> STRING_STATUS_CONTINUE) {
          C.stringStatus <keyword>=</keyword> STRING_STATUS_CONTINUE
          <keyword>const</keyword> end <keyword>=</keyword> C.pos <keyword>-</keyword> <constant>2</constant>
          valueToken(C, TOKEN_STRING, start, end)
          <keyword>while</keyword> (<constant>true</constant>) {
            <keyword>const</keyword> c <keyword>=</keyword> nextChar(C)
            <keyword>if</keyword> (c <keyword>==</keyword><keyword>=</keyword> <string>'}'</string> || c <keyword>==</keyword><keyword>=</keyword> <string>'\0'</string>) return
          }
        } <keyword>else</keyword> {
          continue
        }
      }
    } <keyword>else</keyword> <keyword>if</keyword> (c <keyword>==</keyword><keyword>=</keyword> <string>'&quot;'</string> || c <keyword>==</keyword><keyword>=</keyword> <string>'\0'</string>) {
      break
    }
  }
  <keyword>const</keyword> end <keyword>=</keyword> C.pos <keyword>-</keyword> <constant>1</constant>
  valueToken(C, TOKEN_STRING, start, end)
  return
}

function advance(C) {
  copyToken(C.previous, C.current)
  <keyword>if</keyword> (C.previous.type <keyword>==</keyword><keyword>=</keyword> TOKEN_EOF) {
    return
  }
  <keyword>switch</keyword> (C.stringStatus) {
    <keyword>case</keyword> STRING_STATUS_BEGIN:
      C.stringStatus <keyword>=</keyword> STRING_STATUS_ADD
      token(C, TOKEN_ADD)
      return
    <keyword>case</keyword> STRING_STATUS_ADD:
      C.stringStatus <keyword>=</keyword> STRING_STATUS_NONE
      token(C, TOKEN_LEFT_PAREN)
      return
    <keyword>case</keyword> STRING_STATUS_CLOSE:
      C.stringStatus <keyword>=</keyword> STRING_STATUS_CONTINUE
      token(C, TOKEN_ADD)
      return
    <keyword>case</keyword> STRING_STATUS_CONTINUE: {
      C.stringStatus <keyword>=</keyword> STRING_STATUS_NONE
      <keyword>const</keyword> start <keyword>=</keyword> C.pos
      parseString(C, start)
      return
    }
    <keyword>default</keyword>:
      break
  }
  <keyword>while</keyword> (<constant>true</constant>) {
    let c <keyword>=</keyword> nextChar(C)
    <keyword>switch</keyword> (c) {
      <keyword>case</keyword> <string>' '</string>:
      <keyword>case</keyword> <string>'\t'</string>:
      <keyword>case</keyword> <string>'\r'</string>:
      <keyword>case</keyword> <string>'\n'</string>:
        c <keyword>=</keyword> peekChar(C)
        <keyword>while</keyword> (c <keyword>!=</keyword><keyword>=</keyword> <string>'\0'</string> <keyword>&</keyword><keyword>&</keyword> (c <keyword>==</keyword><keyword>=</keyword> <string>' '</string> || c <keyword>==</keyword><keyword>=</keyword> <string>'\t'</string> || c <keyword>==</keyword><keyword>=</keyword> <string>'\r'</string> || c <keyword>==</keyword><keyword>=</keyword> <string>'\n'</string>)) {
          nextChar(C)
          c <keyword>=</keyword> peekChar(C)
        }
        continue
      <keyword>case</keyword> <string>'#'</string>: {
        nextChar(C)
        c <keyword>=</keyword> peekChar(C)
        <keyword>while</keyword> (c <keyword>!=</keyword><keyword>=</keyword> <string>'\n'</string> <keyword>&</keyword><keyword>&</keyword> c <keyword>!=</keyword><keyword>=</keyword> <string>'\0'</string>) {
          nextChar(C)
          c <keyword>=</keyword> peekChar(C)
        }
        continue
      }
      <keyword>case</keyword> <string>'!'</string>:
        <keyword>if</keyword> (peekChar(C) <keyword>==</keyword><keyword>=</keyword> <string>'='</string>) {
          nextChar(C)
          tokenSpecial(C, TOKEN_NOT_EQUAL, <constant>2</constant>, <constant>2</constant>)
        } <keyword>else</keyword> {
          token(C, TOKEN_NOT)
        }
        return
      <keyword>case</keyword> <string>'='</string>:
        <keyword>if</keyword> (peekChar(C) <keyword>==</keyword><keyword>=</keyword> <string>'='</string>) {
          nextChar(C)
          tokenSpecial(C, TOKEN_EQUAL, <constant>2</constant>, <constant>2</constant>)
        } <keyword>else</keyword> {
          token(C, TOKEN_ASSIGN)
        }
        return
      <keyword>case</keyword> <string>'-'</string>: {
        <keyword>if</keyword> (peekChar(C) <keyword>==</keyword><keyword>=</keyword> <string>'='</string>) {
          nextChar(C)
          tokenSpecial(C, TOKEN_ASSIGN_SUBTRACT, <constant>2</constant>, <constant>2</constant>)
          return
        } <keyword>else</keyword> <keyword>if</keyword> (peekChar(C) <keyword>==</keyword><keyword>=</keyword> <string>'&gt;'</string>) {
          nextChar(C)
          tokenSpecial(C, TOKEN_POINTER, <constant>2</constant>, <constant>2</constant>)
          return
        } <keyword>else</keyword> {
          token(C, TOKEN_SUBTRACT)
          return
        }
      }
      <keyword>case</keyword> <string>'+'</string>:
        <keyword>if</keyword> (peekChar(C) <keyword>==</keyword><keyword>=</keyword> <string>'='</string>) {
          nextChar(C)
          tokenSpecial(C, TOKEN_ASSIGN_ADD, <constant>2</constant>, <constant>2</constant>)
        } <keyword>else</keyword> {
          token(C, TOKEN_ADD)
        }
        return
      <keyword>case</keyword> <string>'*'</string>:
        <keyword>if</keyword> (peekChar(C) <keyword>==</keyword><keyword>=</keyword> <string>'='</string>) {
          nextChar(C)
          tokenSpecial(C, TOKEN_ASSIGN_MULTIPLY, <constant>2</constant>, <constant>2</constant>)
        } <keyword>else</keyword> {
          token(C, TOKEN_MULTIPLY)
        }
        return
      <keyword>case</keyword> <string>'/'</string>:
        <keyword>if</keyword> (peekChar(C) <keyword>==</keyword><keyword>=</keyword> <string>'='</string>) {
          nextChar(C)
          tokenSpecial(C, TOKEN_ASSIGN_DIVIDE, <constant>2</constant>, <constant>2</constant>)
        } <keyword>else</keyword> {
          token(C, TOKEN_DIVIDE)
        }
        return
      <keyword>case</keyword> <string>'%'</string>:
        <keyword>if</keyword> (peekChar(C) <keyword>==</keyword><keyword>=</keyword> <string>'='</string>) {
          nextChar(C)
          tokenSpecial(C, TOKEN_ASSIGN_MODULO, <constant>2</constant>, <constant>2</constant>)
        } <keyword>else</keyword> {
          token(C, TOKEN_MODULO)
        }
        return
      <keyword>case</keyword> <string>'&'</string>:
        <keyword>if</keyword> (peekChar(C) <keyword>==</keyword><keyword>=</keyword> <string>'='</string>) {
          nextChar(C)
          tokenSpecial(C, TOKEN_ASSIGN_BIT_AND, <constant>2</constant>, <constant>2</constant>)
        } <keyword>else</keyword> {
          token(C, TOKEN_BIT_AND)
        }
        return
      <keyword>case</keyword> <string>'|'</string>:
        <keyword>if</keyword> (peekChar(C) <keyword>==</keyword><keyword>=</keyword> <string>'='</string>) {
          nextChar(C)
          tokenSpecial(C, TOKEN_ASSIGN_BIT_OR, <constant>2</constant>, <constant>2</constant>)
        } <keyword>else</keyword> {
          token(C, TOKEN_BIT_OR)
        }
        return
      <keyword>case</keyword> <string>'^'</string>:
        <keyword>if</keyword> (peekChar(C) <keyword>==</keyword><keyword>=</keyword> <string>'='</string>) {
          nextChar(C)
          tokenSpecial(C, TOKEN_ASSIGN_BIT_XOR, <constant>2</constant>, <constant>2</constant>)
        } <keyword>else</keyword> {
          token(C, TOKEN_BIT_XOR)
        }
        return
      <keyword>case</keyword> <string>'&gt;'</string>:
        <keyword>if</keyword> (peekChar(C) <keyword>==</keyword><keyword>=</keyword> <string>'='</string>) {
          nextChar(C)
          tokenSpecial(C, TOKEN_GREATER_EQUAL, <constant>2</constant>, <constant>2</constant>)
        } <keyword>else</keyword> <keyword>if</keyword> (peekChar(C) <keyword>==</keyword><keyword>=</keyword> <string>'&gt;'</string>) {
          nextChar(C)
          <keyword>if</keyword> (peekChar(C) <keyword>==</keyword><keyword>=</keyword> <string>'='</string>) {
            nextChar(C)
            tokenSpecial(C, TOKEN_ASSIGN_BIT_RIGHT_SHIFT, <constant>2</constant>, <constant>2</constant>)
          } <keyword>else</keyword> {
            tokenSpecial(C, TOKEN_BIT_RIGHT_SHIFT, <constant>2</constant>, <constant>2</constant>)
          }
        } <keyword>else</keyword> {
          token(C, TOKEN_GREATER)
        }
        return
      <keyword>case</keyword> <string>'&lt;'</string>:
        <keyword>if</keyword> (peekChar(C) <keyword>==</keyword><keyword>=</keyword> <string>'='</string>) {
          nextChar(C)
          tokenSpecial(C, TOKEN_LESS_EQUAL, <constant>2</constant>, <constant>2</constant>)
        } <keyword>else</keyword> <keyword>if</keyword> (peekChar(C) <keyword>==</keyword><keyword>=</keyword> <string>'&lt;'</string>) {
          nextChar(C)
          <keyword>if</keyword> (peekChar(C) <keyword>==</keyword><keyword>=</keyword> <string>'='</string>) {
            nextChar(C)
            tokenSpecial(C, TOKEN_ASSIGN_BIT_LEFT_SHIFT, <constant>2</constant>, <constant>2</constant>)
          } <keyword>else</keyword> {
            tokenSpecial(C, TOKEN_BIT_LEFT_SHIFT, <constant>2</constant>, <constant>2</constant>)
          }
        } <keyword>else</keyword> {
          token(C, TOKEN_LESS)
        }
        return
      <keyword>case</keyword> <string>'~'</string>:
        token(C, TOKEN_BIT_NOT)
        return
      <keyword>case</keyword> <string>','</string>:
        token(C, TOKEN_COMMA)
        return
      <keyword>case</keyword> <string>'.'</string>:
        token(C, TOKEN_DOT)
        return
      <keyword>case</keyword> <string>'('</string>:
        token(C, TOKEN_LEFT_PAREN)
        return
      <keyword>case</keyword> <string>')'</string>:
        token(C, TOKEN_RIGHT_PAREN)
        return
      <keyword>case</keyword> <string>'['</string>:
        token(C, TOKEN_LEFT_SQUARE)
        return
      <keyword>case</keyword> <string>']'</string>:
        token(C, TOKEN_RIGHT_SQUARE)
        return
      <keyword>case</keyword> <string>'{'</string>:
        <keyword>if</keyword> (C.stringFormat <keyword>&gt;</keyword><keyword>=</keyword> <constant>1</constant>) {
          C.stringFormat++
        }
        token(C, TOKEN_LEFT_CURLY)
        return
      <keyword>case</keyword> <string>'}'</string>:
        <keyword>if</keyword> (C.stringFormat <keyword>==</keyword><keyword>=</keyword> <constant>1</constant>) {
          C.stringFormat <keyword>=</keyword> <constant>0</constant>
          C.stringStatus <keyword>=</keyword> STRING_STATUS_CLOSE
          token(C, TOKEN_RIGHT_PAREN)
          return
        } <keyword>else</keyword> <keyword>if</keyword> (C.stringFormat <keyword>&gt;</keyword> <constant>1</constant>) {
          C.stringFormat--
        }
        token(C, TOKEN_RIGHT_CURLY)
        return
      <keyword>case</keyword> <string>':'</string>:
        token(C, TOKEN_COLON)
        return
      <keyword>case</keyword> <string>'\0'</string>:
        token(C, TOKEN_EOF)
        return
      <keyword>case</keyword> <string>'&quot;'</string>: {
        <keyword>const</keyword> start <keyword>=</keyword> C.pos
        parseString(C, start)
        return
      }
      <keyword>case</keyword> <string>&quot;'&quot;</string>: {
        <keyword>const</keyword> start <keyword>=</keyword> C.pos
        <keyword>while</keyword> (<constant>true</constant>) {
          c <keyword>=</keyword> nextChar(C)
          <keyword>if</keyword> (c <keyword>==</keyword><keyword>=</keyword> <string>'\\'</string>) {
            nextChar(C)
            continue
          } <keyword>else</keyword> <keyword>if</keyword> (c <keyword>==</keyword><keyword>=</keyword> <string>&quot;'&quot;</string> || c <keyword>==</keyword><keyword>=</keyword> <string>'\0'</string>) {
            break
          }
        }
        <keyword>const</keyword> end <keyword>=</keyword> C.pos <keyword>-</keyword> <constant>1</constant>
        valueToken(C, TOKEN_STRING, start, end)
        return
      }
      <keyword>default</keyword>: {
        <keyword>if</keyword> (isDigit(c)) {
          <keyword>const</keyword> start <keyword>=</keyword> C.pos <keyword>-</keyword> <constant>1</constant>
          <keyword>if</keyword> (c <keyword>==</keyword><keyword>=</keyword> <string>'0'</string>) {
            <keyword>const</keyword> p <keyword>=</keyword> peekChar(C)
            <keyword>if</keyword> (p <keyword>==</keyword><keyword>=</keyword> <string>'b'</string>) {
              nextChar(C)
              <keyword>while</keyword> (<constant>true</constant>) {
                c <keyword>=</keyword> peekChar(C)
                <keyword>if</keyword> (c <keyword>!=</keyword><keyword>=</keyword> <string>'0'</string> <keyword>&</keyword><keyword>&</keyword> c <keyword>!=</keyword><keyword>=</keyword> <string>'1'</string>) {
                  break
                }
                nextChar(C)
              }
              <keyword>const</keyword> end <keyword>=</keyword> C.pos
              <keyword>const</keyword> value <keyword>=</keyword> sourceSubstring(C, end <keyword>-</keyword> start <keyword>-</keyword> <constant>2</constant>, start <keyword>+</keyword> <constant>2</constant>)
              numberToken(C, TOKEN_INTEGER, start, end, parseInt(value, <constant>2</constant>))
              return
            } <keyword>else</keyword> <keyword>if</keyword> (p <keyword>==</keyword><keyword>=</keyword> <string>'x'</string>) {
              nextChar(C)
              <keyword>while</keyword> (<constant>true</constant>) {
                c <keyword>=</keyword> peekChar(C)
                <keyword>if</keyword> (<keyword>!</keyword>(c <keyword>&gt;</keyword><keyword>=</keyword> <string>'0'</string> <keyword>&</keyword><keyword>&</keyword> c <keyword>&lt;</keyword><keyword>=</keyword> <string>'9'</string>) <keyword>&</keyword><keyword>&</keyword> <keyword>!</keyword>(c <keyword>&gt;</keyword><keyword>=</keyword> <string>'a'</string> <keyword>&</keyword><keyword>&</keyword> c <keyword>&lt;</keyword><keyword>=</keyword> <string>'f'</string>)) {
                  break
                }
                nextChar(C)
              }
              <keyword>const</keyword> end <keyword>=</keyword> C.pos
              <keyword>const</keyword> value <keyword>=</keyword> sourceSubstring(C, end <keyword>-</keyword> start <keyword>-</keyword> <constant>2</constant>, start <keyword>+</keyword> <constant>2</constant>)
              numberToken(C, TOKEN_INTEGER, start, end, parseInt(value, <constant>16</constant>))
              return
            }
          }
          <keyword>while</keyword> (isDigit(peekChar(C))) {
            nextChar(C)
          }
          <keyword>const</keyword> p <keyword>=</keyword> peekChar(C)
          <keyword>if</keyword> (p <keyword>==</keyword><keyword>=</keyword> <string>'.'</string>) {
            nextChar(C)
            <keyword>while</keyword> (isDigit(peekChar(C))) {
              nextChar(C)
            }
            <keyword>const</keyword> n <keyword>=</keyword> peekChar(C)
            <keyword>if</keyword> (n <keyword>==</keyword><keyword>=</keyword> <string>'e'</string> || n <keyword>==</keyword><keyword>=</keyword> <string>'E'</string>) {
              nextChar(C)
              <keyword>const</keyword> e <keyword>=</keyword> peekChar(C)
              <keyword>if</keyword> (e <keyword>==</keyword><keyword>=</keyword> <string>'-'</string> || e <keyword>==</keyword><keyword>=</keyword> <string>'+'</string>) nextChar(C)
              <keyword>while</keyword> (isDigit(peekChar(C))) {
                nextChar(C)
              }
            }
          } <keyword>else</keyword> <keyword>if</keyword> (p <keyword>==</keyword><keyword>=</keyword> <string>'e'</string> || p <keyword>==</keyword><keyword>=</keyword> <string>'E'</string>) {
            nextChar(C)
            <keyword>const</keyword> n <keyword>=</keyword> peekChar(C)
            <keyword>if</keyword> (n <keyword>==</keyword><keyword>=</keyword> <string>'-'</string> || n <keyword>==</keyword><keyword>=</keyword> <string>'+'</string>) nextChar(C)
            <keyword>while</keyword> (isDigit(peekChar(C))) {
              nextChar(C)
            }
          }
          <keyword>const</keyword> end <keyword>=</keyword> C.pos
          <keyword>const</keyword> value <keyword>=</keyword> sourceSubstring(C, end <keyword>-</keyword> start, start)
          <keyword>const</keyword> number <keyword>=</keyword> Number(value)
          <keyword>if</keyword> (Number.isSafeInteger(number)) numberToken(C, TOKEN_INTEGER, start, end, number)
          <keyword>else</keyword> numberToken(C, TOKEN_FLOAT, start, end, number)
          return
        } <keyword>else</keyword> <keyword>if</keyword> (isIdent(c)) {
          <keyword>const</keyword> start <keyword>=</keyword> C.pos <keyword>-</keyword> <constant>1</constant>
          <keyword>while</keyword> (<constant>true</constant>) {
            c <keyword>=</keyword> peekChar(C)
            <keyword>if</keyword> (isIdent(c)) {
              nextChar(C)
              continue
            } <keyword>else</keyword> <keyword>if</keyword> (c <keyword>==</keyword><keyword>=</keyword> <string>'-'</string>) {
              <keyword>if</keyword> (isIdent(peekTwoChar(C))) {
                nextChar(C)
                nextChar(C)
                continue
              }
            }
            break
          }
          <keyword>const</keyword> end <keyword>=</keyword> C.pos
          pushIdentToken(C, start, end)
          return
        } <keyword>else</keyword> {
          token(C, TOKEN_ERROR)
          compileError(C, C.current, <string>'unknown character: '</string> <keyword>+</keyword> c)
        }
      }
    }
  }
}

function hymnFalse(value) {
  <keyword>switch</keyword> (value.is) {
    <keyword>case</keyword> HYMN_VALUE_NONE:
      <keyword>return</keyword> true
    <keyword>case</keyword> HYMN_VALUE_BOOL:
      <keyword>return</keyword> <keyword>!</keyword>value.value
    <keyword>case</keyword> HYMN_VALUE_INTEGER:
      <keyword>return</keyword> value.value <keyword>==</keyword><keyword>=</keyword> <constant>0</constant>
    <keyword>case</keyword> HYMN_VALUE_FLOAT:
      <keyword>return</keyword> value.value <keyword>==</keyword><keyword>=</keyword> <constant>0.0</constant>
    <keyword>case</keyword> HYMN_VALUE_STRING:
    <keyword>case</keyword> HYMN_VALUE_ARRAY:
      <keyword>return</keyword> value.value.length <keyword>==</keyword><keyword>=</keyword> <constant>0</constant>
    <keyword>case</keyword> HYMN_VALUE_TABLE:
      <keyword>return</keyword> value.value.size <keyword>==</keyword><keyword>=</keyword> <constant>0</constant>
    <keyword>default</keyword>:
      <keyword>return</keyword> false
  }
}

function hymnEqual(a, b) {
  <keyword>switch</keyword> (a.is) {
    <keyword>case</keyword> HYMN_VALUE_NONE:
      <keyword>return</keyword> isNone(b)
    <keyword>case</keyword> HYMN_VALUE_BOOL:
      <keyword>return</keyword> isBool(b) <keyword>&</keyword><keyword>&</keyword> a.value <keyword>==</keyword><keyword>=</keyword> b.value
    <keyword>case</keyword> HYMN_VALUE_INTEGER:
      <keyword>switch</keyword> (b.is) {
        <keyword>case</keyword> HYMN_VALUE_INTEGER:
          <keyword>return</keyword> a.value <keyword>==</keyword><keyword>=</keyword> b.value
        <keyword>case</keyword> HYMN_VALUE_FLOAT:
          <keyword>return</keyword> a.value <keyword>==</keyword><keyword>=</keyword> b.value
        <keyword>default</keyword>:
          <keyword>return</keyword> false
      }
    <keyword>case</keyword> HYMN_VALUE_FLOAT:
      <keyword>switch</keyword> (b.is) {
        <keyword>case</keyword> HYMN_VALUE_INTEGER:
          <keyword>return</keyword> a.value <keyword>==</keyword><keyword>=</keyword> b.value
        <keyword>case</keyword> HYMN_VALUE_FLOAT:
          <keyword>return</keyword> a.value <keyword>==</keyword><keyword>=</keyword> b.value
        <keyword>default</keyword>:
          <keyword>return</keyword> false
      }
    <keyword>case</keyword> HYMN_VALUE_STRING:
    <keyword>case</keyword> HYMN_VALUE_ARRAY:
    <keyword>case</keyword> HYMN_VALUE_TABLE:
    <keyword>case</keyword> HYMN_VALUE_FUNC:
    <keyword>case</keyword> HYMN_VALUE_FUNC_NATIVE:
      <keyword>if</keyword> (b.is <keyword>==</keyword><keyword>=</keyword> a.is) <keyword>return</keyword> a.value <keyword>==</keyword><keyword>=</keyword> b.value
      <keyword>return</keyword> false
    <keyword>default</keyword>:
      <keyword>return</keyword> false
  }
}

function matchValues(a, b) {
  <keyword>if</keyword> (a.is <keyword>!=</keyword><keyword>=</keyword> b.is) <keyword>return</keyword> false
  <keyword>if</keyword> (a.is <keyword>==</keyword><keyword>=</keyword> HYMN_VALUE_NONE) <keyword>return</keyword> true
  <keyword>return</keyword> a.value <keyword>==</keyword><keyword>=</keyword> b.value
}

function scopeGetLocal(scope, index) {
  <keyword>if</keyword> (index <keyword>&lt;</keyword> scope.locals.length) {
    <keyword>return</keyword> scope.locals[index]
  }
  <keyword>const</keyword> local <keyword>=</keyword> new Local()
  scope.locals.push(local)
  <keyword>return</keyword> local
}

function scopeInit(C, scope, type, begin) {
  scope.enclosing <keyword>=</keyword> C.scope
  C.scope <keyword>=</keyword> scope

  scope.localCount <keyword>=</keyword> <constant>0</constant>
  scope.depth <keyword>=</keyword> <constant>0</constant>
  scope.func <keyword>=</keyword> newFunction(C.script)
  scope.type <keyword>=</keyword> type
  scope.begin <keyword>=</keyword> begin

  <keyword>if</keyword> (type <keyword>==</keyword><keyword>=</keyword> TYPE_FUNCTION) {
    scope.func.name <keyword>=</keyword> sourceSubstring(C, C.previous.length, C.previous.start)
  }

  <keyword>const</keyword> local <keyword>=</keyword> scopeGetLocal(scope, scope.localCount++)
  local.depth <keyword>=</keyword> <constant>0</constant>
  local.name <keyword>=</keyword> null
}

function byteCodeNewConstant(C, value) {
  <keyword>const</keyword> code <keyword>=</keyword> current(C)
  <keyword>const</keyword> constants <keyword>=</keyword> code.constants
  <keyword>const</keyword> count <keyword>=</keyword> constants.length
  <keyword>for</keyword> (let c <keyword>=</keyword> <constant>0</constant>; c <keyword>&lt;</keyword> count; c++) {
    <keyword>if</keyword> (matchValues(constants[c], value)) {
      <keyword>return</keyword> c
    }
  }
  constants.push(value)
  <keyword>if</keyword> (count <keyword>&gt;</keyword> UINT8_MAX) {
    compileError(C, C.previous, <string>'too many constants'</string>)
    <keyword>return</keyword> <constant>0</constant>
  }
  <keyword>return</keyword> count
}

function arrayIndexOf(array, input) {
  <keyword>for</keyword> (let i <keyword>=</keyword> <constant>0</constant>; i <keyword>&lt;</keyword> array.length; i++) {
    <keyword>if</keyword> (matchValues(input, array[i])) {
      <keyword>return</keyword> i
    }
  }
  <keyword>return</keyword> <keyword>-</keyword><constant>1</constant>
}

function writeByte(code, byte, row) {
  <keyword>const</keyword> count <keyword>=</keyword> code.count
  <keyword>const</keyword> size <keyword>=</keyword> code.instructions.length
  <keyword>if</keyword> (count <keyword>+</keyword> <constant>1</constant> <keyword>&gt;</keyword> size) {
    <keyword>const</keyword> instructions <keyword>=</keyword> new Uint8Array(size <keyword>*</keyword> <constant>2</constant>)
    <keyword>const</keyword> lines <keyword>=</keyword> new Uint32Array(size <keyword>*</keyword> <constant>2</constant>)
    <keyword>for</keyword> (let i <keyword>=</keyword> <constant>0</constant>; i <keyword>&lt;</keyword> size; i++) instructions[i] = code.instructions[i]
    <keyword>for</keyword> (let i <keyword>=</keyword> <constant>0</constant>; i <keyword>&lt;</keyword> size; i++) lines[i] = code.lines[i]
    code.instructions <keyword>=</keyword> instructions
    code.lines <keyword>=</keyword> lines
  }
  code.instructions[count] <keyword>=</keyword> byte
  code.lines[count] <keyword>=</keyword> row
  code.count <keyword>=</keyword> count <keyword>+</keyword> <constant>1</constant>
}

function emit(C, i) {
  writeByte(current(C), i, C.previous.row)
}

function emitPop(C) {
  <keyword>const</keyword> code <keyword>=</keyword> current(C)
  writeByte(code, OP_POP, C.previous.row)
  C.pop <keyword>=</keyword> code.count
}

function emitShort(C, i, b) {
  <keyword>const</keyword> row <keyword>=</keyword> C.previous.row
  <keyword>const</keyword> code <keyword>=</keyword> current(C)
  writeByte(code, i, row)
  writeByte(code, b, row)
}

function emitWord(C, i, b, n) {
  <keyword>const</keyword> row <keyword>=</keyword> C.previous.row
  <keyword>const</keyword> code <keyword>=</keyword> current(C)
  writeByte(code, i, row)
  writeByte(code, b, row)
  writeByte(code, n, row)
}

function emitConstant(C, value) {
  <keyword>const</keyword> constant <keyword>=</keyword> byteCodeNewConstant(C, value)
  emitShort(C, OP_CONSTANT, constant)
  <keyword>return</keyword> constant
}

function checkAssign(C) {
  <keyword>switch</keyword> (C.current.type) {
    <keyword>case</keyword> TOKEN_ASSIGN:
    <keyword>case</keyword> TOKEN_ASSIGN_ADD:
    <keyword>case</keyword> TOKEN_ASSIGN_BIT_AND:
    <keyword>case</keyword> TOKEN_ASSIGN_BIT_LEFT_SHIFT:
    <keyword>case</keyword> TOKEN_ASSIGN_BIT_OR:
    <keyword>case</keyword> TOKEN_ASSIGN_BIT_RIGHT_SHIFT:
    <keyword>case</keyword> TOKEN_ASSIGN_BIT_XOR:
    <keyword>case</keyword> TOKEN_ASSIGN_DIVIDE:
    <keyword>case</keyword> TOKEN_ASSIGN_MODULO:
    <keyword>case</keyword> TOKEN_ASSIGN_MULTIPLY:
    <keyword>case</keyword> TOKEN_ASSIGN_SUBTRACT:
      <keyword>return</keyword> true
    <keyword>default</keyword>:
      <keyword>return</keyword> false
  }
}

function check(C, type) {
  <keyword>return</keyword> C.current.type <keyword>==</keyword><keyword>=</keyword> type
}

function match(C, type) {
  <keyword>if</keyword> (C.current.type <keyword>!=</keyword><keyword>=</keyword> type) {
    <keyword>return</keyword> false
  }
  advance(C)
  <keyword>return</keyword> true
}

function compileWithPrecedence(C, precedence) {
  advance(C)
  <keyword>const</keyword> rule <keyword>=</keyword> rules[C.previous.type]
  <keyword>const</keyword> prefix <keyword>=</keyword> rule.prefix
  <keyword>if</keyword> (prefix <keyword>==</keyword><keyword>=</keyword> null) {
    compileError(C, C.previous, `expression expected near <string>'${sourceSubstring(C, C.previous.length, C.previous.start)}'</string>`)
    return
  }
  <keyword>const</keyword> assign <keyword>=</keyword> precedence <keyword>&lt;</keyword><keyword>=</keyword> PRECEDENCE_ASSIGN
  prefix(C, assign)
  <keyword>while</keyword> (precedence <keyword>&lt;</keyword><keyword>=</keyword> rules[C.current.type].precedence) {
    advance(C)
    <keyword>const</keyword> infix <keyword>=</keyword> rules[C.previous.type].infix
    <keyword>if</keyword> (infix <keyword>==</keyword><keyword>=</keyword> null) {
      compileError(C, C.previous, <string>'expected infix'</string>)
    }
    infix(C, assign)
  }
  <keyword>if</keyword> (assign <keyword>&</keyword><keyword>&</keyword> checkAssign(C)) {
    advance(C)
    compileError(C, C.current, <string>'invalid assignment'</string>)
  }
}

function consume(C, type, error) {
  <keyword>if</keyword> (C.current.type <keyword>==</keyword><keyword>=</keyword> type) {
    advance(C)
    return
  }
  compileError(C, C.current, error)
}

function pushHiddenLocal(C) {
  <keyword>const</keyword> scope <keyword>=</keyword> C.scope
  <keyword>if</keyword> (scope.localCount <keyword>==</keyword><keyword>=</keyword> HYMN_UINT8_COUNT) {
    compileError(C, C.previous, <string>'too many local variables in scope'</string>)
    <keyword>return</keyword> <constant>0</constant>
  }
  <keyword>const</keyword> index <keyword>=</keyword> scope.localCount++
  <keyword>const</keyword> local <keyword>=</keyword> scopeGetLocal(scope, index)
  local.name <keyword>=</keyword> null
  local.depth <keyword>=</keyword> scope.depth
  <keyword>return</keyword> index
}

function args(C) {
  let count <keyword>=</keyword> <constant>0</constant>
  <keyword>if</keyword> (<keyword>!</keyword>check(C, TOKEN_RIGHT_PAREN)) {
    do {
      expression(C)
      <keyword>if</keyword> (count <keyword>==</keyword><keyword>=</keyword> UINT8_MAX) {
        compileError(C, C.previous, <string>'too many function arguments'</string>)
        break
      }
      count++
    } <keyword>while</keyword> (match(C, TOKEN_COMMA))
  }
  <keyword>if</keyword> (C.current.type <keyword>==</keyword><keyword>=</keyword> TOKEN_RIGHT_PAREN) {
    advance(C)
  } <keyword>else</keyword> {
    compileError(C, C.previous, <string>&quot;function has no closing ')'&quot;</string>)
  }
  <keyword>return</keyword> count
}

function compileCall(C) {
  <keyword>const</keyword> count <keyword>=</keyword> args(C)
  emitShort(C, OP_CALL, count)
}

function compileGroup(C) {
  expression(C)
  <keyword>if</keyword> (C.current.type <keyword>==</keyword><keyword>=</keyword> TOKEN_RIGHT_PAREN) {
    advance(C)
  } <keyword>else</keyword> {
    compileError(C, C.previous, <string>&quot;parenthesis group has no closing ')'&quot;</string>)
  }
}

function compileNone(C) {
  emit(C, OP_NONE)
}

function compileTrue(C) {
  emit(C, OP_TRUE)
}

function compileFalse(C) {
  emit(C, OP_FALSE)
}

function compileInteger(C) {
  emitConstant(C, newInt(C.current.number))
}

function compileFloat(C) {
  emitConstant(C, newFloat(C.current.number))
}

function escapeSequence(c) {
  <keyword>switch</keyword> (c) {
    <keyword>case</keyword> <string>'b'</string>:
      <keyword>return</keyword> <string>'\b'</string>
    <keyword>case</keyword> <string>'f'</string>:
      <keyword>return</keyword> <string>'\f'</string>
    <keyword>case</keyword> <string>'n'</string>:
      <keyword>return</keyword> <string>'\n'</string>
    <keyword>case</keyword> <string>'r'</string>:
      <keyword>return</keyword> <string>'\r'</string>
    <keyword>case</keyword> <string>'t'</string>:
      <keyword>return</keyword> <string>'\t'</string>
    <keyword>case</keyword> <string>'v'</string>:
      <keyword>return</keyword> <string>'\v'</string>
    <keyword>default</keyword>:
      <keyword>return</keyword> c
  }
}

function parseStringLiteral(string, start, len) {
  <keyword>const</keyword> end <keyword>=</keyword> start <keyword>+</keyword> len
  let literal <keyword>=</keyword> <string>''</string>
  <keyword>for</keyword> (let i <keyword>=</keyword> start; i <keyword>&lt;</keyword> end; i++) {
    <keyword>const</keyword> c <keyword>=</keyword> string[i]
    <keyword>if</keyword> (c <keyword>==</keyword><keyword>=</keyword> <string>'\\'</string> <keyword>&</keyword><keyword>&</keyword> i <keyword>+</keyword> <constant>1</constant> <keyword>&lt;</keyword> end) {
      literal <keyword>+</keyword><keyword>=</keyword> escapeSequence(string[i <keyword>+</keyword> <constant>1</constant>])
      i++
    } <keyword>else</keyword> {
      literal <keyword>+</keyword><keyword>=</keyword> c
    }
  }
  <keyword>return</keyword> literal
}

function stringLiteral(C) {
  <keyword>const</keyword> previous <keyword>=</keyword> C.previous
  let string <keyword>=</keyword> parseStringLiteral(C.source, previous.start, previous.length)
  <keyword>while</keyword> (check(C, TOKEN_STRING)) {
    <keyword>const</keyword> current <keyword>=</keyword> C.current
    <keyword>const</keyword> and <keyword>=</keyword> parseStringLiteral(C.source, current.start, current.length)
    string <keyword>+</keyword><keyword>=</keyword> and
    advance(C)
  }
  <keyword>return</keyword> string
}

function compileString(C) {
  emitConstant(C, newString(stringLiteral(C)))
}

function identConstantString(C) {
  <keyword>return</keyword> byteCodeNewConstant(C, newString(stringLiteral(C)))
}

function identConstant(C, token) {
  <keyword>const</keyword> string <keyword>=</keyword> sourceSubstring(C, token.length, token.start)
  <keyword>return</keyword> byteCodeNewConstant(C, newString(string))
}

function beginScope(C) {
  C.scope.depth++
}

function endScope(C) {
  <keyword>const</keyword> scope <keyword>=</keyword> C.scope
  scope.depth--
  <keyword>while</keyword> (scope.localCount <keyword>&gt;</keyword> <constant>0</constant> <keyword>&</keyword><keyword>&</keyword> scope.locals[scope.localCount <keyword>-</keyword> <constant>1</constant>].depth <keyword>&gt;</keyword> scope.depth) {
    emitPop(C)
    scope.localCount--
  }
  C.barrier <keyword>=</keyword> scope.func.code.count
}

function compileArray(C) {
  emit(C, OP_NEW_ARRAY)
  <keyword>if</keyword> (match(C, TOKEN_RIGHT_SQUARE)) {
    return
  }
  <keyword>while</keyword> (<keyword>!</keyword>check(C, TOKEN_RIGHT_SQUARE) <keyword>&</keyword><keyword>&</keyword> <keyword>!</keyword>check(C, TOKEN_EOF)) {
    emit(C, OP_DUPLICATE)
    expression(C)
    emit(C, OP_ARRAY_PUSH)
    emitPop(C)
    <keyword>if</keyword> (<keyword>!</keyword>check(C, TOKEN_RIGHT_SQUARE)) {
      consume(C, TOKEN_COMMA, <string>&quot;expected ',' between array elements&quot;</string>)
    }
  }
  consume(C, TOKEN_RIGHT_SQUARE, <string>&quot;expected ']' at end of array declaration&quot;</string>)
}

function compileTable(C) {
  emit(C, OP_NEW_TABLE)
  <keyword>if</keyword> (match(C, TOKEN_RIGHT_CURLY)) {
    return
  }
  <keyword>while</keyword> (<keyword>!</keyword>check(C, TOKEN_RIGHT_CURLY) <keyword>&</keyword><keyword>&</keyword> <keyword>!</keyword>check(C, TOKEN_EOF)) {
    emit(C, OP_DUPLICATE)
    let name <keyword>=</keyword> UINT8_MAX
    <keyword>if</keyword> (match(C, TOKEN_IDENT)) {
      name <keyword>=</keyword> identConstant(C, C.previous)
    } <keyword>else</keyword> <keyword>if</keyword> (match(C, TOKEN_STRING)) {
      name <keyword>=</keyword> identConstantString(C)
    } <keyword>else</keyword> {
      compileError(C, C.current, <string>'expected table key'</string>)
    }
    consume(C, TOKEN_COLON, <string>&quot;expected ':' between table key and value&quot;</string>)
    expression(C)
    emitShort(C, OP_SET_PROPERTY, name)
    emitPop(C)
    <keyword>if</keyword> (<keyword>!</keyword>check(C, TOKEN_RIGHT_CURLY)) {
      consume(C, TOKEN_COMMA, <string>&quot;expected ',' between table elements&quot;</string>)
    }
  }
  consume(C, TOKEN_RIGHT_CURLY, <string>&quot;expected '}' at end of table declaration&quot;</string>)
}

function pushLocal(C, name) {
  <keyword>const</keyword> scope <keyword>=</keyword> C.scope
  <keyword>if</keyword> (scope.localCount <keyword>==</keyword><keyword>=</keyword> HYMN_UINT8_COUNT) {
    compileError(C, C.previous, <string>'too many local variables in scope'</string>)
    return
  }
  <keyword>const</keyword> local <keyword>=</keyword> scopeGetLocal(scope, scope.localCount++)
  local.name <keyword>=</keyword> name
  local.depth <keyword>=</keyword> <keyword>-</keyword><constant>1</constant>
}

function variable(C, error) {
  consume(C, TOKEN_IDENT, error)
  <keyword>const</keyword> scope <keyword>=</keyword> C.scope
  <keyword>if</keyword> (scope.depth <keyword>==</keyword><keyword>=</keyword> <constant>0</constant>) {
    <keyword>return</keyword> identConstant(C, C.previous)
  }
  <keyword>const</keyword> token <keyword>=</keyword> C.previous
  <keyword>const</keyword> name <keyword>=</keyword> sourceSubstring(C, token.length, token.start)
  <keyword>for</keyword> (let i <keyword>=</keyword> scope.localCount <keyword>-</keyword> <constant>1</constant>; i <keyword>&gt;</keyword><keyword>=</keyword> <constant>0</constant>; i--) {
    <keyword>const</keyword> local <keyword>=</keyword> scope.locals[i]
    <keyword>if</keyword> (local.depth <keyword>!=</keyword><keyword>=</keyword> <keyword>-</keyword><constant>1</constant> <keyword>&</keyword><keyword>&</keyword> local.depth <keyword>&lt;</keyword> scope.depth) {
      break
    } <keyword>else</keyword> <keyword>if</keyword> (name <keyword>==</keyword><keyword>=</keyword> local.name) {
      compileError(C, C.previous, `variable <string>'${name}'</string> already exists in scope`)
    }
  }
  pushLocal(C, name)
  <keyword>return</keyword> <constant>0</constant>
}

function localInitialize(C) {
  <keyword>const</keyword> scope <keyword>=</keyword> C.scope
  <keyword>if</keyword> (scope.depth <keyword>==</keyword><keyword>=</keyword> <constant>0</constant>) {
    return
  }
  scope.locals[scope.localCount <keyword>-</keyword> <constant>1</constant>].depth <keyword>=</keyword> scope.depth
}

function finalizeVariable(C, global) {
  <keyword>if</keyword> (C.scope.depth <keyword>&gt;</keyword> <constant>0</constant>) {
    localInitialize(C)
    return
  }
  emitShort(C, OP_DEFINE_GLOBAL, global)
}

function typeDeclaration(C) {
  <keyword>if</keyword> (match(C, TOKEN_COLON)) {
    <keyword>const</keyword> type <keyword>=</keyword> C.current.type
    <keyword>switch</keyword> (type) {
      <keyword>case</keyword> TOKEN_NONE:
      <keyword>case</keyword> TOKEN_TO_FLOAT:
      <keyword>case</keyword> TOKEN_TO_STRING:
      <keyword>case</keyword> TOKEN_TO_INTEGER:
        advance(C)
        return
      <keyword>default</keyword>:
        compileError(C, C.current, <string>'unavailable type declaration'</string>)
        return
    }
  }
}

function defineNewVariable(C) {
  <keyword>const</keyword> v <keyword>=</keyword> variable(C, <string>'expected a variable name'</string>)
  typeDeclaration(C)
  consume(C, TOKEN_ASSIGN, <string>&quot;expected '=' after variable&quot;</string>)
  expression(C)
  finalizeVariable(C, v)
}

function resolveLocal(C, token) {
  <keyword>const</keyword> name <keyword>=</keyword> sourceSubstring(C, token.length, token.start)
  <keyword>const</keyword> scope <keyword>=</keyword> C.scope
  <keyword>for</keyword> (let i <keyword>=</keyword> scope.localCount <keyword>-</keyword> <constant>1</constant>; i <keyword>&gt;</keyword><keyword>=</keyword> <constant>0</constant>; i--) {
    <keyword>const</keyword> local <keyword>=</keyword> scope.locals[i]
    <keyword>if</keyword> (name <keyword>==</keyword><keyword>=</keyword> local.name) {
      <keyword>if</keyword> (local.depth <keyword>==</keyword><keyword>=</keyword> <keyword>-</keyword><constant>1</constant>) {
        compileError(C, token, `local variable <string>'${name}'</string> referenced before assignment`)
      }
      <keyword>return</keyword> i
    }
  }
  <keyword>return</keyword> <keyword>-</keyword><constant>1</constant>
}

function namedVariable(C, token, assign) {
  let get
  let set
  let v <keyword>=</keyword> resolveLocal(C, token)
  <keyword>if</keyword> (v <keyword>!=</keyword><keyword>=</keyword> <keyword>-</keyword><constant>1</constant>) {
    get <keyword>=</keyword> OP_GET_LOCAL
    set <keyword>=</keyword> OP_SET_LOCAL
  } <keyword>else</keyword> {
    get <keyword>=</keyword> OP_GET_GLOBAL
    set <keyword>=</keyword> OP_SET_GLOBAL
    v <keyword>=</keyword> identConstant(C, token)
  }
  <keyword>if</keyword> (assign <keyword>&</keyword><keyword>&</keyword> checkAssign(C)) {
    <keyword>const</keyword> type <keyword>=</keyword> C.current.type
    advance(C)
    <keyword>if</keyword> (type <keyword>!=</keyword><keyword>=</keyword> TOKEN_ASSIGN) {
      emitShort(C, get, v)
    }
    expression(C)
    <keyword>switch</keyword> (type) {
      <keyword>case</keyword> TOKEN_ASSIGN_ADD:
        emit(C, OP_ADD)
        break
      <keyword>case</keyword> TOKEN_ASSIGN_BIT_AND:
        emit(C, OP_BIT_AND)
        break
      <keyword>case</keyword> TOKEN_ASSIGN_BIT_LEFT_SHIFT:
        emit(C, OP_BIT_LEFT_SHIFT)
        break
      <keyword>case</keyword> TOKEN_ASSIGN_BIT_OR:
        emit(C, OP_BIT_OR)
        break
      <keyword>case</keyword> TOKEN_ASSIGN_BIT_RIGHT_SHIFT:
        emit(C, OP_BIT_RIGHT_SHIFT)
        break
      <keyword>case</keyword> TOKEN_ASSIGN_BIT_XOR:
        emit(C, OP_BIT_XOR)
        break
      <keyword>case</keyword> TOKEN_ASSIGN_DIVIDE:
        emit(C, OP_DIVIDE)
        break
      <keyword>case</keyword> TOKEN_ASSIGN_MODULO:
        emit(C, OP_MODULO)
        break
      <keyword>case</keyword> TOKEN_ASSIGN_MULTIPLY:
        emit(C, OP_MULTIPLY)
        break
      <keyword>case</keyword> TOKEN_ASSIGN_SUBTRACT:
        emit(C, OP_SUBTRACT)
        break
      <keyword>default</keyword>:
        break
    }
    emitShort(C, set, v)
  } <keyword>else</keyword> {
    emitShort(C, get, v)
  }
}

function compileVariable(C, assign) {
  namedVariable(C, C.previous, assign)
}

function compileUnary(C) {
  <keyword>const</keyword> type <keyword>=</keyword> C.previous.type
  compileWithPrecedence(C, PRECEDENCE_UNARY)
  <keyword>switch</keyword> (type) {
    <keyword>case</keyword> TOKEN_NOT:
      emit(C, OP_NOT)
      break
    <keyword>case</keyword> TOKEN_SUBTRACT:
      emit(C, OP_NEGATE)
      break
    <keyword>case</keyword> TOKEN_BIT_NOT:
      emit(C, OP_BIT_NOT)
      break
    <keyword>default</keyword>:
      return
  }
}

function compileBinary(C) {
  <keyword>const</keyword> type <keyword>=</keyword> C.previous.type
  <keyword>const</keyword> rule <keyword>=</keyword> rules[type]
  compileWithPrecedence(C, rule.precedence <keyword>+</keyword> <constant>1</constant>)
  <keyword>switch</keyword> (type) {
    <keyword>case</keyword> TOKEN_ADD:
      emit(C, OP_ADD)
      break
    <keyword>case</keyword> TOKEN_SUBTRACT:
      emit(C, OP_SUBTRACT)
      break
    <keyword>case</keyword> TOKEN_MODULO:
      emit(C, OP_MODULO)
      break
    <keyword>case</keyword> TOKEN_MULTIPLY:
      emit(C, OP_MULTIPLY)
      break
    <keyword>case</keyword> TOKEN_DIVIDE:
      emit(C, OP_DIVIDE)
      break
    <keyword>case</keyword> TOKEN_EQUAL:
      emit(C, OP_EQUAL)
      break
    <keyword>case</keyword> TOKEN_NOT_EQUAL:
      emit(C, OP_NOT_EQUAL)
      break
    <keyword>case</keyword> TOKEN_LESS:
      emit(C, OP_LESS)
      break
    <keyword>case</keyword> TOKEN_LESS_EQUAL:
      emit(C, OP_LESS_EQUAL)
      break
    <keyword>case</keyword> TOKEN_GREATER:
      emit(C, OP_GREATER)
      break
    <keyword>case</keyword> TOKEN_GREATER_EQUAL:
      emit(C, OP_GREATER_EQUAL)
      break
    <keyword>case</keyword> TOKEN_BIT_OR:
      emit(C, OP_BIT_OR)
      break
    <keyword>case</keyword> TOKEN_BIT_AND:
      emit(C, OP_BIT_AND)
      break
    <keyword>case</keyword> TOKEN_BIT_XOR:
      emit(C, OP_BIT_XOR)
      break
    <keyword>case</keyword> TOKEN_BIT_LEFT_SHIFT:
      emit(C, OP_BIT_LEFT_SHIFT)
      break
    <keyword>case</keyword> TOKEN_BIT_RIGHT_SHIFT:
      emit(C, OP_BIT_RIGHT_SHIFT)
      break
    <keyword>default</keyword>:
      return
  }
}

function compileDot(C, assign) {
  consume(C, TOKEN_IDENT, <string>&quot;expected table key after '.'&quot;</string>)
  <keyword>const</keyword> name <keyword>=</keyword> identConstant(C, C.previous)
  <keyword>if</keyword> (assign <keyword>&</keyword><keyword>&</keyword> match(C, TOKEN_ASSIGN)) {
    expression(C)
    emitShort(C, OP_SET_PROPERTY, name)
  } <keyword>else</keyword> {
    emitShort(C, OP_GET_PROPERTY, name)
  }
}

function compilePointer(C) {
  consume(C, TOKEN_IDENT, <string>&quot;expected table key after '-&gt;'&quot;</string>)
  <keyword>const</keyword> name <keyword>=</keyword> identConstant(C, C.previous)
  consume(C, TOKEN_LEFT_PAREN, <string>&quot;expected '(' after function name&quot;</string>)
  emitShort(C, OP_SELF, name)
  <keyword>const</keyword> count <keyword>=</keyword> args(C)
  <keyword>if</keyword> (count <keyword>==</keyword><keyword>=</keyword> UINT8_MAX) {
    compileError(C, C.previous, <string>'too many function arguments'</string>)
    return
  }
  emitShort(C, OP_CALL, count <keyword>+</keyword> <constant>1</constant>)
}

function compileSquare(C, assign) {
  <keyword>if</keyword> (match(C, TOKEN_COLON)) {
    emitConstant(C, newInt(<constant>0</constant>))
    <keyword>if</keyword> (match(C, TOKEN_RIGHT_SQUARE)) {
      emitConstant(C, newNone())
    } <keyword>else</keyword> {
      expression(C)
      consume(C, TOKEN_RIGHT_SQUARE, <string>&quot;expected ']' after square bracket expression&quot;</string>)
    }
    emit(C, OP_SLICE)
  } <keyword>else</keyword> {
    expression(C)
    <keyword>if</keyword> (match(C, TOKEN_COLON)) {
      <keyword>if</keyword> (match(C, TOKEN_RIGHT_SQUARE)) {
        emitConstant(C, newNone())
      } <keyword>else</keyword> {
        expression(C)
        consume(C, TOKEN_RIGHT_SQUARE, <string>&quot;expected ']' after square bracket expression&quot;</string>)
      }
      emit(C, OP_SLICE)
    } <keyword>else</keyword> {
      consume(C, TOKEN_RIGHT_SQUARE, <string>&quot;expected ']' after square bracket expression&quot;</string>)
      <keyword>if</keyword> (assign <keyword>&</keyword><keyword>&</keyword> match(C, TOKEN_ASSIGN)) {
        expression(C)
        emit(C, OP_SET_DYNAMIC)
      } <keyword>else</keyword> {
        emit(C, OP_GET_DYNAMIC)
      }
    }
  }
}

function emitJump(C, instruction) {
  emit(C, instruction)
  emitShort(C, UINT8_MAX, UINT8_MAX)
  <keyword>return</keyword> current(C).count <keyword>-</keyword> <constant>2</constant>
}

function patchJump(C, jump) {
  <keyword>if</keyword> (jump <keyword>==</keyword><keyword>=</keyword> <keyword>-</keyword><constant>1</constant>) {
    return
  }
  <keyword>const</keyword> code <keyword>=</keyword> current(C)
  <keyword>const</keyword> offset <keyword>=</keyword> code.count <keyword>-</keyword> jump <keyword>-</keyword> <constant>2</constant>
  <keyword>if</keyword> (offset <keyword>&gt;</keyword> UINT16_MAX) {
    compileError(C, C.previous, <string>'jump offset too large'</string>)
    return
  }
  code.instructions[jump] <keyword>=</keyword> (offset <keyword>&gt;&gt;</keyword> <constant>8</constant>) <keyword>&</keyword> UINT8_MAX
  code.instructions[jump <keyword>+</keyword> <constant>1</constant>] <keyword>=</keyword> offset <keyword>&</keyword> UINT8_MAX
}

function addJump(C, list, instruction) {
  <keyword>const</keyword> jump <keyword>=</keyword> new JumpList()
  jump.jump <keyword>=</keyword> emitJump(C, instruction)
  jump.depth <keyword>=</keyword> C.scope.depth
  jump.code <keyword>=</keyword> current(C)
  jump.next <keyword>=</keyword> list
  <keyword>return</keyword> jump
}

function freeJumpAndList(C) {
  let jump <keyword>=</keyword> C.jumpAnd
  <keyword>const</keyword> code <keyword>=</keyword> current(C)
  <keyword>const</keyword> depth <keyword>=</keyword> C.scope.depth
  <keyword>while</keyword> (jump <keyword>!=</keyword><keyword>=</keyword> null) {
    <keyword>if</keyword> (jump.code <keyword>!=</keyword><keyword>=</keyword> code || jump.depth <keyword>&lt;</keyword> depth) {
      break
    }
    patchJump(C, jump.jump)
    jump <keyword>=</keyword> jump.next
  }
  C.jumpAnd <keyword>=</keyword> jump
}

function freeJumpOrList(C) {
  let jump <keyword>=</keyword> C.jumpOr
  <keyword>const</keyword> code <keyword>=</keyword> current(C)
  <keyword>const</keyword> depth <keyword>=</keyword> C.scope.depth
  <keyword>while</keyword> (jump <keyword>!=</keyword><keyword>=</keyword> null) {
    <keyword>if</keyword> (jump.code <keyword>!=</keyword><keyword>=</keyword> code || jump.depth <keyword>&lt;</keyword> depth) {
      break
    }
    patchJump(C, jump.jump)
    jump <keyword>=</keyword> jump.next
  }
  C.jumpOr <keyword>=</keyword> jump
}

function freeJumps(C, jump) {
  <keyword>while</keyword> (jump <keyword>!=</keyword><keyword>=</keyword> null) {
    patchJump(C, jump.jump)
    jump <keyword>=</keyword> jump.next
  }
}

function compileAnd(C) {
  C.jumpAnd <keyword>=</keyword> addJump(C, C.jumpAnd, OP_JUMP_IF_FALSE)
  compileWithPrecedence(C, PRECEDENCE_AND)
}

function compileOr(C) {
  C.jumpOr <keyword>=</keyword> addJump(C, C.jumpOr, OP_JUMP_IF_TRUE)
  freeJumpAndList(C)
  compileWithPrecedence(C, PRECEDENCE_OR)
}

function echoIfNone(C) {
  <keyword>const</keyword> code <keyword>=</keyword> C.scope.func.code
  <keyword>const</keyword> count <keyword>=</keyword> code.count
  <keyword>if</keyword> (C.barrier <keyword>==</keyword><keyword>=</keyword> count) return
  <keyword>if</keyword> (C.pop <keyword>==</keyword><keyword>=</keyword> count) code.instructions[count <keyword>-</keyword> <constant>1</constant>] <keyword>=</keyword> OP_ECHO
}

function endFunction(C) {
  <keyword>const</keyword> scope <keyword>=</keyword> C.scope
  <keyword>const</keyword> func <keyword>=</keyword> scope.func
  <keyword>if</keyword> (scope.type <keyword>==</keyword><keyword>=</keyword> TYPE_DIRECT) echoIfNone(C)
  emitShort(C, OP_NONE, OP_RETURN)
  <keyword>if</keyword> (scope.type <keyword>==</keyword><keyword>=</keyword> TYPE_FUNCTION) func.source <keyword>=</keyword> C.source.substring(scope.begin, C.previous.start <keyword>+</keyword> C.previous.length)
  C.scope <keyword>=</keyword> scope.enclosing
  <keyword>return</keyword> func
}

function compileFunction(C, type, begin) {
  <keyword>const</keyword> scope <keyword>=</keyword> new Scope()
  scopeInit(C, scope, type, begin)

  beginScope(C)

  consume(C, TOKEN_LEFT_PAREN, <string>&quot;expected '(' after function name&quot;</string>)

  <keyword>if</keyword> (<keyword>!</keyword>check(C, TOKEN_RIGHT_PAREN)) {
    do {
      C.scope.func.arity++
      <keyword>if</keyword> (C.scope.func.arity <keyword>&gt;</keyword> UINT8_MAX) {
        compileError(C, C.previous, <string>'too many function parameters'</string>)
      }
      <keyword>const</keyword> parameter <keyword>=</keyword> variable(C, <string>'expected parameter name'</string>)
      finalizeVariable(C, parameter)
      typeDeclaration(C)
    } <keyword>while</keyword> (match(C, TOKEN_COMMA))
  }

  consume(C, TOKEN_RIGHT_PAREN, <string>&quot;expected ')' after function parameters&quot;</string>)
  typeDeclaration(C)
  consume(C, TOKEN_LEFT_CURLY, <string>&quot;expected '{' after function parameters&quot;</string>)

  <keyword>while</keyword> (<keyword>!</keyword>check(C, TOKEN_RIGHT_CURLY) <keyword>&</keyword><keyword>&</keyword> <keyword>!</keyword>check(C, TOKEN_EOF)) {
    declaration(C)
  }

  endScope(C)
  consume(C, TOKEN_RIGHT_CURLY, <string>&quot;expected '}' at end of function body&quot;</string>)

  <keyword>const</keyword> func <keyword>=</keyword> endFunction(C)
  emitConstant(C, newFuncValue(func))
}

function functionExpression(C) {
  compileFunction(C, TYPE_FUNCTION, C.previous.start)
}

function declareFunction(C) {
  <keyword>const</keyword> begin <keyword>=</keyword> C.previous.start
  <keyword>const</keyword> global <keyword>=</keyword> variable(C, <string>'expected function name'</string>)
  localInitialize(C)
  compileFunction(C, TYPE_FUNCTION, begin)
  finalizeVariable(C, global)
}

function declaration(C) {
  <keyword>if</keyword> (match(C, TOKEN_SET)) {
    defineNewVariable(C)
  } <keyword>else</keyword> <keyword>if</keyword> (match(C, TOKEN_FUNCTION)) {
    declareFunction(C)
  } <keyword>else</keyword> {
    statement(C)
  }
}

function block(C) {
  beginScope(C)
  <keyword>while</keyword> (<keyword>!</keyword>check(C, TOKEN_RIGHT_CURLY) <keyword>&</keyword><keyword>&</keyword> <keyword>!</keyword>check(C, TOKEN_EOF)) {
    declaration(C)
  }
  endScope(C)
}

function ifStatement(C) {
  expression(C)
  let jump <keyword>=</keyword> emitJump(C, OP_JUMP_IF_FALSE)

  freeJumpOrList(C)

  consume(C, TOKEN_LEFT_CURLY, <string>&quot;expected '{' after if statement&quot;</string>)
  beginScope(C)
  <keyword>while</keyword> (<keyword>!</keyword>check(C, TOKEN_RIGHT_CURLY) <keyword>&</keyword><keyword>&</keyword> <keyword>!</keyword>check(C, TOKEN_EOF)) {
    declaration(C)
  }
  endScope(C)

  consume(C, TOKEN_RIGHT_CURLY, <string>&quot;expected '}' at end of if statement body&quot;</string>)

  <keyword>if</keyword> (check(C, TOKEN_ELIF) || check(C, TOKEN_ELSE)) {
    <keyword>const</keyword> jumpEnd <keyword>=</keyword> new JumpList()
    jumpEnd.jump <keyword>=</keyword> emitJump(C, OP_JUMP)
    let tail <keyword>=</keyword> jumpEnd

    <keyword>while</keyword> (match(C, TOKEN_ELIF)) {
      patchJump(C, jump)
      freeJumpAndList(C)

      expression(C)
      jump <keyword>=</keyword> emitJump(C, OP_JUMP_IF_FALSE)

      freeJumpOrList(C)

      consume(C, TOKEN_LEFT_CURLY, <string>&quot;missing '{' in elif statement&quot;</string>)
      beginScope(C)
      <keyword>while</keyword> (<keyword>!</keyword>check(C, TOKEN_RIGHT_CURLY) <keyword>&</keyword><keyword>&</keyword> <keyword>!</keyword>check(C, TOKEN_EOF)) {
        declaration(C)
      }
      endScope(C)
      consume(C, TOKEN_RIGHT_CURLY, <string>&quot;expected '}' at end of elif statement body&quot;</string>)

      <keyword>const</keyword> next <keyword>=</keyword> new JumpList()
      next.jump <keyword>=</keyword> emitJump(C, OP_JUMP)

      tail.next <keyword>=</keyword> next
      tail <keyword>=</keyword> next
    }

    patchJump(C, jump)
    freeJumpAndList(C)

    <keyword>if</keyword> (match(C, TOKEN_ELSE)) {
      consume(C, TOKEN_LEFT_CURLY, <string>&quot;expected '{' after else statement&quot;</string>)
      block(C)
      consume(C, TOKEN_RIGHT_CURLY, <string>&quot;expected '}' at end of else statement body&quot;</string>)
    }

    patchJump(C, jumpEnd.jump)
    freeJumps(C, jumpEnd.next)
  } <keyword>else</keyword> {
    patchJump(C, jump)
    freeJumpAndList(C)
  }
}

function emitLoop(C, start) {
  emit(C, OP_LOOP)
  <keyword>const</keyword> offset <keyword>=</keyword> current(C).count <keyword>-</keyword> start <keyword>+</keyword> <constant>2</constant>
  <keyword>if</keyword> (offset <keyword>&gt;</keyword> UINT16_MAX) {
    compileError(C, C.previous, <string>'loop is too large'</string>)
  }
  emitShort(C, (offset <keyword>&gt;&gt;</keyword> <constant>8</constant>) <keyword>&</keyword> UINT8_MAX, offset <keyword>&</keyword> UINT8_MAX)
}

function patchJumpList(C) {
  <keyword>while</keyword> (C.jump <keyword>!=</keyword><keyword>=</keyword> null) {
    let depth <keyword>=</keyword> <constant>1</constant>
    <keyword>if</keyword> (C.loop <keyword>!=</keyword><keyword>=</keyword> null) {
      depth <keyword>=</keyword> C.loop.depth <keyword>+</keyword> <constant>1</constant>
    }
    <keyword>if</keyword> (C.jump.depth <keyword>&lt;</keyword> depth) {
      break
    }
    patchJump(C, C.jump.jump)
    C.jump <keyword>=</keyword> C.jump.next
  }
}

function patchJumpForList(C) {
  <keyword>while</keyword> (C.jumpFor <keyword>!=</keyword><keyword>=</keyword> null) {
    let depth <keyword>=</keyword> <constant>1</constant>
    <keyword>if</keyword> (C.loop <keyword>!=</keyword><keyword>=</keyword> null) {
      depth <keyword>=</keyword> C.loop.depth
    }
    <keyword>if</keyword> (C.jumpFor.depth <keyword>&lt;</keyword> depth) {
      break
    }
    patchJump(C, C.jumpFor.jump)
    C.jumpFor <keyword>=</keyword> C.jumpFor.next
  }
}

function iteratorStatement(C, pair) {
  localInitialize(C)

  <keyword>const</keyword> index <keyword>=</keyword> C.scope.localCount
  <keyword>const</keyword> value <keyword>=</keyword> index <keyword>+</keyword> <constant>1</constant>
  <keyword>const</keyword> object <keyword>=</keyword> index <keyword>-</keyword> <constant>1</constant>

  pushHiddenLocal(C)

  <keyword>if</keyword> (pair) {
    variable(C, <string>'expected variable name in for loop'</string>)
    localInitialize(C)
    consume(C, TOKEN_IN, <string>&quot;expected 'in' after variable name in for loop&quot;</string>)
    C.scope.locals[index].name <keyword>=</keyword> C.scope.locals[object].name
  } <keyword>else</keyword> {
    pushHiddenLocal(C)
    C.scope.locals[value].name <keyword>=</keyword> C.scope.locals[object].name
  }

  C.scope.locals[object].name <keyword>=</keyword> null

<comment>  // IN</comment>

  expression(C)

  emitShort(C, OP_FOR, object)
  emitShort(C, UINT8_MAX, UINT8_MAX)

  <keyword>const</keyword> start <keyword>=</keyword> current(C).count
  <keyword>const</keyword> jump <keyword>=</keyword> start <keyword>-</keyword> <constant>2</constant>

  <keyword>const</keyword> loop <keyword>=</keyword> new LoopList(start, C.scope.depth <keyword>+</keyword> <constant>1</constant>, C.loop, <constant>true</constant>)
  C.loop <keyword>=</keyword> loop

<comment>  // BODY</comment>

  consume(C, TOKEN_LEFT_CURLY, <string>&quot;expected '{' after for loop declaration&quot;</string>)
  block(C)

<comment>  // LOOP</comment>

  patchJumpForList(C)
  emitShort(C, OP_FOR_LOOP, object)
  <keyword>const</keyword> offset <keyword>=</keyword> current(C).count <keyword>-</keyword> start <keyword>+</keyword> <constant>2</constant>
  <keyword>if</keyword> (offset <keyword>&gt;</keyword> UINT16_MAX) {
    compileError(C, C.previous, <string>'loop is too large'</string>)
  }
  emitShort(C, (offset <keyword>&gt;&gt;</keyword> <constant>8</constant>) <keyword>&</keyword> UINT8_MAX, offset <keyword>&</keyword> UINT8_MAX)

<comment>  // END</comment>

  C.loop <keyword>=</keyword> loop.next

  patchJump(C, jump)
  patchJumpList(C)

  endScope(C)

  consume(C, TOKEN_RIGHT_CURLY, <string>&quot;expected '}' at end of for loop&quot;</string>)
}

function forStatement(C) {
  beginScope(C)

<comment>  // ASSIGN</comment>

  <keyword>const</keyword> index <keyword>=</keyword> C.scope.localCount

  variable(C, <string>'expected variable name in for loop'</string>)

  <keyword>if</keyword> (match(C, TOKEN_ASSIGN)) {
    expression(C)
    localInitialize(C)
    consume(C, TOKEN_COMMA, <string>&quot;expected ',' in for loop after variable assignment&quot;</string>)
  } <keyword>else</keyword> <keyword>if</keyword> (match(C, TOKEN_COMMA)) {
    iteratorStatement(C, <constant>true</constant>)
    return
  } <keyword>else</keyword> <keyword>if</keyword> (match(C, TOKEN_IN)) {
    iteratorStatement(C, <constant>false</constant>)
    return
  } <keyword>else</keyword> {
    compileError(C, C.previous, <string>'incomplete for loop declaration'</string>)
    return
  }

<comment>  // COMPARE</comment>

  <keyword>const</keyword> compare <keyword>=</keyword> current(C).count

  expression(C)

  <keyword>const</keyword> jump <keyword>=</keyword> emitJump(C, OP_JUMP_IF_FALSE)

<comment>  // INCREMENT</comment>

  <keyword>const</keyword> increment <keyword>=</keyword> current(C).count

  <keyword>const</keyword> loop <keyword>=</keyword> new LoopList(increment, C.scope.depth <keyword>+</keyword> <constant>1</constant>, C.loop, <constant>true</constant>)
  C.loop <keyword>=</keyword> loop

  <keyword>if</keyword> (match(C, TOKEN_COMMA)) {
    expressionStatement(C)
  } <keyword>else</keyword> {
    emitWord(C, OP_INCREMENT_LOCAL_AND_SET, index, <constant>1</constant>)
  }

  <keyword>const</keyword> code <keyword>=</keyword> current(C)

  <keyword>const</keyword> count <keyword>=</keyword> code.count <keyword>-</keyword> increment
  <keyword>const</keyword> instructions <keyword>=</keyword> new Array(count)
  <keyword>const</keyword> lines <keyword>=</keyword> new Array(count)
  <keyword>for</keyword> (let x <keyword>=</keyword> <constant>0</constant>; x <keyword>&lt;</keyword> count; x++) {
    instructions[x] <keyword>=</keyword> code.instructions[increment <keyword>+</keyword> x]
    lines[x] <keyword>=</keyword> code.lines[increment <keyword>+</keyword> x]
  }
  code.count <keyword>=</keyword> increment

<comment>  // BODY</comment>

  consume(C, TOKEN_LEFT_CURLY, <string>&quot;expected '{' after for loop declaration&quot;</string>)
  block(C)

<comment>  // INCREMENT</comment>

  patchJumpForList(C)

  <keyword>const</keyword> position <keyword>=</keyword> code.count
  <keyword>for</keyword> (let x <keyword>=</keyword> <constant>0</constant>; x <keyword>&lt;</keyword> count; x++) {
    code.instructions[position <keyword>+</keyword> x] <keyword>=</keyword> instructions[x]
    code.lines[position <keyword>+</keyword> x] <keyword>=</keyword> lines[x]
  }
  code.count <keyword>+</keyword><keyword>=</keyword> count

  emitLoop(C, compare)

<comment>  // END</comment>

  C.loop <keyword>=</keyword> loop.next

  patchJump(C, jump)
  patchJumpList(C)

  endScope(C)

  consume(C, TOKEN_RIGHT_CURLY, <string>&quot;expected '}' at end of for loop&quot;</string>)
}

function whileStatement(C) {
  <keyword>const</keyword> start <keyword>=</keyword> current(C).count

  <keyword>const</keyword> loop <keyword>=</keyword> new LoopList(start, C.scope.depth <keyword>+</keyword> <constant>1</constant>, C.loop, <constant>false</constant>)
  C.loop <keyword>=</keyword> loop

  expression(C)

  <keyword>const</keyword> jump <keyword>=</keyword> emitJump(C, OP_JUMP_IF_FALSE)

  consume(C, TOKEN_LEFT_CURLY, <string>&quot;expected '{' after while loop declaration&quot;</string>)
  block(C)
  emitLoop(C, start)

  C.loop <keyword>=</keyword> loop.next

  patchJump(C, jump)
  patchJumpList(C)

  consume(C, TOKEN_RIGHT_CURLY, <string>&quot;expected '}' at end of while loop&quot;</string>)
}

function returnStatement(C) {
  <keyword>if</keyword> (C.scope.type <keyword>!=</keyword><keyword>=</keyword> TYPE_FUNCTION) {
    compileError(C, C.previous, <string>'return statement outside of function'</string>)
  }
  <keyword>if</keyword> (check(C, TOKEN_RIGHT_CURLY)) {
    emit(C, OP_NONE)
  } <keyword>else</keyword> {
    expression(C)
  }
  emit(C, OP_RETURN)
}

function popStackLoop(C) {
  <keyword>const</keyword> depth <keyword>=</keyword> C.loop.depth
  <keyword>const</keyword> scope <keyword>=</keyword> C.scope
  <keyword>for</keyword> (let i <keyword>=</keyword> scope.localCount; i <keyword>&gt;</keyword> <constant>0</constant>; i--) {
    <keyword>if</keyword> (scope.locals[i <keyword>-</keyword> <constant>1</constant>].depth <keyword>&lt;</keyword> depth) {
      return
    }
    emitPop(C)
  }
}

function breakStatement(C) {
  <keyword>if</keyword> (C.loop <keyword>==</keyword><keyword>=</keyword> null) {
    compileError(C, C.previous, <string>'break statement outside of loop'</string>)
  }
  popStackLoop(C)
  <keyword>const</keyword> jumpNext <keyword>=</keyword> C.jump
  <keyword>const</keyword> jump <keyword>=</keyword> new JumpList()
  jump.jump <keyword>=</keyword> emitJump(C, OP_JUMP)
  jump.depth <keyword>=</keyword> C.loop.depth
  jump.next <keyword>=</keyword> jumpNext
  C.jump <keyword>=</keyword> jump
}

function continueStatement(C) {
  <keyword>if</keyword> (C.loop <keyword>==</keyword><keyword>=</keyword> null) {
    compileError(C, C.previous, <string>'continue statement outside of loop'</string>)
  }
  popStackLoop(C)
  <keyword>if</keyword> (C.loop.isFor) {
    <keyword>const</keyword> jumpNext <keyword>=</keyword> C.jumpFor
    <keyword>const</keyword> jump <keyword>=</keyword> new JumpList()
    jump.jump <keyword>=</keyword> emitJump(C, OP_JUMP)
    jump.depth <keyword>=</keyword> C.loop.depth
    jump.next <keyword>=</keyword> jumpNext
    C.jumpFor <keyword>=</keyword> jump
  } <keyword>else</keyword> {
    emitLoop(C, C.loop.start)
  }
}

function tryStatement(C) {
  <keyword>const</keyword> except <keyword>=</keyword> new ExceptList()
  except.stack <keyword>=</keyword> C.scope.localCount
  except.start <keyword>=</keyword> current(C).count

  <keyword>const</keyword> func <keyword>=</keyword> C.scope.func
  except.next <keyword>=</keyword> func.except
  func.except <keyword>=</keyword> except

  consume(C, TOKEN_LEFT_CURLY, <string>&quot;expected '{' after try declaration&quot;</string>)
  beginScope(C)
  <keyword>while</keyword> (<keyword>!</keyword>check(C, TOKEN_RIGHT_CURLY) <keyword>&</keyword><keyword>&</keyword> <keyword>!</keyword>check(C, TOKEN_EOF)) {
    declaration(C)
  }
  endScope(C)

  <keyword>const</keyword> jump <keyword>=</keyword> emitJump(C, OP_JUMP)

  consume(C, TOKEN_RIGHT_CURLY, <string>&quot;expected '}' at end of try statement&quot;</string>)
  consume(C, TOKEN_EXCEPT, <string>&quot;expected 'except' at end of try statement&quot;</string>)

  except.end <keyword>=</keyword> current(C).count

  beginScope(C)
  <keyword>const</keyword> message <keyword>=</keyword> variable(C, <string>'expected variable name in exception declaration'</string>)
  finalizeVariable(C, message)
  consume(C, TOKEN_LEFT_CURLY, <string>&quot;expected '{' after exception declaration&quot;</string>)
  <keyword>while</keyword> (<keyword>!</keyword>check(C, TOKEN_RIGHT_CURLY) <keyword>&</keyword><keyword>&</keyword> <keyword>!</keyword>check(C, TOKEN_EOF)) {
    declaration(C)
  }
  endScope(C)

  consume(C, TOKEN_RIGHT_CURLY, <string>&quot;expected '}' at end of exception statement&quot;</string>)

  patchJump(C, jump)
}

function echoStatement(C) {
  expression(C)
  emit(C, OP_ECHO)
}

function printStatement(C) {
  consume(C, TOKEN_LEFT_PAREN, `expected opening <string>'('</string> in call to <string>'print'</string>`)
  expression(C)
  consume(C, TOKEN_COMMA, `not enough arguments in call to <string>'print'</string> (expected <constant>2</constant>)`)
  expression(C)
  consume(C, TOKEN_RIGHT_PAREN, `expected closing <string>')'</string> in call to <string>'print'</string>`)
  emit(C, OP_PRINT)
}

function useStatement(C) {
  expression(C)
  emit(C, OP_USE)
}

function throwStatement(C) {
  expression(C)
  emit(C, OP_THROW)
}

function statement(C) {
  <keyword>if</keyword> (match(C, TOKEN_ECHO)) {
    echoStatement(C)
  } <keyword>else</keyword> <keyword>if</keyword> (match(C, TOKEN_PRINT)) {
    printStatement(C)
  } <keyword>else</keyword> <keyword>if</keyword> (match(C, TOKEN_USE)) {
    useStatement(C)
  } <keyword>else</keyword> <keyword>if</keyword> (match(C, TOKEN_IF)) {
    ifStatement(C)
  } <keyword>else</keyword> <keyword>if</keyword> (match(C, TOKEN_FOR)) {
    forStatement(C)
  } <keyword>else</keyword> <keyword>if</keyword> (match(C, TOKEN_WHILE)) {
    whileStatement(C)
  } <keyword>else</keyword> <keyword>if</keyword> (match(C, TOKEN_RETURN)) {
    returnStatement(C)
  } <keyword>else</keyword> <keyword>if</keyword> (match(C, TOKEN_BREAK)) {
    breakStatement(C)
  } <keyword>else</keyword> <keyword>if</keyword> (match(C, TOKEN_CONTINUE)) {
    continueStatement(C)
  } <keyword>else</keyword> <keyword>if</keyword> (match(C, TOKEN_TRY)) {
    tryStatement(C)
  } <keyword>else</keyword> <keyword>if</keyword> (match(C, TOKEN_THROW)) {
    throwStatement(C)
  } <keyword>else</keyword> <keyword>if</keyword> (match(C, TOKEN_LEFT_CURLY)) {
    block(C)
    consume(C, TOKEN_RIGHT_CURLY, <string>&quot;expected '}' at end of block statement&quot;</string>)
  } <keyword>else</keyword> {
    expressionStatement(C)
  }
}

function arrayPushExpression(C) {
  consume(C, TOKEN_LEFT_PAREN, `expected opening <string>'('</string> in call to <string>'push'</string>`)
  expression(C)
  consume(C, TOKEN_COMMA, `not enough arguments in call to <string>'push'</string> (expected <constant>2</constant>)`)
  expression(C)
  consume(C, TOKEN_RIGHT_PAREN, `expected closing <string>')'</string> in call to <string>'push'</string>`)
  emit(C, OP_ARRAY_PUSH)
}

function arrayInsertExpression(C) {
  consume(C, TOKEN_LEFT_PAREN, `expected opening <string>'('</string> in call to <string>'insert'</string>`)
  expression(C)
  consume(C, TOKEN_COMMA, `not enough arguments in call to <string>'insert'</string> (expected <constant>3</constant>)`)
  expression(C)
  consume(C, TOKEN_COMMA, `not enough arguments in call to <string>'insert'</string> (expected <constant>3</constant>)`)
  expression(C)
  consume(C, TOKEN_RIGHT_PAREN, `expected closing <string>')'</string> in call to <string>'insert'</string>`)
  emit(C, OP_INSERT)
}

function arrayPopExpression(C) {
  consume(C, TOKEN_LEFT_PAREN, `expected opening <string>'('</string> in call to <string>'pop'</string>`)
  expression(C)
  consume(C, TOKEN_RIGHT_PAREN, `expected closing <string>')'</string> in call to <string>'pop'</string>`)
  emit(C, OP_ARRAY_POP)
}

function deleteExpression(C) {
  consume(C, TOKEN_LEFT_PAREN, `expected opening <string>'('</string> in call to <string>'delete'</string>`)
  expression(C)
  consume(C, TOKEN_COMMA, `not enough arguments in call to <string>'delete'</string> (expected <constant>2</constant>)`)
  expression(C)
  consume(C, TOKEN_RIGHT_PAREN, `expected closing <string>')'</string> in call to <string>'delete'</string>`)
  emit(C, OP_DELETE)
}

function lenExpression(C) {
  consume(C, TOKEN_LEFT_PAREN, `expected opening <string>'('</string> in call to <string>'len'</string>`)
  expression(C)
  consume(C, TOKEN_RIGHT_PAREN, `expected closing <string>')'</string> in call to <string>'len'</string>`)
  emit(C, OP_LEN)
}

function castIntegerExpression(C) {
  consume(C, TOKEN_LEFT_PAREN, `expected opening <string>'('</string> in call to <string>'int'</string>`)
  expression(C)
  consume(C, TOKEN_RIGHT_PAREN, `expected closing <string>')'</string> in call to <string>'int'</string>`)
  emit(C, OP_INT)
}

function castFloatExpression(C) {
  consume(C, TOKEN_LEFT_PAREN, `expected opening <string>'('</string> in call to <string>'float'</string>`)
  expression(C)
  consume(C, TOKEN_RIGHT_PAREN, `expected closing <string>')'</string> in call to <string>'float'</string>`)
  emit(C, OP_FLOAT)
}

function castStringExpression(C) {
  consume(C, TOKEN_LEFT_PAREN, `expected opening <string>'('</string> in call to <string>'str'</string>`)
  expression(C)
  consume(C, TOKEN_RIGHT_PAREN, `expected closing <string>')'</string> in call to <string>'str'</string>`)
  emit(C, OP_STRING)
}

function typeExpression(C) {
  consume(C, TOKEN_LEFT_PAREN, `expected opening <string>'('</string> in call to <string>'type'</string>`)
  expression(C)
  consume(C, TOKEN_RIGHT_PAREN, `expected closing <string>')'</string> in call to <string>'type'</string>`)
  emit(C, OP_TYPE)
}

function clearExpression(C) {
  consume(C, TOKEN_LEFT_PAREN, `expected opening <string>'('</string> in call to <string>'clear'</string>`)
  expression(C)
  consume(C, TOKEN_RIGHT_PAREN, `expected closing <string>')'</string> in call to <string>'clear'</string>`)
  emit(C, OP_CLEAR)
}

function copyExpression(C) {
  consume(C, TOKEN_LEFT_PAREN, `expected opening <string>'('</string> in call to <string>'copy'</string>`)
  expression(C)
  consume(C, TOKEN_RIGHT_PAREN, `expected closing <string>')'</string> in call to <string>'copy'</string>`)
  emit(C, OP_COPY)
}

function keysExpression(C) {
  consume(C, TOKEN_LEFT_PAREN, `expected opening <string>'('</string> in call to <string>'keys'</string>`)
  expression(C)
  consume(C, TOKEN_RIGHT_PAREN, `expected closing <string>')'</string> in call to <string>'keys'</string>`)
  emit(C, OP_KEYS)
}

function indexExpression(C) {
  consume(C, TOKEN_LEFT_PAREN, `expected opening <string>'('</string> in call to <string>'index'</string>`)
  expression(C)
  consume(C, TOKEN_COMMA, `not enough arguments in call to <string>'index'</string> (expected <constant>2</constant>)`)
  expression(C)
  consume(C, TOKEN_RIGHT_PAREN, `expected closing <string>')'</string> in call to <string>'index'</string>`)
  emit(C, OP_INDEX)
}

function existsExpression(C) {
  consume(C, TOKEN_LEFT_PAREN, `expected opening <string>'('</string> in call to <string>'exists'</string>`)
  expression(C)
  consume(C, TOKEN_COMMA, `not enough arguments in call to <string>'exists'</string> (expected <constant>2</constant>)`)
  expression(C)
  consume(C, TOKEN_RIGHT_PAREN, `expected closing <string>')'</string> in call to <string>'exists'</string>`)
  emit(C, OP_EXISTS)
}

function sourceExpression(C) {
  consume(C, TOKEN_LEFT_PAREN, `expected opening <string>'('</string> in call to <string>'_source'</string>`)
  expression(C)
  consume(C, TOKEN_RIGHT_PAREN, `expected closing <string>')'</string> in call to <string>'_source'</string>`)
  emit(C, OP_SOURCE)
}

function opCodesExpression(C) {
  consume(C, TOKEN_LEFT_PAREN, `expected opening <string>'('</string> in call to <string>'_opcodes'</string>`)
  expression(C)
  consume(C, TOKEN_RIGHT_PAREN, `expected closing <string>')'</string> in call to <string>'_opcodes'</string>`)
  emit(C, OP_CODES)
}

function stackExpression(C) {
  consume(C, TOKEN_LEFT_PAREN, `expected opening <string>'('</string> in call to <string>'_stack'</string>`)
  consume(C, TOKEN_RIGHT_PAREN, `expected closing <string>')'</string> in call to <string>'_stack'</string>`)
  emit(C, OP_STACK)
}

function referenceExpression(C) {
  consume(C, TOKEN_LEFT_PAREN, `expected opening <string>'('</string> in call to <string>'_reference'</string>`)
  expression(C)
  consume(C, TOKEN_RIGHT_PAREN, `expected closing <string>')'</string> in call to <string>'_reference'</string>`)
  emit(C, OP_REFERENCE)
}

function expressionStatement(C) {
  expression(C)
  emitPop(C)
}

function expression(C) {
  compileWithPrecedence(C, PRECEDENCE_ASSIGN)
}

function parentFrame(H, offset) {
  <keyword>const</keyword> frameCount <keyword>=</keyword> H.frameCount
  <keyword>if</keyword> (offset <keyword>&gt;</keyword> frameCount) {
    <keyword>return</keyword> null
  }
  <keyword>return</keyword> H.frames[frameCount <keyword>-</keyword> offset]
}

function currentFrame(H) {
  <keyword>return</keyword> H.frames[H.frameCount <keyword>-</keyword> <constant>1</constant>]
}

function compile(H, script, source, type) {
  <keyword>const</keyword> scope <keyword>=</keyword> new Scope()
  <keyword>const</keyword> C <keyword>=</keyword> new Compiler(script, source, H)
  scopeInit(C, scope, type, <constant>0</constant>)

  advance(C)
  <keyword>while</keyword> (<keyword>!</keyword>match(C, TOKEN_EOF)) {
    declaration(C)
  }

  <keyword>const</keyword> func <keyword>=</keyword> endFunction(C)
  <keyword>return</keyword> { func: func, error: C.error }
}

function quoteString(string) {
  let quoted <keyword>=</keyword> <string>'&quot;'</string>
  <keyword>const</keyword> size <keyword>=</keyword> string.length
  <keyword>for</keyword> (let i <keyword>=</keyword> <constant>0</constant>; i <keyword>&lt;</keyword> size; i++) {
    <keyword>const</keyword> c <keyword>=</keyword> string[i]
    <keyword>if</keyword> (c <keyword>==</keyword><keyword>=</keyword> <string>'\\'</string>) {
      quoted <keyword>+</keyword><keyword>=</keyword> <string>'\\\\'</string>
    } <keyword>else</keyword> <keyword>if</keyword> (c <keyword>==</keyword><keyword>=</keyword> <string>'&quot;'</string>) {
      quoted <keyword>+</keyword><keyword>=</keyword> <string>'\\&quot;'</string>
    } <keyword>else</keyword> {
      quoted <keyword>+</keyword><keyword>=</keyword> c
    }
  }
  <keyword>return</keyword> quoted <keyword>+</keyword> <string>'&quot;'</string>
}

function valueToStringRecursive(value, set, quote) {
  <keyword>switch</keyword> (value.is) {
    <keyword>case</keyword> HYMN_VALUE_NONE:
      <keyword>return</keyword> <string>'none'</string>
    <keyword>case</keyword> HYMN_VALUE_BOOL:
      <keyword>return</keyword> value.value ? <string>'true'</string> : <string>'false'</string>
    <keyword>case</keyword> HYMN_VALUE_INTEGER:
    <keyword>case</keyword> HYMN_VALUE_FLOAT:
    <keyword>case</keyword> HYMN_VALUE_POINTER:
      <keyword>return</keyword> String(value.value)
    <keyword>case</keyword> HYMN_VALUE_STRING:
      <keyword>if</keyword> (quote) {
        <keyword>return</keyword> quoteString(value.value)
      }
      <keyword>return</keyword> value.value
    <keyword>case</keyword> HYMN_VALUE_ARRAY: {
      <keyword>const</keyword> array <keyword>=</keyword> value.value
      <keyword>if</keyword> (<keyword>!</keyword>array || array.length <keyword>==</keyword><keyword>=</keyword> <constant>0</constant>) {
        <keyword>return</keyword> <string>'[]'</string>
      }
      <keyword>if</keyword> (set <keyword>==</keyword><keyword>=</keyword> null) {
        set <keyword>=</keyword> new Set()
      } <keyword>else</keyword> <keyword>if</keyword> (set.has(array)) {
        <keyword>return</keyword> <string>'[..]'</string>
      }
      set.add(array)
      let print <keyword>=</keyword> <string>'['</string>
      <keyword>for</keyword> (let i <keyword>=</keyword> <constant>0</constant>; i <keyword>&lt;</keyword> array.length; i++) {
        <keyword>const</keyword> item <keyword>=</keyword> array[i]
        <keyword>if</keyword> (i <keyword>!=</keyword><keyword>=</keyword> <constant>0</constant>) {
          print <keyword>+</keyword><keyword>=</keyword> <string>', '</string>
        }
        print <keyword>+</keyword><keyword>=</keyword> valueToStringRecursive(item, set, <constant>true</constant>)
      }
      print <keyword>+</keyword><keyword>=</keyword> <string>']'</string>
      <keyword>return</keyword> print
    }
    <keyword>case</keyword> HYMN_VALUE_TABLE: {
      <keyword>const</keyword> table <keyword>=</keyword> value.value
      <keyword>if</keyword> (<keyword>!</keyword>table || table.size <keyword>==</keyword><keyword>=</keyword> <constant>0</constant>) {
        <keyword>return</keyword> <string>'{}'</string>
      }
      <keyword>if</keyword> (set <keyword>==</keyword><keyword>=</keyword> null) {
        set <keyword>=</keyword> new Set()
      } <keyword>else</keyword> <keyword>if</keyword> (set.has(table)) {
        <keyword>return</keyword> <string>'{ .. }'</string>
      }
      set.add(table)
      <keyword>const</keyword> size <keyword>=</keyword> table.size
      <keyword>const</keyword> keys <keyword>=</keyword> new Array(size)
      let total <keyword>=</keyword> <constant>0</constant>
      <keyword>const</keyword> bins <keyword>=</keyword> table.bins
      <keyword>for</keyword> (let i <keyword>=</keyword> <constant>0</constant>; i <keyword>&lt;</keyword> bins; i++) {
        let item <keyword>=</keyword> table.items[i]
        <keyword>while</keyword> (item <keyword>!=</keyword><keyword>=</keyword> null) {
          <keyword>const</keyword> key <keyword>=</keyword> item.key
          let insert <keyword>=</keyword> <constant>0</constant>
          <keyword>while</keyword> (insert <keyword>!=</keyword><keyword>=</keyword> total) {
            <keyword>if</keyword> (stringCompare(key, keys[insert]) <keyword>&lt;</keyword> <constant>0</constant>) {
              <keyword>for</keyword> (let swap <keyword>=</keyword> total; swap <keyword>&gt;</keyword> insert; swap--) {
                keys[swap] <keyword>=</keyword> keys[swap <keyword>-</keyword> <constant>1</constant>]
              }
              break
            }
            insert++
          }
          keys[insert] <keyword>=</keyword> item.key
          total++
          item <keyword>=</keyword> item.next
        }
      }
      let print <keyword>=</keyword> <string>'{ '</string>
      <keyword>for</keyword> (let i <keyword>=</keyword> <constant>0</constant>; i <keyword>&lt;</keyword> size; i++) {
        <keyword>if</keyword> (i <keyword>!=</keyword><keyword>=</keyword> <constant>0</constant>) {
          print <keyword>+</keyword><keyword>=</keyword> <string>', '</string>
        }
        <keyword>const</keyword> key <keyword>=</keyword> keys[i]
        <keyword>const</keyword> item <keyword>=</keyword> tableGet(table, key)
        print <keyword>+</keyword><keyword>=</keyword> quoteString(key) <keyword>+</keyword> <string>': '</string> <keyword>+</keyword> valueToStringRecursive(item, set, <constant>true</constant>)
      }
      print <keyword>+</keyword><keyword>=</keyword> <string>' }'</string>
      <keyword>return</keyword> print
    }
    <keyword>case</keyword> HYMN_VALUE_FUNC: {
      <keyword>const</keyword> func <keyword>=</keyword> value.value
      <keyword>if</keyword> (func.name) <keyword>return</keyword> func.name
      <keyword>if</keyword> (func.script) <keyword>return</keyword> func.script
      <keyword>return</keyword> <string>'script'</string>
    }
    <keyword>case</keyword> HYMN_VALUE_FUNC_NATIVE:
      <keyword>return</keyword> value.value.name
  }
}

function valueToString(value) {
  <keyword>return</keyword> valueToStringRecursive(value, null, <constant>false</constant>)
}

function valueToInspect(value) {
  <keyword>if</keyword> (value.is <keyword>==</keyword><keyword>=</keyword> HYMN_VALUE_FUNC) {
    <keyword>const</keyword> func <keyword>=</keyword> value.value
    <keyword>if</keyword> (func.source) <keyword>return</keyword> func.source
  }
  <keyword>return</keyword> valueToStringRecursive(value, null, <constant>false</constant>)
}

function valueToDebug(value) {
  <keyword>if</keyword> (value.is <keyword>==</keyword><keyword>=</keyword> HYMN_VALUE_FUNC) {
    <keyword>const</keyword> func <keyword>=</keyword> value.value
    <keyword>return</keyword> disassembleByteCode(func.code, func.name)
  }
  <keyword>return</keyword> valueToStringRecursive(value, null, <constant>false</constant>)
}

function hymnConcat(a, b) {
  <keyword>return</keyword> newString(valueToString(a) <keyword>+</keyword> valueToString(b))
}

function debugValueToString(value) {
  <keyword>return</keyword> valueType(value.is) <keyword>+</keyword> <string>': '</string> <keyword>+</keyword> valueToString(value)
}

function hymnResetStack(H) {
  H.stackTop <keyword>=</keyword> <constant>0</constant>
  H.frameCount <keyword>=</keyword> <constant>0</constant>
}

function hymnStackGet(H, index) {
  <keyword>if</keyword> (index <keyword>&lt;</keyword> H.stack.length) {
    <keyword>return</keyword> H.stack[index]
  }
  <keyword>const</keyword> value <keyword>=</keyword> new HymnValue(HYMN_VALUE_NONE, null)
  H.stack.push(value)
  <keyword>return</keyword> value
}

function hymnPush(H, value) {
  copyValueToFrom(hymnStackGet(H, H.stackTop++), value)
}

function hymnPeek(H, dist) {
  <keyword>if</keyword> (dist <keyword>&gt;</keyword> H.stackTop) {
    console.error(<string>'nothing on stack to peek'</string>)
    <keyword>return</keyword> newNone()
  }
  <keyword>return</keyword> copyValue(H.stack[H.stackTop <keyword>-</keyword> dist])
}

function hymnPop(H) {
  <keyword>if</keyword> (H.stackTop <keyword>==</keyword><keyword>=</keyword> <constant>0</constant>) {
    console.error(<string>'nothing on stack to pop'</string>)
    <keyword>return</keyword> newNone()
  }
  <keyword>return</keyword> copyValue(H.stack[<keyword>-</keyword><keyword>-</keyword>H.stackTop])
}

function hymnException(H) {
  let frame <keyword>=</keyword> currentFrame(H)
  <keyword>while</keyword> (<constant>true</constant>) {
    let except <keyword>=</keyword> null
    let range <keyword>=</keyword> frame.func.except
    <keyword>while</keyword> (range <keyword>!=</keyword><keyword>=</keyword> null) {
      <keyword>if</keyword> (frame.ip <keyword>&gt;</keyword><keyword>=</keyword> range.start <keyword>&</keyword><keyword>&</keyword> frame.ip <keyword>&lt;</keyword><keyword>=</keyword> range.end) {
        except <keyword>=</keyword> range
        break
      }
      range <keyword>=</keyword> range.next
    }
    <keyword>const</keyword> result <keyword>=</keyword> hymnPop(H)
    <keyword>if</keyword> (except <keyword>!=</keyword><keyword>=</keyword> null) {
      H.stackTop <keyword>=</keyword> frame.stack <keyword>+</keyword> except.stack
      frame.ip <keyword>=</keyword> except.end
      hymnPush(H, result)
      <keyword>return</keyword> frame
    }
    H.stackTop <keyword>=</keyword> frame.stack
    H.frameCount--
    <keyword>if</keyword> (H.frameCount <keyword>==</keyword><keyword>=</keyword> <constant>0</constant> || frame.func.name <keyword>==</keyword><keyword>=</keyword> null) {
      H.error <keyword>=</keyword> valueToString(result)
      <keyword>return</keyword> null
    }
    hymnPush(H, result)
    frame <keyword>=</keyword> currentFrame(H)
  }
}

function hymnStacktrace(H) {
  let trace <keyword>=</keyword> <string>''</string>
  <keyword>for</keyword> (let i <keyword>=</keyword> H.frameCount <keyword>-</keyword> <constant>1</constant>; i <keyword>&gt;</keyword><keyword>=</keyword> <constant>0</constant>; i--) {
    <keyword>const</keyword> frame <keyword>=</keyword> H.frames[i]
    <keyword>const</keyword> func <keyword>=</keyword> frame.func
    <keyword>const</keyword> ip <keyword>=</keyword> frame.ip <keyword>-</keyword> <constant>1</constant>
    <keyword>const</keyword> row <keyword>=</keyword> func.code.lines[ip]
    trace <keyword>+</keyword><keyword>=</keyword> <string>'  at'</string>
    <keyword>if</keyword> (func.name <keyword>!=</keyword><keyword>=</keyword> null) trace <keyword>+</keyword><keyword>=</keyword> <string>' '</string> <keyword>+</keyword> func.name
    trace <keyword>+</keyword><keyword>=</keyword> (func.script <keyword>==</keyword><keyword>=</keyword> null ? <string>' script:'</string> : <string>' '</string> <keyword>+</keyword> func.script <keyword>+</keyword> <string>':'</string>) <keyword>+</keyword> row
    <keyword>if</keyword> (i <keyword>&gt;</keyword> <constant>0</constant>) trace <keyword>+</keyword><keyword>=</keyword> <string>'\n'</string>
  }
  <keyword>return</keyword> trace
}

function hymnPushError(H, error) {
  hymnPush(H, newString(error))
  <keyword>return</keyword> hymnException(H)
}

function hymnThrowExistingError(H, error) {
  <keyword>return</keyword> hymnPushError(H, error)
}

function hymnThrowError(H, error) {
  error <keyword>+</keyword><keyword>=</keyword> <string>'\n'</string> <keyword>+</keyword> hymnStacktrace(H)
  <keyword>return</keyword> hymnPushError(H, error)
}

function hymnFrameGet(H, index) {
  <keyword>if</keyword> (index <keyword>&lt;</keyword> H.frames.length) {
    <keyword>return</keyword> H.frames[index]
  }
  <keyword>const</keyword> frame <keyword>=</keyword> new HymnFrame()
  H.frames.push(frame)
  <keyword>return</keyword> frame
}

function hymnCall(H, func, count) {
  <keyword>if</keyword> (count <keyword>!=</keyword><keyword>=</keyword> func.arity) {
    <keyword>if</keyword> (count <keyword>&lt;</keyword> func.arity) <keyword>return</keyword> hymnThrowError(H, `not enough arguments in call to <string>'${func.name}'</string> (expected ${func.arity})`)
    <keyword>return</keyword> hymnThrowError(H, `too many arguments in call to <string>'${func.name}'</string> (expected ${func.arity})`)
  } <keyword>else</keyword> <keyword>if</keyword> (H.frameCount <keyword>==</keyword><keyword>=</keyword> HYMN_FRAMES_MAX) {
    <keyword>return</keyword> hymnThrowError(H, <string>'stack overflow'</string>)
  }

  <keyword>const</keyword> frame <keyword>=</keyword> hymnFrameGet(H, H.frameCount++)
  frame.func <keyword>=</keyword> func
  frame.ip <keyword>=</keyword> <constant>0</constant>
  frame.stack <keyword>=</keyword> H.stackTop <keyword>-</keyword> count <keyword>-</keyword> <constant>1</constant>

  <keyword>return</keyword> frame
}

function hymnCallValue(H, value, count) {
  <keyword>switch</keyword> (value.is) {
    <keyword>case</keyword> HYMN_VALUE_FUNC:
      <keyword>return</keyword> hymnCall(H, value.value, count)
    <keyword>case</keyword> HYMN_VALUE_FUNC_NATIVE: {
      <keyword>const</keyword> func <keyword>=</keyword> value.value.func
      <keyword>const</keyword> result <keyword>=</keyword> func(H, count, H.stack[H.stackTop <keyword>-</keyword> count])
      <keyword>const</keyword> top <keyword>=</keyword> H.stackTop <keyword>-</keyword> count <keyword>-</keyword> <constant>1</constant>
      H.stackTop <keyword>=</keyword> top
      hymnPush(H, result)
      <keyword>return</keyword> currentFrame(H)
    }
    <keyword>default</keyword>: {
      <keyword>return</keyword> hymnThrowError(H, `can't call ${valueType(value.is)} (expected function)`)
    }
  }
}

function readByte(frame) {
  <keyword>return</keyword> frame.func.code.instructions[frame.ip++]
}

function readShort(frame) {
  frame.ip <keyword>+</keyword><keyword>=</keyword> <constant>2</constant>
  <keyword>return</keyword> (frame.func.code.instructions[frame.ip <keyword>-</keyword> <constant>2</constant>] <keyword>&lt;&lt;</keyword> <constant>8</constant>) | frame.func.code.instructions[frame.ip <keyword>-</keyword> <constant>1</constant>]
}

function readConstant(frame) {
  <keyword>return</keyword> frame.func.code.constants[readByte(frame)]
}

function httpPathParent(path) {
  <keyword>if</keyword> (path.length <keyword>&lt;</keyword> <constant>2</constant>) {
    <keyword>return</keyword> path
  }
  let i <keyword>=</keyword> path.length <keyword>-</keyword> <constant>2</constant>
  <keyword>while</keyword> (<constant>true</constant>) {
    <keyword>if</keyword> (i <keyword>==</keyword><keyword>=</keyword> <constant>0</constant>) break
    <keyword>if</keyword> (path[i] <keyword>==</keyword><keyword>=</keyword> <string>'/'</string>) break
    i--
  }
  <keyword>return</keyword> path.substring(<constant>0</constant>, i)
}

async function hymnImport(H, file) {
  <keyword>const</keyword> imports <keyword>=</keyword> H.imports

  let script <keyword>=</keyword> null
  let p <keyword>=</keyword> <constant>1</constant>
  <keyword>while</keyword> (<constant>true</constant>) {
    <keyword>const</keyword> frame <keyword>=</keyword> parentFrame(H, p)
    <keyword>if</keyword> (frame <keyword>==</keyword><keyword>=</keyword> null) {
      break
    }
    script <keyword>=</keyword> frame.func.script
    <keyword>if</keyword> (script <keyword>!=</keyword><keyword>=</keyword> null) {
      break
    }
    p++
  }

  <keyword>const</keyword> paths <keyword>=</keyword> H.paths
  <keyword>const</keyword> size <keyword>=</keyword> paths.length

  let module <keyword>=</keyword> null
  let source <keyword>=</keyword> null

  <keyword>if</keyword> (node) {
    <keyword>const</keyword> parent <keyword>=</keyword> script ? nodePath.dirname(script) : null

    <keyword>for</keyword> (let i <keyword>=</keyword> <constant>0</constant>; i <keyword>&lt;</keyword> size; i++) {
      <keyword>const</keyword> value <keyword>=</keyword> paths[i]
      <keyword>if</keyword> (<keyword>!</keyword>isString(value)) {
        continue
      }
      <keyword>const</keyword> question <keyword>=</keyword> value.value

      <keyword>const</keyword> replace <keyword>=</keyword> question.replace(<keyword>/</keyword><keyword>&lt;</keyword>path&gt;/g, file)
      <keyword>const</keyword> path <keyword>=</keyword> parent ? replace.replace(<keyword>/</keyword><keyword>&lt;</keyword>parent&gt;/g, parent) : replace
      <keyword>const</keyword> use <keyword>=</keyword> nodePath.resolve(path)

      <keyword>if</keyword> (tableGet(imports, use) <keyword>!=</keyword><keyword>=</keyword> null) {
        <keyword>return</keyword> currentFrame(H)
      }

      <keyword>if</keyword> (nodeFs.existsSync(use)) {
        module <keyword>=</keyword> use
        break
      }
    }

    <keyword>if</keyword> (module <keyword>==</keyword><keyword>=</keyword> null) {
      let missing <keyword>=</keyword> <string>'import not found: '</string> <keyword>+</keyword> file

      <keyword>for</keyword> (let i <keyword>=</keyword> <constant>0</constant>; i <keyword>&lt;</keyword> size; i++) {
        <keyword>const</keyword> value <keyword>=</keyword> paths[i]
        <keyword>if</keyword> (<keyword>!</keyword>isString(value)) {
          continue
        }
        <keyword>const</keyword> question <keyword>=</keyword> value.value

        <keyword>const</keyword> replace <keyword>=</keyword> question.replace(<keyword>/</keyword><keyword>&lt;</keyword>path&gt;/g, file)
        <keyword>const</keyword> path <keyword>=</keyword> parent ? replace.replace(<keyword>/</keyword><keyword>&lt;</keyword>parent&gt;/g, parent) : replace
        <keyword>const</keyword> use <keyword>=</keyword> nodePath.resolve(path)

        missing <keyword>+</keyword><keyword>=</keyword> <string>'\n  no file: '</string> <keyword>+</keyword> use
      }

      <keyword>return</keyword> hymnThrowError(H, missing)
    }

    tablePut(imports, module, newBool(<constant>true</constant>))

    source <keyword>=</keyword> nodeFs.readFileSync(module, { encoding: <string>'utf-8'</string> })
  } <keyword>else</keyword> {
    <keyword>const</keyword> parent <keyword>=</keyword> script ? httpPathParent(script) : null

    <keyword>for</keyword> (let i <keyword>=</keyword> <constant>0</constant>; i <keyword>&lt;</keyword> size; i++) {
      <keyword>const</keyword> value <keyword>=</keyword> paths[i]
      <keyword>if</keyword> (<keyword>!</keyword>isString(value)) {
        continue
      }
      <keyword>const</keyword> question <keyword>=</keyword> value.value

      <keyword>const</keyword> replace <keyword>=</keyword> question.replace(<keyword>/</keyword><keyword>&lt;</keyword>path&gt;/g, file)
      <keyword>const</keyword> use <keyword>=</keyword> parent ? replace.replace(<keyword>/</keyword><keyword>&lt;</keyword>parent&gt;/g, parent) : replace

      <keyword>if</keyword> (tableGet(imports, use) <keyword>!=</keyword><keyword>=</keyword> null) {
        <keyword>return</keyword> currentFrame(H)
      }

      <keyword>const</keyword> response <keyword>=</keyword> await fetch(use).catch((exception) <keyword>=</keyword><keyword>&gt;</keyword> {
        <keyword>return</keyword> { ok: <constant>false</constant>, status: <constant>404</constant>, exception: exception }
      })

      <keyword>if</keyword> (response.ok) {
        source <keyword>=</keyword> await response.text().catch((exception) <keyword>=</keyword><keyword>&gt;</keyword> {
          <keyword>return</keyword> exception
        })
        module <keyword>=</keyword> use
        break
      }
    }

    <keyword>if</keyword> (module <keyword>==</keyword><keyword>=</keyword> null) {
      let missing <keyword>=</keyword> <string>'import not found: '</string> <keyword>+</keyword> file

      <keyword>for</keyword> (let i <keyword>=</keyword> <constant>0</constant>; i <keyword>&lt;</keyword> size; i++) {
        <keyword>const</keyword> value <keyword>=</keyword> paths[i]
        <keyword>if</keyword> (<keyword>!</keyword>isString(value)) {
          continue
        }
        <keyword>const</keyword> question <keyword>=</keyword> value.value

        <keyword>const</keyword> replace <keyword>=</keyword> question.replace(<keyword>/</keyword><keyword>&lt;</keyword>path&gt;/g, file)
        <keyword>const</keyword> use <keyword>=</keyword> parent ? replace.replace(<keyword>/</keyword><keyword>&lt;</keyword>parent&gt;/g, parent) : replace

        missing <keyword>+</keyword><keyword>=</keyword> <string>'\n  no file: '</string> <keyword>+</keyword> use
      }

      <keyword>return</keyword> hymnThrowError(H, missing)
    }

    tablePut(imports, module, newBool(<constant>true</constant>))
  }

  <keyword>const</keyword> result <keyword>=</keyword> compile(H, module, source, TYPE_SCRIPT)

  <keyword>const</keyword> func <keyword>=</keyword> result.func
  let error <keyword>=</keyword> result.error

  <keyword>if</keyword> (error) {
    <keyword>return</keyword> hymnThrowExistingError(H, error)
  }

  <keyword>const</keyword> funcValue <keyword>=</keyword> newFuncValue(func)

  hymnPush(H, funcValue)
  hymnCall(H, func, <constant>0</constant>)

  error <keyword>=</keyword> await hymnRun(H)
  <keyword>if</keyword> (error) {
    <keyword>return</keyword> hymnThrowExistingError(H, error)
  }

  <keyword>return</keyword> currentFrame(H)
}

function debugConstantInstruction(debug, name, code, index) {
  <keyword>const</keyword> constant <keyword>=</keyword> code.instructions[index <keyword>+</keyword> <constant>1</constant>]
  debug[<constant>0</constant>] <keyword>+</keyword><keyword>=</keyword> `${name}: [${constant}] [${debugValueToString(code.constants[constant])}]`
  <keyword>return</keyword> index <keyword>+</keyword> <constant>2</constant>
}

function debugByteInstruction(debug, name, code, index) {
  <keyword>const</keyword> byte <keyword>=</keyword> code.instructions[index <keyword>+</keyword> <constant>1</constant>]
  debug[<constant>0</constant>] <keyword>+</keyword><keyword>=</keyword> `${name}: [${byte}]`
  <keyword>return</keyword> index <keyword>+</keyword> <constant>2</constant>
}

function debugJumpInstruction(debug, name, sign, code, index) {
  <keyword>const</keyword> jump <keyword>=</keyword> (code.instructions[index <keyword>+</keyword> <constant>1</constant>] <keyword>&lt;&lt;</keyword> <constant>8</constant>) | code.instructions[index <keyword>+</keyword> <constant>2</constant>]
  debug[<constant>0</constant>] <keyword>+</keyword><keyword>=</keyword> `${name}: [${index}] <keyword>-&gt;</keyword> [${index <keyword>+</keyword> <constant>3</constant> <keyword>+</keyword> sign <keyword>*</keyword> jump}]`
  <keyword>return</keyword> index <keyword>+</keyword> <constant>3</constant>
}

function debugThreeByteInstruction(debug, name, code, index) {
  <keyword>const</keyword> byte <keyword>=</keyword> code.instructions[index <keyword>+</keyword> <constant>1</constant>]
  <keyword>const</keyword> next <keyword>=</keyword> code.instructions[index <keyword>+</keyword> <constant>2</constant>]
  debug[<constant>0</constant>] <keyword>+</keyword><keyword>=</keyword> `${name}: [${byte}] [${next}]`
  <keyword>return</keyword> index <keyword>+</keyword> <constant>3</constant>
}

function debugForLoopInstruction(debug, name, sign, code, index) {
  <keyword>const</keyword> slot <keyword>=</keyword> code.instructions[index <keyword>+</keyword> <constant>1</constant>]
  <keyword>const</keyword> jump <keyword>=</keyword> (code.instructions[index <keyword>+</keyword> <constant>2</constant>] <keyword>&lt;&lt;</keyword> <constant>8</constant>) | code.instructions[index <keyword>+</keyword> <constant>3</constant>]
  debug[<constant>0</constant>] <keyword>+</keyword><keyword>=</keyword> `${name}: [${slot}] [${index}] <keyword>-&gt;</keyword> [${index <keyword>+</keyword> <constant>4</constant> <keyword>+</keyword> sign <keyword>*</keyword> jump}]`
  <keyword>return</keyword> index <keyword>+</keyword> <constant>4</constant>
}

function debugInstruction(debug, name, index) {
  debug[<constant>0</constant>] <keyword>+</keyword><keyword>=</keyword> name
  <keyword>return</keyword> index <keyword>+</keyword> <constant>1</constant>
}

function disassembleInstruction(debug, code, index) {
  debug[<constant>0</constant>] <keyword>+</keyword><keyword>=</keyword> String(index).padStart(<constant>4</constant>, <string>'0'</string>) <keyword>+</keyword> <string>' '</string>
  <keyword>if</keyword> (index <keyword>&gt;</keyword> <constant>0</constant> <keyword>&</keyword><keyword>&</keyword> code.lines[index] <keyword>==</keyword><keyword>=</keyword> code.lines[index <keyword>-</keyword> <constant>1</constant>]) {
    debug[<constant>0</constant>] <keyword>+</keyword><keyword>=</keyword> <string>'   | '</string>
  } <keyword>else</keyword> {
    debug[<constant>0</constant>] <keyword>+</keyword><keyword>=</keyword> String(code.lines[index]).padStart(<constant>4</constant>, <string>' '</string>) <keyword>+</keyword> <string>' '</string>
  }
  <keyword>const</keyword> instruction <keyword>=</keyword> code.instructions[index]
  <keyword>switch</keyword> (instruction) {
    <keyword>case</keyword> OP_ADD:
      <keyword>return</keyword> debugInstruction(debug, <string>'OP_ADD'</string>, index)
    <keyword>case</keyword> OP_INSERT:
      <keyword>return</keyword> debugInstruction(debug, <string>'OP_INSERT'</string>, index)
    <keyword>case</keyword> OP_ARRAY_POP:
      <keyword>return</keyword> debugInstruction(debug, <string>'OP_ARRAY_POP'</string>, index)
    <keyword>case</keyword> OP_ARRAY_PUSH:
      <keyword>return</keyword> debugInstruction(debug, <string>'OP_ARRAY_PUSH'</string>, index)
    <keyword>case</keyword> OP_BIT_AND:
      <keyword>return</keyword> debugInstruction(debug, <string>'OP_BIT_AND'</string>, index)
    <keyword>case</keyword> OP_BIT_LEFT_SHIFT:
      <keyword>return</keyword> debugInstruction(debug, <string>'OP_BIT_LEFT_SHIFT'</string>, index)
    <keyword>case</keyword> OP_BIT_NOT:
      <keyword>return</keyword> debugInstruction(debug, <string>'OP_BIT_NOT'</string>, index)
    <keyword>case</keyword> OP_BIT_OR:
      <keyword>return</keyword> debugInstruction(debug, <string>'OP_BIT_OR'</string>, index)
    <keyword>case</keyword> OP_BIT_RIGHT_SHIFT:
      <keyword>return</keyword> debugInstruction(debug, <string>'OP_BIT_RIGHT_SHIFT'</string>, index)
    <keyword>case</keyword> OP_BIT_XOR:
      <keyword>return</keyword> debugInstruction(debug, <string>'OP_BIT_XOR'</string>, index)
    <keyword>case</keyword> OP_CALL:
      <keyword>return</keyword> debugByteInstruction(debug, <string>'OP_CALL'</string>, code, index)
    <keyword>case</keyword> OP_SELF:
      <keyword>return</keyword> debugConstantInstruction(debug, <string>'OP_SELF'</string>, code, index)
    <keyword>case</keyword> OP_CLEAR:
      <keyword>return</keyword> debugInstruction(debug, <string>'OP_CLEAR'</string>, index)
    <keyword>case</keyword> OP_CONSTANT:
      <keyword>return</keyword> debugConstantInstruction(debug, <string>'OP_CONSTANT'</string>, code, index)
    <keyword>case</keyword> OP_NEW_ARRAY:
      <keyword>return</keyword> debugInstruction(debug, <string>'OP_NEW_ARRAY'</string>, index)
    <keyword>case</keyword> OP_NEW_TABLE:
      <keyword>return</keyword> debugInstruction(debug, <string>'OP_NEW_TABLE'</string>, index)
    <keyword>case</keyword> OP_COPY:
      <keyword>return</keyword> debugInstruction(debug, <string>'OP_COPY'</string>, index)
    <keyword>case</keyword> OP_DEFINE_GLOBAL:
      <keyword>return</keyword> debugConstantInstruction(debug, <string>'OP_DEFINE_GLOBAL'</string>, code, index)
    <keyword>case</keyword> OP_DELETE:
      <keyword>return</keyword> debugInstruction(debug, <string>'OP_DELETE'</string>, index)
    <keyword>case</keyword> OP_DIVIDE:
      <keyword>return</keyword> debugInstruction(debug, <string>'OP_DIVIDE'</string>, index)
    <keyword>case</keyword> OP_DUPLICATE:
      <keyword>return</keyword> debugInstruction(debug, <string>'OP_DUPLICATE'</string>, index)
    <keyword>case</keyword> OP_EQUAL:
      <keyword>return</keyword> debugInstruction(debug, <string>'OP_EQUAL'</string>, index)
    <keyword>case</keyword> OP_ECHO:
      <keyword>return</keyword> debugInstruction(debug, <string>'OP_ECHO'</string>, index)
    <keyword>case</keyword> OP_EXISTS:
      <keyword>return</keyword> debugInstruction(debug, <string>'OP_EXISTS'</string>, index)
    <keyword>case</keyword> OP_FALSE:
      <keyword>return</keyword> debugInstruction(debug, <string>'OP_FALSE'</string>, index)
    <keyword>case</keyword> OP_FOR:
      <keyword>return</keyword> debugForLoopInstruction(debug, <string>'OP_FOR'</string>, <constant>1</constant>, code, index)
    <keyword>case</keyword> OP_FOR_LOOP:
      <keyword>return</keyword> debugForLoopInstruction(debug, <string>'OP_FOR_LOOP'</string>, <keyword>-</keyword><constant>1</constant>, code, index)
    <keyword>case</keyword> OP_GET_DYNAMIC:
      <keyword>return</keyword> debugInstruction(debug, <string>'OP_GET_DYNAMIC'</string>, index)
    <keyword>case</keyword> OP_GET_GLOBAL:
      <keyword>return</keyword> debugConstantInstruction(debug, <string>'OP_GET_GLOBAL'</string>, code, index)
    <keyword>case</keyword> OP_GET_LOCAL:
      <keyword>return</keyword> debugByteInstruction(debug, <string>'OP_GET_LOCAL'</string>, code, index)
    <keyword>case</keyword> OP_GET_PROPERTY:
      <keyword>return</keyword> debugConstantInstruction(debug, <string>'OP_GET_PROPERTY'</string>, code, index)
    <keyword>case</keyword> OP_GREATER:
      <keyword>return</keyword> debugInstruction(debug, <string>'OP_GREATER'</string>, index)
    <keyword>case</keyword> OP_GREATER_EQUAL:
      <keyword>return</keyword> debugInstruction(debug, <string>'OP_GREATER_EQUAL'</string>, index)
    <keyword>case</keyword> OP_INCREMENT_LOCAL_AND_SET:
      <keyword>return</keyword> debugThreeByteInstruction(debug, <string>'OP_INCREMENT_LOCAL_AND_SET'</string>, code, index)
    <keyword>case</keyword> OP_INDEX:
      <keyword>return</keyword> debugInstruction(debug, <string>'OP_INDEX'</string>, index)
    <keyword>case</keyword> OP_JUMP:
      <keyword>return</keyword> debugJumpInstruction(debug, <string>'OP_JUMP'</string>, <constant>1</constant>, code, index)
    <keyword>case</keyword> OP_JUMP_IF_FALSE:
      <keyword>return</keyword> debugJumpInstruction(debug, <string>'OP_JUMP_IF_FALSE'</string>, <constant>1</constant>, code, index)
    <keyword>case</keyword> OP_JUMP_IF_TRUE:
      <keyword>return</keyword> debugJumpInstruction(debug, <string>'OP_JUMP_IF_TRUE'</string>, <constant>1</constant>, code, index)
    <keyword>case</keyword> OP_KEYS:
      <keyword>return</keyword> debugInstruction(debug, <string>'OP_KEYS'</string>, index)
    <keyword>case</keyword> OP_LEN:
      <keyword>return</keyword> debugInstruction(debug, <string>'OP_LEN'</string>, index)
    <keyword>case</keyword> OP_LESS:
      <keyword>return</keyword> debugInstruction(debug, <string>'OP_LESS'</string>, index)
    <keyword>case</keyword> OP_LESS_EQUAL:
      <keyword>return</keyword> debugInstruction(debug, <string>'OP_LESS_EQUAL'</string>, index)
    <keyword>case</keyword> OP_LOOP:
      <keyword>return</keyword> debugJumpInstruction(debug, <string>'OP_LOOP'</string>, <keyword>-</keyword><constant>1</constant>, code, index)
    <keyword>case</keyword> OP_MODULO:
      <keyword>return</keyword> debugInstruction(debug, <string>'OP_MODULO'</string>, index)
    <keyword>case</keyword> OP_MULTIPLY:
      <keyword>return</keyword> debugInstruction(debug, <string>'OP_MULTIPLY'</string>, index)
    <keyword>case</keyword> OP_NEGATE:
      <keyword>return</keyword> debugInstruction(debug, <string>'OP_NEGATE'</string>, index)
    <keyword>case</keyword> OP_NONE:
      <keyword>return</keyword> debugInstruction(debug, <string>'OP_NONE'</string>, index)
    <keyword>case</keyword> OP_NOT:
      <keyword>return</keyword> debugInstruction(debug, <string>'OP_NOT'</string>, index)
    <keyword>case</keyword> OP_NOT_EQUAL:
      <keyword>return</keyword> debugInstruction(debug, <string>'OP_NOT_EQUAL'</string>, index)
    <keyword>case</keyword> OP_POP:
      <keyword>return</keyword> debugInstruction(debug, <string>'OP_POP'</string>, index)
    <keyword>case</keyword> OP_PRINT:
      <keyword>return</keyword> debugInstruction(debug, <string>'OP_PRINT'</string>, index)
    <keyword>case</keyword> OP_RETURN:
      <keyword>return</keyword> debugInstruction(debug, <string>'OP_RETURN'</string>, index)
    <keyword>case</keyword> OP_SET_DYNAMIC:
      <keyword>return</keyword> debugInstruction(debug, <string>'OP_SET_DYNAMIC'</string>, index)
    <keyword>case</keyword> OP_SET_GLOBAL:
      <keyword>return</keyword> debugConstantInstruction(debug, <string>'OP_SET_GLOBAL'</string>, code, index)
    <keyword>case</keyword> OP_SET_LOCAL:
      <keyword>return</keyword> debugByteInstruction(debug, <string>'OP_SET_LOCAL'</string>, code, index)
    <keyword>case</keyword> OP_SET_PROPERTY:
      <keyword>return</keyword> debugConstantInstruction(debug, <string>'OP_SET_PROPERTY'</string>, code, index)
    <keyword>case</keyword> OP_SLICE:
      <keyword>return</keyword> debugInstruction(debug, <string>'OP_SLICE'</string>, index)
    <keyword>case</keyword> OP_SUBTRACT:
      <keyword>return</keyword> debugInstruction(debug, <string>'OP_SUBTRACT'</string>, index)
    <keyword>case</keyword> OP_THROW:
      <keyword>return</keyword> debugInstruction(debug, <string>'OP_THROW'</string>, index)
    <keyword>case</keyword> OP_FLOAT:
      <keyword>return</keyword> debugInstruction(debug, <string>'OP_FLOAT'</string>, index)
    <keyword>case</keyword> OP_INT:
      <keyword>return</keyword> debugInstruction(debug, <string>'OP_INT'</string>, index)
    <keyword>case</keyword> OP_STRING:
      <keyword>return</keyword> debugInstruction(debug, <string>'OP_STRING'</string>, index)
    <keyword>case</keyword> OP_TRUE:
      <keyword>return</keyword> debugInstruction(debug, <string>'OP_TRUE'</string>, index)
    <keyword>case</keyword> OP_TYPE:
      <keyword>return</keyword> debugInstruction(debug, <string>'OP_TYPE'</string>, index)
    <keyword>case</keyword> OP_USE:
      <keyword>return</keyword> debugInstruction(debug, <string>'OP_USE'</string>, index)
    <keyword>case</keyword> OP_SOURCE:
      <keyword>return</keyword> debugInstruction(debug, <string>'OP_SOURCE'</string>, index)
    <keyword>case</keyword> OP_CODES:
      <keyword>return</keyword> debugInstruction(debug, <string>'OP_CODES'</string>, index)
    <keyword>case</keyword> OP_STACK:
      <keyword>return</keyword> debugInstruction(debug, <string>'OP_STACK'</string>, index)
    <keyword>case</keyword> OP_REFERENCE:
      <keyword>return</keyword> debugInstruction(debug, <string>'OP_REFERENCE'</string>, index)
    <keyword>default</keyword>:
      <keyword>return</keyword> (debug[<constant>0</constant>] <keyword>+</keyword><keyword>=</keyword> <string>'UNKNOWN_OPCODE '</string> <keyword>+</keyword> instruction)
  }
}

function disassembleByteCode(code) {
  <keyword>const</keyword> debug <keyword>=</keyword> [<string>''</string>]
  <keyword>if</keyword> (code.count <keyword>&gt;</keyword> <constant>0</constant>) {
    let index <keyword>=</keyword> disassembleInstruction(debug, code, <constant>0</constant>)
    <keyword>while</keyword> (index <keyword>&lt;</keyword> code.count) {
      debug[<constant>0</constant>] <keyword>+</keyword><keyword>=</keyword> <string>'\n'</string>
      index <keyword>=</keyword> disassembleInstruction(debug, code, index)
    }
  }
  <keyword>return</keyword> debug[<constant>0</constant>]
}

async function hymnRun(H) {
  let frame <keyword>=</keyword> currentFrame(H)
  <keyword>while</keyword> (<constant>true</constant>) {
    <keyword>switch</keyword> (readByte(frame)) {
      <keyword>case</keyword> OP_RETURN: {
        <keyword>const</keyword> result <keyword>=</keyword> hymnPop(H)
        H.frameCount--
        <keyword>if</keyword> (H.frameCount <keyword>==</keyword><keyword>=</keyword> <constant>0</constant> || frame.func.name <keyword>==</keyword><keyword>=</keyword> null) {
          hymnPop(H)
          return
        }
        H.stackTop <keyword>=</keyword> frame.stack
        hymnPush(H, result)
        frame <keyword>=</keyword> currentFrame(H)
        break
      }
      <keyword>case</keyword> OP_POP:
        hymnPop(H)
        break
      <keyword>case</keyword> OP_TRUE:
        hymnPush(H, newBool(<constant>true</constant>))
        break
      <keyword>case</keyword> OP_FALSE:
        hymnPush(H, newBool(<constant>false</constant>))
        break
      <keyword>case</keyword> OP_NONE:
        hymnPush(H, newNone())
        break
      <keyword>case</keyword> OP_CALL: {
        <keyword>const</keyword> count <keyword>=</keyword> readByte(frame)
        <keyword>const</keyword> call <keyword>=</keyword> hymnPeek(H, count <keyword>+</keyword> <constant>1</constant>)
        frame <keyword>=</keyword> hymnCallValue(H, call, count)
        <keyword>if</keyword> (frame <keyword>==</keyword><keyword>=</keyword> null) return
        break
      }
      <keyword>case</keyword> OP_SELF: {
        <keyword>const</keyword> table <keyword>=</keyword> hymnPeek(H, <constant>1</constant>)
        <keyword>if</keyword> (<keyword>!</keyword>isTable(table)) {
          frame <keyword>=</keyword> hymnThrowError(H, `can't get property of ${valueType(table.is)} (expected table)`)
          <keyword>if</keyword> (frame <keyword>==</keyword><keyword>=</keyword> null) return
          <keyword>else</keyword> break
        }
        <keyword>const</keyword> name <keyword>=</keyword> readConstant(frame).value
        <keyword>const</keyword> fun <keyword>=</keyword> tableGet(table.value, name)
        copyValueToFrom(hymnStackGet(H, H.stackTop <keyword>-</keyword> <constant>1</constant>), fun)
        hymnPush(H, table)
        break
      }
      <keyword>case</keyword> OP_JUMP: {
        <keyword>const</keyword> jump <keyword>=</keyword> readShort(frame)
        frame.ip <keyword>+</keyword><keyword>=</keyword> jump
        break
      }
      <keyword>case</keyword> OP_JUMP_IF_FALSE: {
        <keyword>const</keyword> value <keyword>=</keyword> hymnPop(H)
        <keyword>const</keyword> jump <keyword>=</keyword> readShort(frame)
        <keyword>if</keyword> (hymnFalse(value)) {
          frame.ip <keyword>+</keyword><keyword>=</keyword> jump
        }
        break
      }
      <keyword>case</keyword> OP_JUMP_IF_TRUE: {
        <keyword>const</keyword> value <keyword>=</keyword> hymnPop(H)
        <keyword>const</keyword> jump <keyword>=</keyword> readShort(frame)
        <keyword>if</keyword> (<keyword>!</keyword>hymnFalse(value)) {
          frame.ip <keyword>+</keyword><keyword>=</keyword> jump
        }
        break
      }
      <keyword>case</keyword> OP_LOOP: {
        <keyword>const</keyword> jump <keyword>=</keyword> readShort(frame)
        frame.ip <keyword>-</keyword><keyword>=</keyword> jump
        break
      }
      <keyword>case</keyword> OP_FOR: {
        <keyword>const</keyword> slot <keyword>=</keyword> readByte(frame)
        <keyword>const</keyword> object <keyword>=</keyword> H.stack[frame.stack <keyword>+</keyword> slot]
        H.stackTop <keyword>+</keyword><keyword>=</keyword> <constant>2</constant>
        <keyword>if</keyword> (isTable(object)) {
          <keyword>const</keyword> table <keyword>=</keyword> object.value
          <keyword>const</keyword> next <keyword>=</keyword> tableNext(table, null)
          <keyword>if</keyword> (next <keyword>==</keyword><keyword>=</keyword> null) {
            H.stack[frame.stack <keyword>+</keyword> slot <keyword>+</keyword> <constant>1</constant>] <keyword>=</keyword> newNone()
            H.stack[frame.stack <keyword>+</keyword> slot <keyword>+</keyword> <constant>2</constant>] <keyword>=</keyword> newNone()
            <keyword>const</keyword> jump <keyword>=</keyword> readShort(frame)
            frame.ip <keyword>+</keyword><keyword>=</keyword> jump
          } <keyword>else</keyword> {
            H.stack[frame.stack <keyword>+</keyword> slot <keyword>+</keyword> <constant>1</constant>] <keyword>=</keyword> newString(next.key)
            H.stack[frame.stack <keyword>+</keyword> slot <keyword>+</keyword> <constant>2</constant>] <keyword>=</keyword> copyValue(next.value)
            frame.ip <keyword>+</keyword><keyword>=</keyword> <constant>2</constant>
          }
        } <keyword>else</keyword> <keyword>if</keyword> (isArray(object)) {
          <keyword>const</keyword> array <keyword>=</keyword> object.value
          <keyword>if</keyword> (array.length <keyword>==</keyword><keyword>=</keyword> <constant>0</constant>) {
            H.stack[frame.stack <keyword>+</keyword> slot <keyword>+</keyword> <constant>1</constant>] <keyword>=</keyword> newNone()
            H.stack[frame.stack <keyword>+</keyword> slot <keyword>+</keyword> <constant>2</constant>] <keyword>=</keyword> newNone()
            <keyword>const</keyword> jump <keyword>=</keyword> readShort(frame)
            frame.ip <keyword>+</keyword><keyword>=</keyword> jump
          } <keyword>else</keyword> {
            <keyword>const</keyword> item <keyword>=</keyword> array[<constant>0</constant>]
            H.stack[frame.stack <keyword>+</keyword> slot <keyword>+</keyword> <constant>1</constant>] <keyword>=</keyword> newInt(<constant>0</constant>)
            H.stack[frame.stack <keyword>+</keyword> slot <keyword>+</keyword> <constant>2</constant>] <keyword>=</keyword> copyValue(item)
            frame.ip <keyword>+</keyword><keyword>=</keyword> <constant>2</constant>
          }
        } <keyword>else</keyword> {
          H.stack[frame.stack <keyword>+</keyword> slot <keyword>+</keyword> <constant>1</constant>] <keyword>=</keyword> newNone()
          H.stack[frame.stack <keyword>+</keyword> slot <keyword>+</keyword> <constant>2</constant>] <keyword>=</keyword> newNone()
          frame <keyword>=</keyword> hymnThrowError(H, `can't iterate over ${valueType(object.is)} (expected array or table)`)
          <keyword>if</keyword> (frame <keyword>==</keyword><keyword>=</keyword> null) return
          <keyword>else</keyword> break
        }
        break
      }
      <keyword>case</keyword> OP_FOR_LOOP: {
        <keyword>const</keyword> slot <keyword>=</keyword> readByte(frame)
        <keyword>const</keyword> object <keyword>=</keyword> H.stack[frame.stack <keyword>+</keyword> slot]
        <keyword>const</keyword> index <keyword>=</keyword> slot <keyword>+</keyword> <constant>1</constant>
        <keyword>const</keyword> value <keyword>=</keyword> slot <keyword>+</keyword> <constant>2</constant>
        <keyword>if</keyword> (isTable(object)) {
          <keyword>const</keyword> table <keyword>=</keyword> object.value
          <keyword>const</keyword> key <keyword>=</keyword> H.stack[frame.stack <keyword>+</keyword> index].value
          <keyword>const</keyword> next <keyword>=</keyword> tableNext(table, key)
          <keyword>if</keyword> (next <keyword>==</keyword><keyword>=</keyword> null) {
            frame.ip <keyword>+</keyword><keyword>=</keyword> <constant>2</constant>
          } <keyword>else</keyword> {
            H.stack[frame.stack <keyword>+</keyword> index] <keyword>=</keyword> newString(next.key)
            H.stack[frame.stack <keyword>+</keyword> value] <keyword>=</keyword> copyValue(next.value)
            <keyword>const</keyword> jump <keyword>=</keyword> readShort(frame)
            frame.ip <keyword>-</keyword><keyword>=</keyword> jump
          }
        } <keyword>else</keyword> {
          <keyword>const</keyword> array <keyword>=</keyword> object.value
          <keyword>const</keyword> key <keyword>=</keyword> H.stack[frame.stack <keyword>+</keyword> index].value <keyword>+</keyword> <constant>1</constant>
          <keyword>if</keyword> (key <keyword>&gt;</keyword><keyword>=</keyword> array.length) {
            frame.ip <keyword>+</keyword><keyword>=</keyword> <constant>2</constant>
          } <keyword>else</keyword> {
            <keyword>const</keyword> item <keyword>=</keyword> array[key]
            H.stack[frame.stack <keyword>+</keyword> index].value++
            H.stack[frame.stack <keyword>+</keyword> value] <keyword>=</keyword> copyValue(item)
            <keyword>const</keyword> jump <keyword>=</keyword> readShort(frame)
            frame.ip <keyword>-</keyword><keyword>=</keyword> jump
          }
        }
        break
      }
      <keyword>case</keyword> OP_EQUAL: {
        <keyword>const</keyword> b <keyword>=</keyword> hymnPop(H)
        <keyword>const</keyword> a <keyword>=</keyword> hymnPop(H)
        hymnPush(H, newBool(hymnEqual(a, b)))
        break
      }
      <keyword>case</keyword> OP_NOT_EQUAL: {
        <keyword>const</keyword> b <keyword>=</keyword> hymnPop(H)
        <keyword>const</keyword> a <keyword>=</keyword> hymnPop(H)
        hymnPush(H, newBool(<keyword>!</keyword>hymnEqual(a, b)))
        break
      }
      <keyword>case</keyword> OP_LESS: {
        <keyword>const</keyword> b <keyword>=</keyword> hymnPop(H)
        <keyword>const</keyword> a <keyword>=</keyword> hymnPop(H)
        <keyword>if</keyword> ((isInt(a) || isFloat(a)) <keyword>&</keyword><keyword>&</keyword> (isInt(b) || isFloat(b))) {
          hymnPush(H, newBool(a.value <keyword>&lt;</keyword> b.value))
        } <keyword>else</keyword> {
          frame <keyword>=</keyword> hymnThrowError(H, `comparison <string>'&lt;'</string> can't use ${valueType(a.is)} and ${valueType(b.is)} (expected numbers)`)
          <keyword>if</keyword> (frame <keyword>==</keyword><keyword>=</keyword> null) return
          <keyword>else</keyword> break
        }
        break
      }
      <keyword>case</keyword> OP_LESS_EQUAL: {
        <keyword>const</keyword> b <keyword>=</keyword> hymnPop(H)
        <keyword>const</keyword> a <keyword>=</keyword> hymnPop(H)
        <keyword>if</keyword> ((isInt(a) || isFloat(a)) <keyword>&</keyword><keyword>&</keyword> (isInt(b) || isFloat(b))) {
          hymnPush(H, newBool(a.value <keyword>&lt;</keyword><keyword>=</keyword> b.value))
        } <keyword>else</keyword> {
          frame <keyword>=</keyword> hymnThrowError(H, `comparison <string>'&lt;='</string> can't use ${valueType(a.is)} and ${valueType(b.is)} (expected numbers)`)
          <keyword>if</keyword> (frame <keyword>==</keyword><keyword>=</keyword> null) return
          <keyword>else</keyword> break
        }
        break
      }
      <keyword>case</keyword> OP_GREATER: {
        <keyword>const</keyword> b <keyword>=</keyword> hymnPop(H)
        <keyword>const</keyword> a <keyword>=</keyword> hymnPop(H)
        <keyword>if</keyword> ((isInt(a) || isFloat(a)) <keyword>&</keyword><keyword>&</keyword> (isInt(b) || isFloat(b))) {
          hymnPush(H, newBool(a.value <keyword>&gt;</keyword> b.value))
        } <keyword>else</keyword> {
          frame <keyword>=</keyword> hymnThrowError(H, `comparison <string>'&gt;'</string> can't use ${valueType(a.is)} and ${valueType(b.is)} (expected numbers)`)
          <keyword>if</keyword> (frame <keyword>==</keyword><keyword>=</keyword> null) return
          <keyword>else</keyword> break
        }
        break
      }
      <keyword>case</keyword> OP_GREATER_EQUAL: {
        <keyword>const</keyword> b <keyword>=</keyword> hymnPop(H)
        <keyword>const</keyword> a <keyword>=</keyword> hymnPop(H)
        <keyword>if</keyword> ((isInt(a) || isFloat(a)) <keyword>&</keyword><keyword>&</keyword> (isInt(b) || isFloat(b))) {
          hymnPush(H, newBool(a.value <keyword>&gt;</keyword><keyword>=</keyword> b.value))
        } <keyword>else</keyword> {
          frame <keyword>=</keyword> hymnThrowError(H, `comparison <string>'&gt;='</string> can't use ${valueType(a.is)} and ${valueType(b.is)} (expected numbers)`)
          <keyword>if</keyword> (frame <keyword>==</keyword><keyword>=</keyword> null) return
          <keyword>else</keyword> break
        }
        break
      }
      <keyword>case</keyword> OP_ADD: {
        <keyword>const</keyword> b <keyword>=</keyword> hymnPop(H)
        <keyword>const</keyword> a <keyword>=</keyword> hymnPop(H)
        <keyword>if</keyword> (isNone(a)) {
          <keyword>if</keyword> (isString(b)) {
            hymnPush(H, hymnConcat(a, b))
          } <keyword>else</keyword> {
            frame <keyword>=</keyword> hymnThrowError(H, `can't add ${valueType(a.is)} and ${valueType(b.is)}`)
            <keyword>if</keyword> (frame <keyword>==</keyword><keyword>=</keyword> null) return
            <keyword>else</keyword> break
          }
        } <keyword>else</keyword> <keyword>if</keyword> (isBool(a)) {
          <keyword>if</keyword> (isString(b)) {
            hymnPush(H, hymnConcat(a, b))
          } <keyword>else</keyword> {
            frame <keyword>=</keyword> hymnThrowError(H, `can't add ${valueType(a.is)} and ${valueType(b.is)}`)
            <keyword>if</keyword> (frame <keyword>==</keyword><keyword>=</keyword> null) return
            <keyword>else</keyword> break
          }
        } <keyword>else</keyword> <keyword>if</keyword> (isInt(a)) {
          <keyword>if</keyword> (isInt(b)) {
            a.value <keyword>+</keyword><keyword>=</keyword> b.value
            hymnPush(H, a)
          } <keyword>else</keyword> <keyword>if</keyword> (isFloat(b)) {
            b.value <keyword>+</keyword><keyword>=</keyword> a.value
            hymnPush(H, a)
          } <keyword>else</keyword> <keyword>if</keyword> (isString(b)) {
            hymnPush(H, hymnConcat(a, b))
          } <keyword>else</keyword> {
            frame <keyword>=</keyword> hymnThrowError(H, `can't add ${valueType(a.is)} and ${valueType(b.is)}`)
            <keyword>if</keyword> (frame <keyword>==</keyword><keyword>=</keyword> null) return
            <keyword>else</keyword> break
          }
        } <keyword>else</keyword> <keyword>if</keyword> (isFloat(a)) {
          <keyword>if</keyword> (isInt(b)) {
            a.value <keyword>+</keyword><keyword>=</keyword> b.value
            hymnPush(H, a)
          } <keyword>else</keyword> <keyword>if</keyword> (isFloat(b)) {
            a.value <keyword>+</keyword><keyword>=</keyword> b.value
            hymnPush(H, a)
          } <keyword>else</keyword> <keyword>if</keyword> (isString(b)) {
            hymnPush(H, hymnConcat(a, b))
          } <keyword>else</keyword> {
            frame <keyword>=</keyword> hymnThrowError(H, `can't add ${valueType(a.is)} and ${valueType(b.is)}`)
            <keyword>if</keyword> (frame <keyword>==</keyword><keyword>=</keyword> null) return
            <keyword>else</keyword> break
          }
        } <keyword>else</keyword> <keyword>if</keyword> (isString(a)) {
          hymnPush(H, hymnConcat(a, b))
        } <keyword>else</keyword> {
          frame <keyword>=</keyword> hymnThrowError(H, `can't add ${valueType(a.is)} and ${valueType(b.is)}`)
          <keyword>if</keyword> (frame <keyword>==</keyword><keyword>=</keyword> null) return
          <keyword>else</keyword> break
        }
        break
      }
      <keyword>case</keyword> OP_SUBTRACT: {
        <keyword>const</keyword> b <keyword>=</keyword> hymnPop(H)
        <keyword>const</keyword> a <keyword>=</keyword> hymnPop(H)
        <keyword>if</keyword> (isInt(a)) {
          <keyword>if</keyword> (isInt(b)) {
            a.value <keyword>-</keyword><keyword>=</keyword> b.value
            hymnPush(H, a)
          } <keyword>else</keyword> <keyword>if</keyword> (isFloat(b)) {
            a.value <keyword>-</keyword><keyword>=</keyword> b.value
            hymnPush(H, a)
          } <keyword>else</keyword> {
            frame <keyword>=</keyword> hymnThrowError(H, `can't subtract ${valueType(a.is)} and ${valueType(b.is)} (expected numbers)`)
            <keyword>if</keyword> (frame <keyword>==</keyword><keyword>=</keyword> null) return
            <keyword>else</keyword> break
          }
        } <keyword>else</keyword> <keyword>if</keyword> (isFloat(a)) {
          <keyword>if</keyword> (isInt(b)) {
            a.value <keyword>-</keyword><keyword>=</keyword> b.value
            hymnPush(H, a)
          } <keyword>else</keyword> <keyword>if</keyword> (isFloat(b)) {
            a.value <keyword>-</keyword><keyword>=</keyword> b.value
            hymnPush(H, a)
          } <keyword>else</keyword> {
            frame <keyword>=</keyword> hymnThrowError(H, `can't subtract ${valueType(a.is)} and ${valueType(b.is)} (expected numbers)`)
            <keyword>if</keyword> (frame <keyword>==</keyword><keyword>=</keyword> null) return
            <keyword>else</keyword> break
          }
        } <keyword>else</keyword> {
          frame <keyword>=</keyword> hymnThrowError(H, `can't subtract ${valueType(a.is)} and ${valueType(b.is)} (expected numbers)`)
          <keyword>if</keyword> (frame <keyword>==</keyword><keyword>=</keyword> null) return
          <keyword>else</keyword> break
        }
        break
      }
      <keyword>case</keyword> OP_MULTIPLY: {
        <keyword>const</keyword> b <keyword>=</keyword> hymnPop(H)
        <keyword>const</keyword> a <keyword>=</keyword> hymnPop(H)
        <keyword>if</keyword> (isInt(a)) {
          <keyword>if</keyword> (isInt(b)) {
            a.value <keyword>*</keyword><keyword>=</keyword> b.value
            hymnPush(H, a)
          } <keyword>else</keyword> <keyword>if</keyword> (isFloat(b)) {
            a.value <keyword>*</keyword><keyword>=</keyword> b.value
            hymnPush(H, a)
          } <keyword>else</keyword> {
            frame <keyword>=</keyword> hymnThrowError(H, `can't multiply ${valueType(a.is)} and ${valueType(b.is)} (expected numbers)`)
            <keyword>if</keyword> (frame <keyword>==</keyword><keyword>=</keyword> null) return
            <keyword>else</keyword> break
          }
        } <keyword>else</keyword> <keyword>if</keyword> (isFloat(a)) {
          <keyword>if</keyword> (isInt(b)) {
            a.value <keyword>*</keyword><keyword>=</keyword> b.value
            hymnPush(H, a)
          } <keyword>else</keyword> <keyword>if</keyword> (isFloat(b)) {
            a.value <keyword>*</keyword><keyword>=</keyword> b.value
            hymnPush(H, a)
          } <keyword>else</keyword> {
            frame <keyword>=</keyword> hymnThrowError(H, `can't multiply ${valueType(a.is)} and ${valueType(b.is)} (expected numbers)`)
            <keyword>if</keyword> (frame <keyword>==</keyword><keyword>=</keyword> null) return
            <keyword>else</keyword> break
          }
        } <keyword>else</keyword> {
          frame <keyword>=</keyword> hymnThrowError(H, `can't multiply ${valueType(a.is)} and ${valueType(b.is)} (expected numbers)`)
          <keyword>if</keyword> (frame <keyword>==</keyword><keyword>=</keyword> null) return
          <keyword>else</keyword> break
        }
        break
      }
      <keyword>case</keyword> OP_DIVIDE: {
        <keyword>const</keyword> b <keyword>=</keyword> hymnPop(H)
        <keyword>const</keyword> a <keyword>=</keyword> hymnPop(H)
        <keyword>if</keyword> (isInt(a)) {
          <keyword>if</keyword> (isInt(b)) {
            a.value <keyword>/</keyword><keyword>=</keyword> b.value
            hymnPush(H, a)
          } <keyword>else</keyword> <keyword>if</keyword> (isFloat(b)) {
            a.value <keyword>/</keyword><keyword>=</keyword> b.value
            hymnPush(H, a)
          } <keyword>else</keyword> {
            frame <keyword>=</keyword> hymnThrowError(H, `can't divide ${valueType(a.is)} and ${valueType(b.is)} (expected numbers)`)
            <keyword>if</keyword> (frame <keyword>==</keyword><keyword>=</keyword> null) return
            <keyword>else</keyword> break
          }
        } <keyword>else</keyword> <keyword>if</keyword> (isFloat(a)) {
          <keyword>if</keyword> (isInt(b)) {
            a.value <keyword>/</keyword><keyword>=</keyword> b.value
            hymnPush(H, a)
          } <keyword>else</keyword> <keyword>if</keyword> (isFloat(b)) {
            a.value <keyword>/</keyword><keyword>=</keyword> b.value
            hymnPush(H, a)
          } <keyword>else</keyword> {
            frame <keyword>=</keyword> hymnThrowError(H, `can't divide ${valueType(a.is)} and ${valueType(b.is)} (expected numbers)`)
            <keyword>if</keyword> (frame <keyword>==</keyword><keyword>=</keyword> null) return
            <keyword>else</keyword> break
          }
        } <keyword>else</keyword> {
          frame <keyword>=</keyword> hymnThrowError(H, `can't divide ${valueType(a.is)} and ${valueType(b.is)} (expected numbers)`)
          <keyword>if</keyword> (frame <keyword>==</keyword><keyword>=</keyword> null) return
          <keyword>else</keyword> break
        }
        break
      }
      <keyword>case</keyword> OP_MODULO: {
        <keyword>const</keyword> b <keyword>=</keyword> hymnPop(H)
        <keyword>const</keyword> a <keyword>=</keyword> hymnPop(H)
        <keyword>if</keyword> (isInt(a)) {
          <keyword>if</keyword> (isInt(b)) {
            a.value %<keyword>=</keyword> b.value
            hymnPush(H, a)
          } <keyword>else</keyword> {
            frame <keyword>=</keyword> hymnThrowError(H, `can't modulo ${valueType(a.is)} and ${valueType(b.is)} (expected integers)`)
            <keyword>if</keyword> (frame <keyword>==</keyword><keyword>=</keyword> null) return
            <keyword>else</keyword> break
          }
        } <keyword>else</keyword> {
          frame <keyword>=</keyword> hymnThrowError(H, `can't modulo ${valueType(a.is)} and ${valueType(b.is)} (expected integers)`)
          <keyword>if</keyword> (frame <keyword>==</keyword><keyword>=</keyword> null) return
          <keyword>else</keyword> break
        }
        break
      }
      <keyword>case</keyword> OP_BIT_NOT: {
        <keyword>const</keyword> value <keyword>=</keyword> hymnPop(H)
        <keyword>if</keyword> (isInt(value)) {
          value.value <keyword>=</keyword> <keyword>~</keyword>value.value
          hymnPush(H, value)
        } <keyword>else</keyword> {
          frame <keyword>=</keyword> hymnThrowError(H, `bitwise <string>'~'</string> can't use ${valueType(value.is)} (expected integer)`)
          <keyword>if</keyword> (frame <keyword>==</keyword><keyword>=</keyword> null) return
          <keyword>else</keyword> break
        }
        break
      }
      <keyword>case</keyword> OP_BIT_OR: {
        <keyword>const</keyword> b <keyword>=</keyword> hymnPop(H)
        <keyword>const</keyword> a <keyword>=</keyword> hymnPop(H)
        <keyword>if</keyword> (isInt(a)) {
          <keyword>if</keyword> (isInt(b)) {
            a.value |<keyword>=</keyword> b.value
            hymnPush(H, a)
          } <keyword>else</keyword> {
            frame <keyword>=</keyword> hymnThrowError(H, `bitwise <string>'|'</string> can't use ${valueType(a.is)} and ${valueType(b.is)} (expected integers)`)
            <keyword>if</keyword> (frame <keyword>==</keyword><keyword>=</keyword> null) return
            <keyword>else</keyword> break
          }
        } <keyword>else</keyword> {
          frame <keyword>=</keyword> hymnThrowError(H, `bitwise <string>'|'</string> can't use ${valueType(a.is)} and ${valueType(b.is)} (expected integers)`)
          <keyword>if</keyword> (frame <keyword>==</keyword><keyword>=</keyword> null) return
          <keyword>else</keyword> break
        }
        break
      }
      <keyword>case</keyword> OP_BIT_AND: {
        <keyword>const</keyword> b <keyword>=</keyword> hymnPop(H)
        <keyword>const</keyword> a <keyword>=</keyword> hymnPop(H)
        <keyword>if</keyword> (isInt(a)) {
          <keyword>if</keyword> (isInt(b)) {
            a.value <keyword>&</keyword><keyword>=</keyword> b.value
            hymnPush(H, a)
          } <keyword>else</keyword> {
            frame <keyword>=</keyword> hymnThrowError(H, `bitwise <string>'&'</string> can't use ${valueType(a.is)} and ${valueType(b.is)} (expected integers)`)
            <keyword>if</keyword> (frame <keyword>==</keyword><keyword>=</keyword> null) return
            <keyword>else</keyword> break
          }
        } <keyword>else</keyword> {
          frame <keyword>=</keyword> hymnThrowError(H, `bitwise <string>'&'</string> can't use ${valueType(a.is)} and ${valueType(b.is)} (expected integers)`)
          <keyword>if</keyword> (frame <keyword>==</keyword><keyword>=</keyword> null) return
          <keyword>else</keyword> break
        }
        break
      }
      <keyword>case</keyword> OP_BIT_XOR: {
        <keyword>const</keyword> b <keyword>=</keyword> hymnPop(H)
        <keyword>const</keyword> a <keyword>=</keyword> hymnPop(H)
        <keyword>if</keyword> (isInt(a)) {
          <keyword>if</keyword> (isInt(b)) {
            a.value <keyword>^</keyword><keyword>=</keyword> b.value
            hymnPush(H, a)
          } <keyword>else</keyword> {
            frame <keyword>=</keyword> hymnThrowError(H, `bitwise <string>'^'</string> can't use ${valueType(a.is)} and ${valueType(b.is)} (expected integers)`)
            <keyword>if</keyword> (frame <keyword>==</keyword><keyword>=</keyword> null) return
            <keyword>else</keyword> break
          }
        } <keyword>else</keyword> {
          frame <keyword>=</keyword> hymnThrowError(H, `bitwise <string>'^'</string> can't use ${valueType(a.is)} and ${valueType(b.is)} (expected integers)`)
          <keyword>if</keyword> (frame <keyword>==</keyword><keyword>=</keyword> null) return
          <keyword>else</keyword> break
        }
        break
      }
      <keyword>case</keyword> OP_BIT_LEFT_SHIFT: {
        <keyword>const</keyword> b <keyword>=</keyword> hymnPop(H)
        <keyword>const</keyword> a <keyword>=</keyword> hymnPop(H)
        <keyword>if</keyword> (isInt(a)) {
          <keyword>if</keyword> (isInt(b)) {
            a.value <keyword>&lt;&lt;</keyword><keyword>=</keyword> b.value
            hymnPush(H, a)
          } <keyword>else</keyword> {
            frame <keyword>=</keyword> hymnThrowError(H, `bitwise <string>'&lt;&lt;'</string> can't use ${valueType(a.is)} and ${valueType(b.is)} (expected integers)`)
            <keyword>if</keyword> (frame <keyword>==</keyword><keyword>=</keyword> null) return
            <keyword>else</keyword> break
          }
        } <keyword>else</keyword> {
          frame <keyword>=</keyword> hymnThrowError(H, `bitwise <string>'&lt;&lt;'</string> can't use ${valueType(a.is)} and ${valueType(b.is)} (expected integers)`)
          <keyword>if</keyword> (frame <keyword>==</keyword><keyword>=</keyword> null) return
          <keyword>else</keyword> break
        }
        break
      }
      <keyword>case</keyword> OP_BIT_RIGHT_SHIFT: {
        <keyword>const</keyword> b <keyword>=</keyword> hymnPop(H)
        <keyword>const</keyword> a <keyword>=</keyword> hymnPop(H)
        <keyword>if</keyword> (isInt(a)) {
          <keyword>if</keyword> (isInt(b)) {
            a.value <keyword>&gt;&gt;</keyword><keyword>=</keyword> b.value
            hymnPush(H, a)
          } <keyword>else</keyword> {
            frame <keyword>=</keyword> hymnThrowError(H, `bitwise <string>'&gt;&gt;'</string> can't use ${valueType(a.is)} and ${valueType(b.is)} (expected integers)`)
            <keyword>if</keyword> (frame <keyword>==</keyword><keyword>=</keyword> null) return
            <keyword>else</keyword> break
          }
        } <keyword>else</keyword> {
          frame <keyword>=</keyword> hymnThrowError(H, `bitwise <string>'&gt;&gt;'</string> can't use ${valueType(a.is)} and ${valueType(b.is)} (expected integers)`)
          <keyword>if</keyword> (frame <keyword>==</keyword><keyword>=</keyword> null) return
          <keyword>else</keyword> break
        }
        break
      }
      <keyword>case</keyword> OP_NEGATE: {
        <keyword>const</keyword> value <keyword>=</keyword> hymnPop(H)
        <keyword>if</keyword> (isInt(value)) {
          value.value <keyword>=</keyword> <keyword>-</keyword>value.value
        } <keyword>else</keyword> <keyword>if</keyword> (isFloat(value)) {
          value.value <keyword>=</keyword> <keyword>-</keyword>value.value
        } <keyword>else</keyword> {
          frame <keyword>=</keyword> hymnThrowError(H, `negation <string>'-'</string> can't use ${valueType(value.is)} (expected number)`)
          <keyword>if</keyword> (frame <keyword>==</keyword><keyword>=</keyword> null) return
          <keyword>else</keyword> break
        }
        hymnPush(H, value)
        break
      }
      <keyword>case</keyword> OP_NOT: {
        <keyword>const</keyword> value <keyword>=</keyword> hymnPop(H)
        <keyword>if</keyword> (isBool(value)) {
          value.value <keyword>=</keyword> <keyword>!</keyword>value.value
        } <keyword>else</keyword> {
          frame <keyword>=</keyword> hymnThrowError(H, `not <string>'!'</string> can't use ${valueType(value.is)} (expected boolean)`)
          <keyword>if</keyword> (frame <keyword>==</keyword><keyword>=</keyword> null) return
          <keyword>else</keyword> break
        }
        hymnPush(H, value)
        break
      }
      <keyword>case</keyword> OP_CONSTANT: {
        <keyword>const</keyword> value <keyword>=</keyword> readConstant(frame)
        hymnPush(H, value)
        break
      }
      <keyword>case</keyword> OP_NEW_ARRAY: {
        <keyword>const</keyword> value <keyword>=</keyword> newArrayValue([])
        hymnPush(H, value)
        break
      }
      <keyword>case</keyword> OP_NEW_TABLE: {
        <keyword>const</keyword> value <keyword>=</keyword> newTableValue(new HymnTable())
        hymnPush(H, value)
        break
      }
      <keyword>case</keyword> OP_DEFINE_GLOBAL: {
        <keyword>const</keyword> name <keyword>=</keyword> readConstant(frame).value
        <keyword>const</keyword> value <keyword>=</keyword> hymnPop(H)
        <keyword>const</keyword> previous <keyword>=</keyword> tablePut(H.globals, name, value)
        <keyword>if</keyword> (previous <keyword>!=</keyword><keyword>=</keyword> null) {
          tablePut(H.globals, name, previous)
          frame <keyword>=</keyword> hymnThrowError(H, `multiple global definitions of <string>'${name}'</string>`)
          <keyword>if</keyword> (frame <keyword>==</keyword><keyword>=</keyword> null) return
          <keyword>else</keyword> break
        }
        break
      }
      <keyword>case</keyword> OP_SET_GLOBAL: {
        <keyword>const</keyword> name <keyword>=</keyword> readConstant(frame).value
        <keyword>const</keyword> value <keyword>=</keyword> hymnPeek(H, <constant>1</constant>)
        tablePut(H.globals, name, value)
        break
      }
      <keyword>case</keyword> OP_GET_GLOBAL: {
        <keyword>const</keyword> name <keyword>=</keyword> readConstant(frame).value
        <keyword>const</keyword> get <keyword>=</keyword> tableGet(H.globals, name)
        <keyword>if</keyword> (get <keyword>==</keyword><keyword>=</keyword> null) {
          frame <keyword>=</keyword> hymnThrowError(H, `undefined global <string>'${name}'</string>`)
          <keyword>if</keyword> (frame <keyword>==</keyword><keyword>=</keyword> null) return
          <keyword>else</keyword> break
        }
        hymnPush(H, get)
        break
      }
      <keyword>case</keyword> OP_SET_LOCAL: {
        <keyword>const</keyword> slot <keyword>=</keyword> readByte(frame)
        <keyword>const</keyword> value <keyword>=</keyword> hymnPeek(H, <constant>1</constant>)
        H.stack[frame.stack <keyword>+</keyword> slot] <keyword>=</keyword> value
        break
      }
      <keyword>case</keyword> OP_GET_LOCAL: {
        <keyword>const</keyword> slot <keyword>=</keyword> readByte(frame)
        <keyword>const</keyword> value <keyword>=</keyword> H.stack[frame.stack <keyword>+</keyword> slot]
        hymnPush(H, value)
        break
      }
      <keyword>case</keyword> OP_INCREMENT_LOCAL_AND_SET: {
        <keyword>const</keyword> slot <keyword>=</keyword> readByte(frame)
        <keyword>const</keyword> increment <keyword>=</keyword> readByte(frame)
        <keyword>const</keyword> value <keyword>=</keyword> copyValue(H.stack[frame.stack <keyword>+</keyword> slot])
        <keyword>if</keyword> (isInt(value) || isFloat(value)) {
          value.value <keyword>+</keyword><keyword>=</keyword> increment
        } <keyword>else</keyword> {
          frame <keyword>=</keyword> hymnThrowError(H, `can't increment ${valueType(value.is)} (expected number)`)
          <keyword>if</keyword> (frame <keyword>==</keyword><keyword>=</keyword> null) return
          <keyword>else</keyword> break
        }
        H.stack[frame.stack <keyword>+</keyword> slot] <keyword>=</keyword> value
        break
      }
      <keyword>case</keyword> OP_SET_PROPERTY: {
        <keyword>const</keyword> value <keyword>=</keyword> hymnPop(H)
        <keyword>const</keyword> tableValue <keyword>=</keyword> hymnPop(H)
        <keyword>if</keyword> (<keyword>!</keyword>isTable(tableValue)) {
          frame <keyword>=</keyword> hymnThrowError(H, `can't set property of ${valueType(value.is)} (expected table)`)
          <keyword>if</keyword> (frame <keyword>==</keyword><keyword>=</keyword> null) return
          <keyword>else</keyword> break
        }
        <keyword>const</keyword> table <keyword>=</keyword> tableValue.value
        <keyword>const</keyword> name <keyword>=</keyword> readConstant(frame).value
        tablePut(table, name, value)
        hymnPush(H, value)
        break
      }
      <keyword>case</keyword> OP_GET_PROPERTY: {
        <keyword>const</keyword> value <keyword>=</keyword> hymnPop(H)
        <keyword>if</keyword> (<keyword>!</keyword>isTable(value)) {
          frame <keyword>=</keyword> hymnThrowError(H, `can't get property of ${valueType(value.is)} (expected table)`)
          <keyword>if</keyword> (frame <keyword>==</keyword><keyword>=</keyword> null) return
          <keyword>else</keyword> break
        }
        <keyword>const</keyword> table <keyword>=</keyword> value.value
        <keyword>const</keyword> name <keyword>=</keyword> readConstant(frame).value
        <keyword>const</keyword> g <keyword>=</keyword> tableGet(table, name)
        <keyword>if</keyword> (g <keyword>==</keyword><keyword>=</keyword> null) hymnPush(H, newNone())
        <keyword>else</keyword> hymnPush(H, g)
        break
      }
      <keyword>case</keyword> OP_EXISTS: {
        <keyword>const</keyword> v <keyword>=</keyword> hymnPop(H)
        <keyword>const</keyword> o <keyword>=</keyword> hymnPop(H)
        <keyword>if</keyword> (<keyword>!</keyword>isTable(o)) {
          frame <keyword>=</keyword> hymnThrowError(H, `call to <string>'exists'</string> can't use ${valueType(o.is)} <keyword>for</keyword> <constant>1</constant>st argument (expected table)`)
          <keyword>if</keyword> (frame <keyword>==</keyword><keyword>=</keyword> null) return
          <keyword>else</keyword> break
        }
        <keyword>if</keyword> (<keyword>!</keyword>isString(v)) {
          frame <keyword>=</keyword> hymnThrowError(H, `call to <string>'exists'</string> can't use ${valueType(v.is)} <keyword>for</keyword> <constant>2</constant>nd argument (expected string)`)
          <keyword>if</keyword> (frame <keyword>==</keyword><keyword>=</keyword> null) return
          <keyword>else</keyword> break
        }
        <keyword>const</keyword> table <keyword>=</keyword> o.value
        <keyword>const</keyword> name <keyword>=</keyword> v.value
        <keyword>const</keyword> g <keyword>=</keyword> tableGet(table, name)
        <keyword>if</keyword> (g <keyword>==</keyword><keyword>=</keyword> null) {
          hymnPush(H, newBool(<constant>false</constant>))
        } <keyword>else</keyword> {
          hymnPush(H, newBool(<constant>true</constant>))
        }
        break
      }
      <keyword>case</keyword> OP_SET_DYNAMIC: {
        <keyword>const</keyword> s <keyword>=</keyword> hymnPop(H)
        <keyword>const</keyword> i <keyword>=</keyword> hymnPop(H)
        <keyword>const</keyword> v <keyword>=</keyword> hymnPop(H)
        <keyword>if</keyword> (isArray(v)) {
          <keyword>if</keyword> (<keyword>!</keyword>isInt(i)) {
            frame <keyword>=</keyword> hymnThrowError(H, `array assignment index can't be ${valueType(i.is)} (expected integer)`)
            <keyword>if</keyword> (frame <keyword>==</keyword><keyword>=</keyword> null) return
            <keyword>else</keyword> break
          }
          <keyword>const</keyword> array <keyword>=</keyword> v.value
          <keyword>const</keyword> size <keyword>=</keyword> array.length
          let index <keyword>=</keyword> i.value
          <keyword>if</keyword> (index <keyword>&gt;</keyword> size) {
            frame <keyword>=</keyword> hymnThrowError(H, `array assignment index out of bounds: ${index} <keyword>&gt;</keyword> ${size}`)
            <keyword>if</keyword> (frame <keyword>==</keyword><keyword>=</keyword> null) return
            <keyword>else</keyword> break
          }
          <keyword>if</keyword> (index <keyword>&lt;</keyword> <constant>0</constant>) {
            index <keyword>=</keyword> size <keyword>+</keyword> index
            <keyword>if</keyword> (index <keyword>&lt;</keyword> <constant>0</constant>) {
              frame <keyword>=</keyword> hymnThrowError(H, `negative array assignment index: ${index}`)
              <keyword>if</keyword> (frame <keyword>==</keyword><keyword>=</keyword> null) return
              <keyword>else</keyword> break
            }
          }
          <keyword>if</keyword> (index <keyword>==</keyword><keyword>=</keyword> size) {
            array.push(s)
          } <keyword>else</keyword> {
            array[index] <keyword>=</keyword> s
          }
        } <keyword>else</keyword> <keyword>if</keyword> (isTable(v)) {
          <keyword>if</keyword> (<keyword>!</keyword>isString(i)) {
            frame <keyword>=</keyword> hymnThrowError(H, `table assignment key can't be ${valueType(i.is)} (expected string)`)
            <keyword>if</keyword> (frame <keyword>==</keyword><keyword>=</keyword> null) return
            <keyword>else</keyword> break
          }
          <keyword>const</keyword> table <keyword>=</keyword> v.value
          <keyword>const</keyword> name <keyword>=</keyword> i.value
          tablePut(table, name, s)
        } <keyword>else</keyword> {
          frame <keyword>=</keyword> hymnThrowError(H, `can't assign value to ${valueType(v.is)} (expected array or table)`)
          <keyword>if</keyword> (frame <keyword>==</keyword><keyword>=</keyword> null) return
          <keyword>else</keyword> break
        }
        hymnPush(H, s)
        break
      }
      <keyword>case</keyword> OP_GET_DYNAMIC: {
        <keyword>const</keyword> i <keyword>=</keyword> hymnPop(H)
        <keyword>const</keyword> v <keyword>=</keyword> hymnPop(H)
        <keyword>switch</keyword> (v.is) {
          <keyword>case</keyword> HYMN_VALUE_STRING: {
            <keyword>if</keyword> (<keyword>!</keyword>isInt(i)) {
              frame <keyword>=</keyword> hymnThrowError(H, `string index can't be ${valueType(i.is)} (expected integer)`)
              <keyword>if</keyword> (frame <keyword>==</keyword><keyword>=</keyword> null) return
              <keyword>else</keyword> break
            }
            <keyword>const</keyword> string <keyword>=</keyword> v.value
            <keyword>const</keyword> size <keyword>=</keyword> string.length
            let index <keyword>=</keyword> i.value
            <keyword>if</keyword> (index <keyword>&gt;</keyword><keyword>=</keyword> size) {
              frame <keyword>=</keyword> hymnThrowError(H, `string index out of bounds: ${index} <keyword>&gt;</keyword><keyword>=</keyword> ${size}`)
              <keyword>if</keyword> (frame <keyword>==</keyword><keyword>=</keyword> null) return
              <keyword>else</keyword> break
            }
            <keyword>if</keyword> (index <keyword>&lt;</keyword> <constant>0</constant>) {
              index <keyword>=</keyword> size <keyword>+</keyword> index
              <keyword>if</keyword> (index <keyword>&lt;</keyword> <constant>0</constant>) {
                frame <keyword>=</keyword> hymnThrowError(H, `negative string index: ${index}`)
                <keyword>if</keyword> (frame <keyword>==</keyword><keyword>=</keyword> null) return
                <keyword>else</keyword> break
              }
            }
            <keyword>const</keyword> c <keyword>=</keyword> string[index]
            hymnPush(H, newString(String(c)))
            break
          }
          <keyword>case</keyword> HYMN_VALUE_ARRAY: {
            <keyword>if</keyword> (<keyword>!</keyword>isInt(i)) {
              frame <keyword>=</keyword> hymnThrowError(H, `array index can't be ${valueType(i.is)} (expected integer)`)
              <keyword>if</keyword> (frame <keyword>==</keyword><keyword>=</keyword> null) return
              <keyword>else</keyword> break
            }
            <keyword>const</keyword> array <keyword>=</keyword> v.value
            <keyword>const</keyword> size <keyword>=</keyword> array.length
            let index <keyword>=</keyword> i.value
            <keyword>if</keyword> (index <keyword>&gt;</keyword><keyword>=</keyword> size) {
              frame <keyword>=</keyword> hymnThrowError(H, `array index out of bounds: ${index} <keyword>&gt;</keyword><keyword>=</keyword> ${size}`)
              <keyword>if</keyword> (frame <keyword>==</keyword><keyword>=</keyword> null) return
              <keyword>else</keyword> break
            }
            <keyword>if</keyword> (index <keyword>&lt;</keyword> <constant>0</constant>) {
              index <keyword>=</keyword> size <keyword>+</keyword> index
              <keyword>if</keyword> (index <keyword>&lt;</keyword> <constant>0</constant>) {
                frame <keyword>=</keyword> hymnThrowError(H, `negative array index: ${index}`)
                <keyword>if</keyword> (frame <keyword>==</keyword><keyword>=</keyword> null) return
                <keyword>else</keyword> break
              }
            }
            <keyword>const</keyword> g <keyword>=</keyword> array[index]
            hymnPush(H, g)
            break
          }
          <keyword>case</keyword> HYMN_VALUE_TABLE: {
            <keyword>if</keyword> (<keyword>!</keyword>isString(i)) {
              frame <keyword>=</keyword> hymnThrowError(H, `table key can't be ${valueType(i.is)} (expected string)`)
              <keyword>if</keyword> (frame <keyword>==</keyword><keyword>=</keyword> null) return
              <keyword>else</keyword> break
            }
            <keyword>const</keyword> table <keyword>=</keyword> v.value
            <keyword>const</keyword> name <keyword>=</keyword> i.value
            <keyword>const</keyword> g <keyword>=</keyword> tableGet(table, name)
            <keyword>if</keyword> (g <keyword>==</keyword><keyword>=</keyword> null) hymnPush(H, newNone())
            <keyword>else</keyword> hymnPush(H, g)
            break
          }
          <keyword>default</keyword>: {
            frame <keyword>=</keyword> hymnThrowError(H, `can't get value from ${valueType(v.is)} (expected array, table, or string)`)
            <keyword>if</keyword> (frame <keyword>==</keyword><keyword>=</keyword> null) return
            <keyword>else</keyword> break
          }
        }
        break
      }
      <keyword>case</keyword> OP_LEN: {
        <keyword>const</keyword> value <keyword>=</keyword> hymnPop(H)
        <keyword>switch</keyword> (value.is) {
          <keyword>case</keyword> HYMN_VALUE_STRING: {
            <keyword>const</keyword> len <keyword>=</keyword> value.value.length
            hymnPush(H, newInt(len))
            break
          }
          <keyword>case</keyword> HYMN_VALUE_ARRAY: {
            <keyword>const</keyword> len <keyword>=</keyword> value.value.length
            hymnPush(H, newInt(len))
            break
          }
          <keyword>case</keyword> HYMN_VALUE_TABLE: {
            <keyword>const</keyword> len <keyword>=</keyword> value.value.size
            hymnPush(H, newInt(len))
            break
          }
          <keyword>default</keyword>:
            frame <keyword>=</keyword> hymnThrowError(H, `call to <string>'len'</string> can't use ${valueType(value.is)} (expected array, string, or table)`)
            <keyword>if</keyword> (frame <keyword>==</keyword><keyword>=</keyword> null) return
            <keyword>else</keyword> break
        }

        break
      }
      <keyword>case</keyword> OP_ARRAY_POP: {
        <keyword>const</keyword> a <keyword>=</keyword> hymnPop(H)
        <keyword>if</keyword> (<keyword>!</keyword>isArray(a)) {
          frame <keyword>=</keyword> hymnThrowError(H, `call to <string>'pop'</string> can't use ${valueType(a.is)} (expected array)`)
          <keyword>if</keyword> (frame <keyword>==</keyword><keyword>=</keyword> null) return
          <keyword>else</keyword> break
        } <keyword>else</keyword> {
          <keyword>const</keyword> value <keyword>=</keyword> a.value.pop()
          hymnPush(H, value)
        }
        break
      }
      <keyword>case</keyword> OP_ARRAY_PUSH: {
        <keyword>const</keyword> v <keyword>=</keyword> hymnPop(H)
        <keyword>const</keyword> a <keyword>=</keyword> hymnPop(H)
        <keyword>if</keyword> (<keyword>!</keyword>isArray(a)) {
          frame <keyword>=</keyword> hymnThrowError(H, `call to <string>'push'</string> can't use ${valueType(v.is)} <keyword>for</keyword> <constant>1</constant>st argument (expected array)`)
          <keyword>if</keyword> (frame <keyword>==</keyword><keyword>=</keyword> null) return
          <keyword>else</keyword> break
        } <keyword>else</keyword> {
          a.value.push(v)
          hymnPush(H, v)
        }
        break
      }
      <keyword>case</keyword> OP_INSERT: {
        <keyword>const</keyword> p <keyword>=</keyword> hymnPop(H)
        <keyword>const</keyword> i <keyword>=</keyword> hymnPop(H)
        <keyword>const</keyword> v <keyword>=</keyword> hymnPop(H)
        <keyword>if</keyword> (isArray(v)) {
          <keyword>if</keyword> (<keyword>!</keyword>isInt(i)) {
            frame <keyword>=</keyword> hymnThrowError(H, `call to <string>'insert'</string> can't use ${valueType(v.is)} <keyword>for</keyword> <constant>2</constant>nd argument (expected integer)`)
            <keyword>if</keyword> (frame <keyword>==</keyword><keyword>=</keyword> null) return
            <keyword>else</keyword> break
          }
          <keyword>const</keyword> array <keyword>=</keyword> v.value
          <keyword>const</keyword> size <keyword>=</keyword> array.length
          let index <keyword>=</keyword> i.value
          <keyword>if</keyword> (index <keyword>&gt;</keyword> size) {
            frame <keyword>=</keyword> hymnThrowError(H, `index out of bounds in call to <string>'insert'</string>: ${index} <keyword>&gt;</keyword> ${size}`)
            <keyword>if</keyword> (frame <keyword>==</keyword><keyword>=</keyword> null) return
            <keyword>else</keyword> break
          }
          <keyword>if</keyword> (index <keyword>&lt;</keyword> <constant>0</constant>) {
            index <keyword>=</keyword> size <keyword>+</keyword> index
            <keyword>if</keyword> (index <keyword>&lt;</keyword> <constant>0</constant>) {
              frame <keyword>=</keyword> hymnThrowError(H, `negative index in <string>'insert'</string> call: ${index}`)
              <keyword>if</keyword> (frame <keyword>==</keyword><keyword>=</keyword> null) return
              <keyword>else</keyword> break
            }
          }
          <keyword>if</keyword> (index <keyword>==</keyword><keyword>=</keyword> size) {
            array.push(p)
          } <keyword>else</keyword> {
            array.splice(index, <constant>0</constant>, p)
          }
          hymnPush(H, p)
        } <keyword>else</keyword> {
          frame <keyword>=</keyword> hymnThrowError(H, `call to <string>'insert'</string> can't use ${valueType(v.is)} <keyword>for</keyword> <constant>1</constant>st argument (expected array)`)
          <keyword>if</keyword> (frame <keyword>==</keyword><keyword>=</keyword> null) return
          <keyword>else</keyword> break
        }
        break
      }
      <keyword>case</keyword> OP_DELETE: {
        <keyword>const</keyword> at <keyword>=</keyword> hymnPop(H)
        <keyword>const</keyword> value <keyword>=</keyword> hymnPop(H)
        <keyword>if</keyword> (isArray(value)) {
          <keyword>if</keyword> (<keyword>!</keyword>isInt(at)) {
            frame <keyword>=</keyword> hymnThrowError(H, `call to <string>'delete'</string> can't use ${valueType(at.is)} <keyword>for</keyword> <constant>2</constant>nd argument (expected integer)`)
            <keyword>if</keyword> (frame <keyword>==</keyword><keyword>=</keyword> null) return
            <keyword>else</keyword> break
          }
          <keyword>const</keyword> array <keyword>=</keyword> value.value
          <keyword>const</keyword> size <keyword>=</keyword> array.length
          let index <keyword>=</keyword> at.value
          <keyword>if</keyword> (index <keyword>&gt;</keyword><keyword>=</keyword> size) {
            frame <keyword>=</keyword> hymnThrowError(H, `index out of bounds in call to <string>'delete'</string>: ${index} <keyword>&gt;</keyword><keyword>=</keyword> ${size}`)
            <keyword>if</keyword> (frame <keyword>==</keyword><keyword>=</keyword> null) return
            <keyword>else</keyword> break
          }
          <keyword>if</keyword> (index <keyword>&lt;</keyword> <constant>0</constant>) {
            index <keyword>=</keyword> size <keyword>+</keyword> index
            <keyword>if</keyword> (index <keyword>&lt;</keyword> <constant>0</constant>) {
              frame <keyword>=</keyword> hymnThrowError(H, `negative index in <string>'delete'</string> call: ${index}`)
              <keyword>if</keyword> (frame <keyword>==</keyword><keyword>=</keyword> null) return
              <keyword>else</keyword> break
            }
          }
          <keyword>const</keyword> item <keyword>=</keyword> array.splice(index, <constant>1</constant>)[<constant>0</constant>]
          hymnPush(H, item)
        } <keyword>else</keyword> <keyword>if</keyword> (isTable(value)) {
          <keyword>if</keyword> (<keyword>!</keyword>isString(at)) {
            frame <keyword>=</keyword> hymnThrowError(H, `call to <string>'delete'</string> can't use ${valueType(at.is)} <keyword>for</keyword> <constant>2</constant>nd argument (expected string)`)
            <keyword>if</keyword> (frame <keyword>==</keyword><keyword>=</keyword> null) return
            <keyword>else</keyword> break
          }
          <keyword>const</keyword> table <keyword>=</keyword> value.value
          <keyword>const</keyword> name <keyword>=</keyword> at.value
          <keyword>const</keyword> item <keyword>=</keyword> tableGet(table, name)
          <keyword>if</keyword> (item <keyword>!=</keyword><keyword>=</keyword> null) {
            tableRemove(table, name)
            hymnPush(H, item)
          } <keyword>else</keyword> {
            hymnPush(H, newNone())
          }
        } <keyword>else</keyword> {
          frame <keyword>=</keyword> hymnThrowError(H, `call to <string>'delete'</string> can't use ${valueType(value.is)} <keyword>for</keyword> <constant>1</constant>st argument (expected array or table)`)
          <keyword>if</keyword> (frame <keyword>==</keyword><keyword>=</keyword> null) return
          <keyword>else</keyword> break
        }
        break
      }
      <keyword>case</keyword> OP_COPY: {
        <keyword>const</keyword> value <keyword>=</keyword> hymnPop(H)
        <keyword>switch</keyword> (value.is) {
          <keyword>case</keyword> HYMN_VALUE_NONE:
          <keyword>case</keyword> HYMN_VALUE_BOOL:
          <keyword>case</keyword> HYMN_VALUE_INTEGER:
          <keyword>case</keyword> HYMN_VALUE_FLOAT:
          <keyword>case</keyword> HYMN_VALUE_STRING:
          <keyword>case</keyword> HYMN_VALUE_FUNC:
          <keyword>case</keyword> HYMN_VALUE_FUNC_NATIVE:
            hymnPush(H, value)
            break
          <keyword>case</keyword> HYMN_VALUE_ARRAY: {
            <keyword>const</keyword> copy <keyword>=</keyword> value.value.slice()
            hymnPush(H, newArrayValue(copy))
            break
          }
          <keyword>case</keyword> HYMN_VALUE_TABLE: {
            <keyword>const</keyword> copy <keyword>=</keyword> newTableCopy(value.value)
            hymnPush(H, newTableValue(copy))
            break
          }
          <keyword>default</keyword>:
            hymnPush(H, newNone())
        }
        break
      }
      <keyword>case</keyword> OP_SLICE: {
        <keyword>const</keyword> b <keyword>=</keyword> hymnPop(H)
        <keyword>const</keyword> a <keyword>=</keyword> hymnPop(H)
        <keyword>const</keyword> v <keyword>=</keyword> hymnPop(H)
        <keyword>if</keyword> (<keyword>!</keyword>isInt(a)) {
          frame <keyword>=</keyword> hymnThrowError(H, `slice can't use ${valueType(a.is)} (expected integer)`)
          <keyword>if</keyword> (frame <keyword>==</keyword><keyword>=</keyword> null) return
          <keyword>else</keyword> break
        }
        <keyword>const</keyword> start <keyword>=</keyword> a.value
        <keyword>if</keyword> (start <keyword>&lt;</keyword> <constant>0</constant>) {
          frame <keyword>=</keyword> hymnThrowError(H, `negative slice start: ${start}`)
          <keyword>if</keyword> (frame <keyword>==</keyword><keyword>=</keyword> null) return
          <keyword>else</keyword> break
        }
        <keyword>if</keyword> (isString(v)) {
          <keyword>const</keyword> original <keyword>=</keyword> v.value
          <keyword>const</keyword> size <keyword>=</keyword> original.length
          let end
          <keyword>if</keyword> (isInt(b)) {
            end <keyword>=</keyword> b.value
          } <keyword>else</keyword> <keyword>if</keyword> (isNone(b)) {
            end <keyword>=</keyword> size
          } <keyword>else</keyword> {
            frame <keyword>=</keyword> hymnThrowError(H, `slice can't use ${valueType(b.is)} (expected integer)`)
            <keyword>if</keyword> (frame <keyword>==</keyword><keyword>=</keyword> null) return
            <keyword>else</keyword> break
          }
          <keyword>if</keyword> (end <keyword>&gt;</keyword> size) {
            frame <keyword>=</keyword> hymnThrowError(H, `slice out of bounds: ${end} <keyword>&gt;</keyword> ${size}`)
            <keyword>if</keyword> (frame <keyword>==</keyword><keyword>=</keyword> null) return
            <keyword>else</keyword> break
          }
          <keyword>if</keyword> (end <keyword>&lt;</keyword> <constant>0</constant>) {
            end <keyword>=</keyword> size <keyword>+</keyword> end
            <keyword>if</keyword> (end <keyword>&lt;</keyword> <constant>0</constant>) {
              frame <keyword>=</keyword> hymnThrowError(H, `negative slice end: ${end}`)
              <keyword>if</keyword> (frame <keyword>==</keyword><keyword>=</keyword> null) return
              <keyword>else</keyword> break
            }
          }
          <keyword>if</keyword> (start <keyword>&gt;</keyword><keyword>=</keyword> end) {
            frame <keyword>=</keyword> hymnThrowError(H, `slice out of range: ${start} <keyword>&gt;</keyword><keyword>=</keyword> ${end}`)
            <keyword>if</keyword> (frame <keyword>==</keyword><keyword>=</keyword> null) return
            <keyword>else</keyword> break
          }
          <keyword>const</keyword> sub <keyword>=</keyword> original.substring(start, end)
          hymnPush(H, newString(sub))
        } <keyword>else</keyword> <keyword>if</keyword> (isArray(v)) {
          <keyword>const</keyword> array <keyword>=</keyword> v.value
          <keyword>const</keyword> size <keyword>=</keyword> array.length
          let end
          <keyword>if</keyword> (isInt(b)) {
            end <keyword>=</keyword> b.value
          } <keyword>else</keyword> <keyword>if</keyword> (isNone(b)) {
            end <keyword>=</keyword> size
          } <keyword>else</keyword> {
            frame <keyword>=</keyword> hymnThrowError(H, `slice can't use ${valueType(b.is)} (expected integer)`)
            <keyword>if</keyword> (frame <keyword>==</keyword><keyword>=</keyword> null) return
            <keyword>else</keyword> break
          }
          <keyword>if</keyword> (end <keyword>&gt;</keyword> size) {
            frame <keyword>=</keyword> hymnThrowError(H, `slice out of bounds: ${end} <keyword>&gt;</keyword> ${size}`)
            <keyword>if</keyword> (frame <keyword>==</keyword><keyword>=</keyword> null) return
            <keyword>else</keyword> break
          }
          <keyword>if</keyword> (end <keyword>&lt;</keyword> <constant>0</constant>) {
            end <keyword>=</keyword> size <keyword>+</keyword> end
            <keyword>if</keyword> (end <keyword>&lt;</keyword> <constant>0</constant>) {
              frame <keyword>=</keyword> hymnThrowError(H, `negative slice end: ${end}`)
              <keyword>if</keyword> (frame <keyword>==</keyword><keyword>=</keyword> null) return
              <keyword>else</keyword> break
            }
          }
          <keyword>if</keyword> (start <keyword>&gt;</keyword><keyword>=</keyword> end) {
            frame <keyword>=</keyword> hymnThrowError(H, `slice out of range: ${start} <keyword>&gt;</keyword><keyword>=</keyword> ${end}`)
            <keyword>if</keyword> (frame <keyword>==</keyword><keyword>=</keyword> null) return
            <keyword>else</keyword> break
          }
          <keyword>const</keyword> copy <keyword>=</keyword> array.slice(start, end)
          hymnPush(H, newArrayValue(copy))
        } <keyword>else</keyword> {
          frame <keyword>=</keyword> hymnThrowError(H, `can't slice ${valueType(v.is)} (expected string or array)`)
          <keyword>if</keyword> (frame <keyword>==</keyword><keyword>=</keyword> null) return
          <keyword>else</keyword> break
        }
        break
      }
      <keyword>case</keyword> OP_CLEAR: {
        <keyword>const</keyword> value <keyword>=</keyword> hymnPop(H)
        <keyword>switch</keyword> (value.is) {
          <keyword>case</keyword> HYMN_VALUE_BOOL:
            hymnPush(H, newBool(<constant>false</constant>))
            break
          <keyword>case</keyword> HYMN_VALUE_INTEGER:
            hymnPush(H, newInt(<constant>0</constant>))
            break
          <keyword>case</keyword> HYMN_VALUE_FLOAT:
            hymnPush(H, newFloat(<constant>0.0</constant>))
            break
          <keyword>case</keyword> HYMN_VALUE_STRING:
            hymnPush(H, newString(<string>''</string>))
            break
          <keyword>case</keyword> HYMN_VALUE_ARRAY: {
            <keyword>const</keyword> array <keyword>=</keyword> value.value
            array.length <keyword>=</keyword> <constant>0</constant>
            hymnPush(H, value)
            break
          }
          <keyword>case</keyword> HYMN_VALUE_TABLE: {
            <keyword>const</keyword> table <keyword>=</keyword> value.value
            tableClear(table)
            hymnPush(H, value)
            break
          }
          <keyword>case</keyword> HYMN_VALUE_NONE:
          <keyword>case</keyword> HYMN_VALUE_FUNC:
          <keyword>case</keyword> HYMN_VALUE_FUNC_NATIVE:
          <keyword>case</keyword> HYMN_VALUE_POINTER:
            hymnPush(H, newNone())
            break
        }
        break
      }
      <keyword>case</keyword> OP_KEYS: {
        <keyword>const</keyword> value <keyword>=</keyword> hymnPop(H)
        <keyword>if</keyword> (<keyword>!</keyword>isTable(value)) {
          frame <keyword>=</keyword> hymnThrowError(H, `call to <string>'keys'</string> can't use ${valueType(value.is)} (expected table)`)
          <keyword>if</keyword> (frame <keyword>==</keyword><keyword>=</keyword> null) return
          <keyword>else</keyword> break
        } <keyword>else</keyword> {
          <keyword>const</keyword> table <keyword>=</keyword> value.value
          <keyword>const</keyword> keys <keyword>=</keyword> tableKeys(table)
          hymnPush(H, newArrayValue(keys))
        }
        break
      }
      <keyword>case</keyword> OP_INDEX: {
        <keyword>const</keyword> b <keyword>=</keyword> hymnPop(H)
        <keyword>const</keyword> a <keyword>=</keyword> hymnPop(H)
        <keyword>switch</keyword> (a.is) {
          <keyword>case</keyword> HYMN_VALUE_STRING: {
            <keyword>if</keyword> (<keyword>!</keyword>isString(b)) {
              frame <keyword>=</keyword> hymnThrowError(H, `call to <string>'index'</string> can't use ${valueType(b.is)} <keyword>for</keyword> <constant>2</constant>nd argument (expected string)`)
              <keyword>if</keyword> (frame <keyword>==</keyword><keyword>=</keyword> null) return
              <keyword>else</keyword> break
            }
            <keyword>const</keyword> index <keyword>=</keyword> a.value.indexOf(b.value)
            hymnPush(H, newInt(index))
            break
          }
          <keyword>case</keyword> HYMN_VALUE_ARRAY:
            hymnPush(H, newInt(arrayIndexOf(a.value, b)))
            break
          <keyword>case</keyword> HYMN_VALUE_TABLE: {
            <keyword>const</keyword> key <keyword>=</keyword> tableKeyOf(a.value, b)
            <keyword>if</keyword> (key <keyword>==</keyword><keyword>=</keyword> null) hymnPush(H, newNone())
            <keyword>else</keyword> hymnPush(H, newString(key))
            break
          }
          <keyword>default</keyword>:
            frame <keyword>=</keyword> hymnThrowError(H, `call to <string>'index'</string> can't use ${valueType(a.is)} <keyword>for</keyword> <constant>1</constant>st argument (expected string, array, or table)`)
            <keyword>if</keyword> (frame <keyword>==</keyword><keyword>=</keyword> null) return
            <keyword>else</keyword> break
        }
        break
      }
      <keyword>case</keyword> OP_TYPE: {
        <keyword>const</keyword> value <keyword>=</keyword> hymnPop(H)
        hymnPush(H, newString(valueType(value.is)))
        break
      }
      <keyword>case</keyword> OP_INT: {
        <keyword>const</keyword> value <keyword>=</keyword> hymnPop(H)
        <keyword>if</keyword> (isInt(value)) {
          hymnPush(H, value)
        } <keyword>else</keyword> <keyword>if</keyword> (isFloat(value)) {
          hymnPush(H, newInt(parseInt(value.value)))
        } <keyword>else</keyword> <keyword>if</keyword> (isString(value)) {
          <keyword>const</keyword> number <keyword>=</keyword> Number(value.value)
          <keyword>if</keyword> (isNaN(number)) {
            hymnPush(H, newNone())
          } <keyword>else</keyword> {
            hymnPush(H, newInt(parseInt(number)))
          }
        } <keyword>else</keyword> {
          frame <keyword>=</keyword> hymnThrowError(H, `can't cast ${valueType(value.is)} to integer`)
          <keyword>if</keyword> (frame <keyword>==</keyword><keyword>=</keyword> null) return
          <keyword>else</keyword> break
        }
        break
      }
      <keyword>case</keyword> OP_FLOAT: {
        <keyword>const</keyword> value <keyword>=</keyword> hymnPop(H)
        <keyword>if</keyword> (isInt(value)) {
          hymnPush(H, newFloat(parseFloat(value.value)))
        } <keyword>else</keyword> <keyword>if</keyword> (isFloat(value)) {
          hymnPush(H, value)
        } <keyword>else</keyword> <keyword>if</keyword> (isString(value)) {
          <keyword>const</keyword> number <keyword>=</keyword> Number(value.value)
          <keyword>if</keyword> (isNaN(number)) {
            hymnPush(H, newNone())
          } <keyword>else</keyword> {
            hymnPush(H, newFloat(number))
          }
        } <keyword>else</keyword> {
          frame <keyword>=</keyword> hymnThrowError(H, `can't cast ${valueType(value.is)} to <constant>float</constant>`)
          <keyword>if</keyword> (frame <keyword>==</keyword><keyword>=</keyword> null) return
          <keyword>else</keyword> break
        }
        break
      }
      <keyword>case</keyword> OP_STRING: {
        <keyword>const</keyword> value <keyword>=</keyword> hymnPop(H)
        hymnPush(H, newString(valueToString(value)))
        break
      }
      <keyword>case</keyword> OP_ECHO: {
        <keyword>const</keyword> value <keyword>=</keyword> hymnPop(H)
        H.printLine(valueToString(value))
        break
      }
      <keyword>case</keyword> OP_PRINT: {
        <keyword>const</keyword> value <keyword>=</keyword> hymnPop(H)
        <keyword>const</keyword> route <keyword>=</keyword> hymnPop(H)
        <keyword>if</keyword> (hymnFalse(route)) {
          H.print(valueToString(value))
        } <keyword>else</keyword> {
          H.printError(valueToString(value))
        }
        break
      }
      <keyword>case</keyword> OP_SOURCE: {
        <keyword>const</keyword> value <keyword>=</keyword> hymnPop(H)
        hymnPush(H, newString(valueToInspect(value)))
        break
      }
      <keyword>case</keyword> OP_CODES: {
        <keyword>const</keyword> value <keyword>=</keyword> hymnPop(H)
        hymnPush(H, newString(valueToDebug(value)))
        break
      }
      <keyword>case</keyword> OP_STACK: {
        <keyword>if</keyword> (H.stackTop <keyword>!=</keyword><keyword>=</keyword> <constant>0</constant>) {
          let debug <keyword>=</keyword> <string>''</string>
          <keyword>for</keyword> (let i <keyword>=</keyword> <constant>0</constant>; i <keyword>&lt;</keyword> H.stackTop; i++) {
            debug <keyword>+</keyword><keyword>=</keyword> <string>'['</string> <keyword>+</keyword> debugValueToString(H.stack[i]) <keyword>+</keyword> <string>']\n'</string>
          }
          hymnPush(H, newString(debug))
        } <keyword>else</keyword> {
          hymnPush(H, newString(<string>''</string>))
        }
        break
      }
      <keyword>case</keyword> OP_REFERENCE: {
        hymnPop(H)
        hymnPush(H, newInt(<constant>0</constant>))
        break
      }
      <keyword>case</keyword> OP_THROW: {
        frame <keyword>=</keyword> hymnException(H)
        <keyword>if</keyword> (frame <keyword>==</keyword><keyword>=</keyword> null) return
        break
      }
      <keyword>case</keyword> OP_DUPLICATE: {
        <keyword>const</keyword> top <keyword>=</keyword> hymnPeek(H, <constant>1</constant>)
        hymnPush(H, top)
        break
      }
      <keyword>case</keyword> OP_USE: {
        <keyword>const</keyword> file <keyword>=</keyword> hymnPop(H)
        <keyword>if</keyword> (isString(file)) {
          frame <keyword>=</keyword> await hymnImport(H, file.value)
          <keyword>if</keyword> (frame <keyword>==</keyword><keyword>=</keyword> null) return
        } <keyword>else</keyword> {
          frame <keyword>=</keyword> hymnThrowError(H, `import can't use ${valueType(file.is)} (expected string)`)
          <keyword>if</keyword> (frame <keyword>==</keyword><keyword>=</keyword> null) return
          <keyword>else</keyword> break
        }
        break
      }
      <keyword>default</keyword>:
        console.error(<string>'unknown instruction'</string>)
        return
    }
  }
}

function addFunction(H, name, func) {
  <keyword>const</keyword> value <keyword>=</keyword> newNativeFunction(name, func)
  tablePut(H.globals, name, newFuncNativeValue(value))
}

function addPointer(H, name, pointer) {
  tablePut(H.globals, name, newPointerValue(pointer))
}

async function debugScript(H, script, source) {
  <keyword>const</keyword> result <keyword>=</keyword> compile(H, script, source, TYPE_SCRIPT)

  <keyword>const</keyword> func <keyword>=</keyword> result.func
  <keyword>if</keyword> (result.error <keyword>!=</keyword><keyword>=</keyword> null) {
    <keyword>return</keyword> result.error
  }

  console.debug(`\n-- ${script <keyword>!=</keyword><keyword>=</keyword> null ? script : <string>'script'</string>} <keyword>-</keyword><keyword>-</keyword>\n${disassembleByteCode(func.code)}`)

  <keyword>const</keyword> constants <keyword>=</keyword> func.code.constants

  <keyword>for</keyword> (let i <keyword>=</keyword> <constant>0</constant>; i <keyword>&lt;</keyword> constants.length; i++) {
    <keyword>const</keyword> constant <keyword>=</keyword> constants[i]
    <keyword>if</keyword> (isFunc(constant)) {
      <keyword>const</keyword> value <keyword>=</keyword> constant.value
      console.debug(`\n-- ${value.name <keyword>!=</keyword><keyword>=</keyword> null ? value.name : <string>'script'</string>} <keyword>-</keyword><keyword>-</keyword>\n${disassembleByteCode(value.code)}`)
    }
  }

  hymnResetStack(H)

  <keyword>return</keyword> null
}

async function interpretScript(H, script, source, type) {
  <keyword>const</keyword> result <keyword>=</keyword> compile(H, script, source, type)

  <keyword>const</keyword> func <keyword>=</keyword> result.func
  <keyword>if</keyword> (result.error <keyword>!=</keyword><keyword>=</keyword> null) {
    <keyword>return</keyword> result.error
  }

  <keyword>const</keyword> funcVal <keyword>=</keyword> newFuncValue(func)
  hymnPush(H, funcVal)
  hymnCall(H, func, <constant>0</constant>)

  await hymnRun(H)
  <keyword>if</keyword> (H.error <keyword>!=</keyword><keyword>=</keyword> null) <keyword>return</keyword> H.error

  hymnResetStack(H)
  <keyword>return</keyword> null
}

async function interpret(H, source) {
  <keyword>return</keyword> interpretScript(H, null, source, TYPE_SCRIPT)
}

async function direct(H, source) {
  <keyword>return</keyword> interpretScript(H, null, source, TYPE_DIRECT)
}

function newVM() {
  <keyword>const</keyword> H <keyword>=</keyword> new Hymn()

  <keyword>if</keyword> (node) {
    H.paths.push(newString(<string>'&lt;parent&gt;/&lt;path&gt;.hm'</string>))
    H.paths.push(newString(<string>'./&lt;path&gt;.hm'</string>))
    H.paths.push(newString(<string>'./libs/&lt;path&gt;.hm'</string>))
  } <keyword>else</keyword> {
    <keyword>const</keyword> address <keyword>=</keyword> window.location.href
    <keyword>const</keyword> url <keyword>=</keyword> address.substring(<constant>0</constant>, address.lastIndexOf(<string>'/'</string>) <keyword>+</keyword> <constant>1</constant>)
    H.paths.push(newString(url <keyword>+</keyword> <string>'&lt;path&gt;.hm'</string>))
    H.paths.push(newString(url <keyword>+</keyword> <string>'libs/&lt;path&gt;.hm'</string>))
    H.paths.push(newString(<string>'/&lt;path&gt;.hm'</string>))
    H.paths.push(newString(<string>'/libs/&lt;path&gt;.hm'</string>))
  }

  tablePut(H.globals, <string>'PATHS'</string>, newArrayValue(H.paths))
  tablePut(H.globals, <string>'IMPORTS'</string>, newTableValue(H.imports))
  tablePut(H.globals, <string>'GLOBALS'</string>, newTableValue(H.globals))

  <keyword>return</keyword> H
}

<keyword>if</keyword> (node) {
  module.exports <keyword>=</keyword> {
    version: HYMN_VERSION,
    isFloat: isFloat,
    isFuncNative: isFuncNative,
    isPointer: isPointer,
    newNone: newNone,
    newFloat: newFloat,
    newFuncNativeValue: newFuncNativeValue,
    newPointerValue: newPointerValue,
    newFunction: newFunction,
    newNativeFunction: newNativeFunction,
    addFunction: addFunction,
    addPointer: addPointer,
    interpretScript: interpretScript,
    interpret: interpret,
    direct: direct,
    newVM: newVM,
    debug: debugScript,
  }
}</code></pre></div>
      </section>
    </main>
    <footer>
      <p>
        Made with ❤ by <a href="https://nathanmcmillan.github.io/">Nathan McMillan</a>. You can find the website source code
        <a href="https://github.com/nathanmcmillan/hymn-website">here</a>.
      </p>
    </footer>
  </body>
</html>